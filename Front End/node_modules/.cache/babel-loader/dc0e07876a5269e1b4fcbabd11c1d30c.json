{"ast":null,"code":"'use strict';\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar net = require('net');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nconst {\n  parse,\n  serialize\n} = require('pg-protocol'); // TODO(bmc) support binary mode at some point\n\n\nvar Connection = function (config) {\n  EventEmitter.call(this);\n  config = config || {};\n  this.stream = config.stream || new net.Socket();\n  this._keepAlive = config.keepAlive;\n  this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;\n  this.lastBuffer = false;\n  this.parsedStatements = {};\n  this.ssl = config.ssl || false;\n  this._ending = false;\n  this._emitMessage = false;\n  var self = this;\n  this.on('newListener', function (eventName) {\n    if (eventName === 'message') {\n      self._emitMessage = true;\n    }\n  });\n};\n\nutil.inherits(Connection, EventEmitter);\n\nConnection.prototype.connect = function (port, host) {\n  var self = this;\n  this._connecting = true;\n  this.stream.setNoDelay(true);\n  this.stream.connect(port, host);\n  this.stream.once('connect', function () {\n    if (self._keepAlive) {\n      self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis);\n    }\n\n    self.emit('connect');\n  });\n\n  const reportStreamError = function (error) {\n    // errors about disconnections should be ignored during disconnect\n    if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n      return;\n    }\n\n    self.emit('error', error);\n  };\n\n  this.stream.on('error', reportStreamError);\n  this.stream.on('close', function () {\n    self.emit('end');\n  });\n\n  if (!this.ssl) {\n    return this.attachListeners(this.stream);\n  }\n\n  this.stream.once('data', function (buffer) {\n    var responseCode = buffer.toString('utf8');\n\n    switch (responseCode) {\n      case 'S':\n        // Server supports SSL connections, continue with a secure connection\n        break;\n\n      case 'N':\n        // Server does not support SSL connections\n        self.stream.end();\n        return self.emit('error', new Error('The server does not support SSL connections'));\n\n      default:\n        // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n        self.stream.end();\n        return self.emit('error', new Error('There was an error establishing an SSL connection'));\n    }\n\n    var tls = require('tls');\n\n    const options = Object.assign({\n      socket: self.stream\n    }, self.ssl);\n\n    if (net.isIP(host) === 0) {\n      options.servername = host;\n    }\n\n    self.stream = tls.connect(options);\n    self.attachListeners(self.stream);\n    self.stream.on('error', reportStreamError);\n    self.emit('sslconnect');\n  });\n};\n\nConnection.prototype.attachListeners = function (stream) {\n  stream.on('end', () => {\n    this.emit('end');\n  });\n  parse(stream, msg => {\n    var eventName = msg.name === 'error' ? 'errorMessage' : msg.name;\n\n    if (this._emitMessage) {\n      this.emit('message', msg);\n    }\n\n    this.emit(eventName, msg);\n  });\n};\n\nConnection.prototype.requestSsl = function () {\n  this.stream.write(serialize.requestSsl());\n};\n\nConnection.prototype.startup = function (config) {\n  this.stream.write(serialize.startup(config));\n};\n\nConnection.prototype.cancel = function (processID, secretKey) {\n  this._send(serialize.cancel(processID, secretKey));\n};\n\nConnection.prototype.password = function (password) {\n  this._send(serialize.password(password));\n};\n\nConnection.prototype.sendSASLInitialResponseMessage = function (mechanism, initialResponse) {\n  this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));\n};\n\nConnection.prototype.sendSCRAMClientFinalMessage = function (additionalData) {\n  this._send(serialize.sendSCRAMClientFinalMessage(additionalData));\n};\n\nConnection.prototype._send = function (buffer) {\n  if (!this.stream.writable) {\n    return false;\n  }\n\n  return this.stream.write(buffer);\n};\n\nConnection.prototype.query = function (text) {\n  this._send(serialize.query(text));\n}; // send parse message\n\n\nConnection.prototype.parse = function (query) {\n  this._send(serialize.parse(query));\n}; // send bind message\n// \"more\" === true to buffer the message until flush() is called\n\n\nConnection.prototype.bind = function (config) {\n  this._send(serialize.bind(config));\n}; // send execute message\n// \"more\" === true to buffer the message until flush() is called\n\n\nConnection.prototype.execute = function (config) {\n  this._send(serialize.execute(config));\n};\n\nconst flushBuffer = serialize.flush();\n\nConnection.prototype.flush = function () {\n  if (this.stream.writable) {\n    this.stream.write(flushBuffer);\n  }\n};\n\nconst syncBuffer = serialize.sync();\n\nConnection.prototype.sync = function () {\n  this._ending = true;\n\n  this._send(flushBuffer);\n\n  this._send(syncBuffer);\n};\n\nconst endBuffer = serialize.end();\n\nConnection.prototype.end = function () {\n  // 0x58 = 'X'\n  this._ending = true;\n\n  if (!this._connecting || !this.stream.writable) {\n    this.stream.end();\n    return;\n  }\n\n  return this.stream.write(endBuffer, () => {\n    this.stream.end();\n  });\n};\n\nConnection.prototype.close = function (msg) {\n  this._send(serialize.close(msg));\n};\n\nConnection.prototype.describe = function (msg) {\n  this._send(serialize.describe(msg));\n};\n\nConnection.prototype.sendCopyFromChunk = function (chunk) {\n  this._send(serialize.copyData(chunk));\n};\n\nConnection.prototype.endCopyFrom = function () {\n  this._send(serialize.copyDone());\n};\n\nConnection.prototype.sendCopyFail = function (msg) {\n  this._send(serialize.copyFail(msg));\n};\n\nmodule.exports = Connection;","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg/lib/connection.js"],"names":["net","require","EventEmitter","util","parse","serialize","Connection","config","call","stream","Socket","_keepAlive","keepAlive","_keepAliveInitialDelayMillis","keepAliveInitialDelayMillis","lastBuffer","parsedStatements","ssl","_ending","_emitMessage","self","on","eventName","inherits","prototype","connect","port","host","_connecting","setNoDelay","once","setKeepAlive","emit","reportStreamError","error","code","attachListeners","buffer","responseCode","toString","end","Error","tls","options","Object","assign","socket","isIP","servername","msg","name","requestSsl","write","startup","cancel","processID","secretKey","_send","password","sendSASLInitialResponseMessage","mechanism","initialResponse","sendSCRAMClientFinalMessage","additionalData","writable","query","text","bind","execute","flushBuffer","flush","syncBuffer","sync","endBuffer","close","describe","sendCopyFromChunk","chunk","copyData","endCopyFrom","copyDone","sendCopyFail","copyFail","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar net = require('net')\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\n\nconst { parse, serialize } = require('pg-protocol')\n\n// TODO(bmc) support binary mode at some point\nvar Connection = function (config) {\n  EventEmitter.call(this)\n  config = config || {}\n  this.stream = config.stream || new net.Socket()\n  this._keepAlive = config.keepAlive\n  this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis\n  this.lastBuffer = false\n  this.parsedStatements = {}\n  this.ssl = config.ssl || false\n  this._ending = false\n  this._emitMessage = false\n  var self = this\n  this.on('newListener', function (eventName) {\n    if (eventName === 'message') {\n      self._emitMessage = true\n    }\n  })\n}\n\nutil.inherits(Connection, EventEmitter)\n\nConnection.prototype.connect = function (port, host) {\n  var self = this\n\n  this._connecting = true\n  this.stream.setNoDelay(true)\n  this.stream.connect(port, host)\n\n  this.stream.once('connect', function () {\n    if (self._keepAlive) {\n      self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis)\n    }\n    self.emit('connect')\n  })\n\n  const reportStreamError = function (error) {\n    // errors about disconnections should be ignored during disconnect\n    if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n      return\n    }\n    self.emit('error', error)\n  }\n  this.stream.on('error', reportStreamError)\n\n  this.stream.on('close', function () {\n    self.emit('end')\n  })\n\n  if (!this.ssl) {\n    return this.attachListeners(this.stream)\n  }\n\n  this.stream.once('data', function (buffer) {\n    var responseCode = buffer.toString('utf8')\n    switch (responseCode) {\n      case 'S': // Server supports SSL connections, continue with a secure connection\n        break\n      case 'N': // Server does not support SSL connections\n        self.stream.end()\n        return self.emit('error', new Error('The server does not support SSL connections'))\n      default:\n        // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n        self.stream.end()\n        return self.emit('error', new Error('There was an error establishing an SSL connection'))\n    }\n    var tls = require('tls')\n    const options = Object.assign(\n      {\n        socket: self.stream,\n      },\n      self.ssl\n    )\n    if (net.isIP(host) === 0) {\n      options.servername = host\n    }\n    self.stream = tls.connect(options)\n    self.attachListeners(self.stream)\n    self.stream.on('error', reportStreamError)\n\n    self.emit('sslconnect')\n  })\n}\n\nConnection.prototype.attachListeners = function (stream) {\n  stream.on('end', () => {\n    this.emit('end')\n  })\n  parse(stream, (msg) => {\n    var eventName = msg.name === 'error' ? 'errorMessage' : msg.name\n    if (this._emitMessage) {\n      this.emit('message', msg)\n    }\n    this.emit(eventName, msg)\n  })\n}\n\nConnection.prototype.requestSsl = function () {\n  this.stream.write(serialize.requestSsl())\n}\n\nConnection.prototype.startup = function (config) {\n  this.stream.write(serialize.startup(config))\n}\n\nConnection.prototype.cancel = function (processID, secretKey) {\n  this._send(serialize.cancel(processID, secretKey))\n}\n\nConnection.prototype.password = function (password) {\n  this._send(serialize.password(password))\n}\n\nConnection.prototype.sendSASLInitialResponseMessage = function (mechanism, initialResponse) {\n  this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse))\n}\n\nConnection.prototype.sendSCRAMClientFinalMessage = function (additionalData) {\n  this._send(serialize.sendSCRAMClientFinalMessage(additionalData))\n}\n\nConnection.prototype._send = function (buffer) {\n  if (!this.stream.writable) {\n    return false\n  }\n  return this.stream.write(buffer)\n}\n\nConnection.prototype.query = function (text) {\n  this._send(serialize.query(text))\n}\n\n// send parse message\nConnection.prototype.parse = function (query) {\n  this._send(serialize.parse(query))\n}\n\n// send bind message\n// \"more\" === true to buffer the message until flush() is called\nConnection.prototype.bind = function (config) {\n  this._send(serialize.bind(config))\n}\n\n// send execute message\n// \"more\" === true to buffer the message until flush() is called\nConnection.prototype.execute = function (config) {\n  this._send(serialize.execute(config))\n}\n\nconst flushBuffer = serialize.flush()\nConnection.prototype.flush = function () {\n  if (this.stream.writable) {\n    this.stream.write(flushBuffer)\n  }\n}\n\nconst syncBuffer = serialize.sync()\nConnection.prototype.sync = function () {\n  this._ending = true\n  this._send(flushBuffer)\n  this._send(syncBuffer)\n}\n\nconst endBuffer = serialize.end()\n\nConnection.prototype.end = function () {\n  // 0x58 = 'X'\n  this._ending = true\n  if (!this._connecting || !this.stream.writable) {\n    this.stream.end()\n    return\n  }\n  return this.stream.write(endBuffer, () => {\n    this.stream.end()\n  })\n}\n\nConnection.prototype.close = function (msg) {\n  this._send(serialize.close(msg))\n}\n\nConnection.prototype.describe = function (msg) {\n  this._send(serialize.describe(msg))\n}\n\nConnection.prototype.sendCopyFromChunk = function (chunk) {\n  this._send(serialize.copyData(chunk))\n}\n\nConnection.prototype.endCopyFrom = function () {\n  this._send(serialize.copyDone())\n}\n\nConnection.prototype.sendCopyFail = function (msg) {\n  this._send(serialize.copyFail(msg))\n}\n\nmodule.exports = Connection\n"]},"metadata":{},"sourceType":"script"}