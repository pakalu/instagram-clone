{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\nconst {\n  Events\n} = require(`./events`);\n\nconst {\n  QueryFile\n} = require(`./query-file`);\n\nconst {\n  ServerFormatting,\n  PreparedStatement,\n  ParameterizedQuery\n} = require(`./types`);\n\nconst {\n  SpecialQuery\n} = require(`./special-query`);\n\nconst {\n  queryResult\n} = require(`./query-result`);\n\nconst npm = {\n  util: require(`util`),\n  utils: require(`./utils`),\n  formatting: require(`./formatting`),\n  errors: require(`./errors`),\n  stream: require(`./stream`),\n  text: require(`./text`)\n};\nconst QueryResultError = npm.errors.QueryResultError,\n      InternalError = npm.utils.InternalError,\n      qrec = npm.errors.queryResultErrorCode;\nconst badMask = queryResult.one | queryResult.many; // unsupported combination bit-mask;\n//////////////////////////////\n// Generic query method;\n\nfunction $query(ctx, query, values, qrm, config) {\n  const special = qrm instanceof SpecialQuery && qrm;\n  const $p = config.promise;\n\n  if (special && special.isStream) {\n    return npm.stream.call(this, ctx, query, values, config);\n  }\n\n  const opt = ctx.options,\n        capSQL = opt.capSQL;\n  let error,\n      entityType,\n      pgFormatting = opt.pgFormatting,\n      params = pgFormatting ? values : undefined;\n\n  if (typeof query === `function`) {\n    try {\n      query = npm.formatting.resolveFunc(query, values);\n    } catch (e) {\n      error = e;\n      params = values;\n      query = npm.util.inspect(query);\n    }\n  }\n\n  if (!error && !query) {\n    error = new TypeError(npm.text.invalidQuery);\n  }\n\n  if (!error && typeof query === `object`) {\n    if (query instanceof QueryFile) {\n      query.prepare();\n\n      if (query.error) {\n        error = query.error;\n        query = query.file;\n      } else {\n        query = query[QueryFile.$query];\n      }\n    } else {\n      if (`entity` in query) {\n        entityType = query.type;\n        query = query.entity; // query is a function name;\n      } else {\n        if (query instanceof ServerFormatting) {\n          pgFormatting = true;\n        } else {\n          if (`name` in query) {\n            query = new PreparedStatement(query);\n            pgFormatting = true;\n          } else {\n            if (`text` in query) {\n              query = new ParameterizedQuery(query);\n              pgFormatting = true;\n            }\n          }\n        }\n\n        if (query instanceof ServerFormatting && !npm.utils.isNull(values)) {\n          query.values = values;\n        }\n      }\n    }\n  }\n\n  if (!error) {\n    if (!pgFormatting && !npm.utils.isText(query)) {\n      const errTxt = entityType ? entityType === `func` ? npm.text.invalidFunction : npm.text.invalidProc : npm.text.invalidQuery;\n      error = new TypeError(errTxt);\n    }\n\n    if (query instanceof ServerFormatting) {\n      const qp = query.parse();\n\n      if (qp instanceof Error) {\n        error = qp;\n      } else {\n        query = qp;\n      }\n    }\n  }\n\n  if (!error && !special) {\n    if (npm.utils.isNull(qrm)) {\n      qrm = queryResult.any; // default query result;\n    } else {\n      if (qrm !== parseInt(qrm) || (qrm & badMask) === badMask || qrm < 1 || qrm > 6) {\n        error = new TypeError(npm.text.invalidMask);\n      }\n    }\n  }\n\n  if (!error && (!pgFormatting || entityType)) {\n    try {\n      // use 'pg-promise' implementation of values formatting;\n      if (entityType) {\n        params = undefined;\n        query = npm.formatting.formatEntity(query, values, {\n          capSQL,\n          type: entityType\n        });\n      } else {\n        query = npm.formatting.formatQuery(query, values);\n      }\n    } catch (e) {\n      if (entityType) {\n        let prefix = entityType === `func` ? `select * from` : `call`;\n\n        if (capSQL) {\n          prefix = prefix.toUpperCase();\n        }\n\n        query = prefix + ` ` + query + `(...)`;\n      } else {\n        params = values;\n      }\n\n      error = e instanceof Error ? e : new npm.utils.InternalError(e);\n    }\n  }\n\n  return $p((resolve, reject) => {\n    if (notifyReject()) {\n      return;\n    }\n\n    error = Events.query(opt, getContext());\n\n    if (notifyReject()) {\n      return;\n    }\n\n    try {\n      const start = Date.now();\n      ctx.db.client.query(query, params, (err, result) => {\n        let data,\n            multiResult,\n            lastResult = result;\n\n        if (err) {\n          // istanbul ignore if (auto-testing connectivity issues is too problematic)\n          if (npm.utils.isConnectivityError(err)) {\n            ctx.db.client.$connectionError = err;\n          }\n\n          error = err;\n        } else {\n          multiResult = Array.isArray(result);\n\n          if (multiResult) {\n            lastResult = result[result.length - 1];\n\n            for (let i = 0; i < result.length; i++) {\n              const r = result[i];\n              error = Events.receive(opt, r.rows, r, getContext());\n\n              if (error) {\n                break;\n              }\n            }\n          } else {\n            result.duration = Date.now() - start;\n            error = Events.receive(opt, result.rows, result, getContext());\n          }\n        }\n\n        if (!error) {\n          data = lastResult;\n\n          if (special) {\n            if (special.isMultiResult) {\n              data = multiResult ? result : [result]; // method .multiResult() is called\n            } // else, method .result() is called\n\n          } else {\n            data = data.rows;\n            const len = data.length;\n\n            if (len) {\n              if (len > 1 && qrm & queryResult.one) {\n                // one row was expected, but returned multiple;\n                error = new QueryResultError(qrec.multiple, lastResult, query, params);\n              } else {\n                if (!(qrm & (queryResult.one | queryResult.many))) {\n                  // no data should have been returned;\n                  error = new QueryResultError(qrec.notEmpty, lastResult, query, params);\n                } else {\n                  if (!(qrm & queryResult.many)) {\n                    data = data[0];\n                  }\n                }\n              }\n            } else {\n              // no data returned;\n              if (qrm & queryResult.none) {\n                if (qrm & queryResult.one) {\n                  data = null;\n                } else {\n                  data = qrm & queryResult.many ? data : null;\n                }\n              } else {\n                error = new QueryResultError(qrec.noData, lastResult, query, params);\n              }\n            }\n          }\n        }\n\n        if (!notifyReject()) {\n          resolve(data);\n        }\n      });\n    } catch (e) {\n      // this can only happen as a result of an internal failure within node-postgres,\n      // like during a sudden loss of communications, which is impossible to reproduce\n      // automatically, so removing it from the test coverage:\n      // istanbul ignore next\n      error = e;\n    }\n\n    function getContext() {\n      let client;\n\n      if (ctx.db) {\n        client = ctx.db.client;\n      } else {\n        error = new Error(npm.text.looseQuery);\n      }\n\n      return {\n        client,\n        query,\n        params,\n        dc: ctx.dc,\n        ctx: ctx.ctx\n      };\n    }\n\n    notifyReject();\n\n    function notifyReject() {\n      const context = getContext();\n\n      if (error) {\n        if (error instanceof InternalError) {\n          error = error.error;\n        }\n\n        Events.error(opt, error, context);\n        reject(error);\n        return true;\n      }\n    }\n  });\n}\n\nmodule.exports = config => {\n  return function (ctx, query, values, qrm) {\n    return $query.call(this, ctx, query, values, qrm, config);\n  };\n};","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg-promise/lib/query.js"],"names":["Events","require","QueryFile","ServerFormatting","PreparedStatement","ParameterizedQuery","SpecialQuery","queryResult","npm","util","utils","formatting","errors","stream","text","QueryResultError","InternalError","qrec","queryResultErrorCode","badMask","one","many","$query","ctx","query","values","qrm","config","special","$p","promise","isStream","call","opt","options","capSQL","error","entityType","pgFormatting","params","undefined","resolveFunc","e","inspect","TypeError","invalidQuery","prepare","file","type","entity","isNull","isText","errTxt","invalidFunction","invalidProc","qp","parse","Error","any","parseInt","invalidMask","formatEntity","formatQuery","prefix","toUpperCase","resolve","reject","notifyReject","getContext","start","Date","now","db","client","err","result","data","multiResult","lastResult","isConnectivityError","$connectionError","Array","isArray","length","i","r","receive","rows","duration","isMultiResult","len","multiple","notEmpty","none","noData","looseQuery","dc","context","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {Events} = require(`./events`);\r\nconst {QueryFile} = require(`./query-file`);\r\nconst {ServerFormatting, PreparedStatement, ParameterizedQuery} = require(`./types`);\r\nconst {SpecialQuery} = require(`./special-query`);\r\nconst {queryResult} = require(`./query-result`);\r\n\r\nconst npm = {\r\n    util: require(`util`),\r\n    utils: require(`./utils`),\r\n    formatting: require(`./formatting`),\r\n    errors: require(`./errors`),\r\n    stream: require(`./stream`),\r\n    text: require(`./text`)\r\n};\r\n\r\nconst QueryResultError = npm.errors.QueryResultError,\r\n    InternalError = npm.utils.InternalError,\r\n    qrec = npm.errors.queryResultErrorCode;\r\n\r\nconst badMask = queryResult.one | queryResult.many; // unsupported combination bit-mask;\r\n\r\n//////////////////////////////\r\n// Generic query method;\r\nfunction $query(ctx, query, values, qrm, config) {\r\n\r\n    const special = qrm instanceof SpecialQuery && qrm;\r\n    const $p = config.promise;\r\n\r\n    if (special && special.isStream) {\r\n        return npm.stream.call(this, ctx, query, values, config);\r\n    }\r\n\r\n    const opt = ctx.options,\r\n        capSQL = opt.capSQL;\r\n\r\n    let error, entityType,\r\n        pgFormatting = opt.pgFormatting,\r\n        params = pgFormatting ? values : undefined;\r\n\r\n    if (typeof query === `function`) {\r\n        try {\r\n            query = npm.formatting.resolveFunc(query, values);\r\n        } catch (e) {\r\n            error = e;\r\n            params = values;\r\n            query = npm.util.inspect(query);\r\n        }\r\n    }\r\n\r\n    if (!error && !query) {\r\n        error = new TypeError(npm.text.invalidQuery);\r\n    }\r\n\r\n    if (!error && typeof query === `object`) {\r\n        if (query instanceof QueryFile) {\r\n            query.prepare();\r\n            if (query.error) {\r\n                error = query.error;\r\n                query = query.file;\r\n            } else {\r\n                query = query[QueryFile.$query];\r\n            }\r\n        } else {\r\n            if (`entity` in query) {\r\n                entityType = query.type;\r\n                query = query.entity; // query is a function name;\r\n            } else {\r\n                if (query instanceof ServerFormatting) {\r\n                    pgFormatting = true;\r\n                } else {\r\n                    if (`name` in query) {\r\n                        query = new PreparedStatement(query);\r\n                        pgFormatting = true;\r\n                    } else {\r\n                        if (`text` in query) {\r\n                            query = new ParameterizedQuery(query);\r\n                            pgFormatting = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (query instanceof ServerFormatting && !npm.utils.isNull(values)) {\r\n                    query.values = values;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!error) {\r\n        if (!pgFormatting && !npm.utils.isText(query)) {\r\n            const errTxt = entityType ? (entityType === `func` ? npm.text.invalidFunction : npm.text.invalidProc) : npm.text.invalidQuery;\r\n            error = new TypeError(errTxt);\r\n        }\r\n        if (query instanceof ServerFormatting) {\r\n            const qp = query.parse();\r\n            if (qp instanceof Error) {\r\n                error = qp;\r\n            } else {\r\n                query = qp;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!error && !special) {\r\n        if (npm.utils.isNull(qrm)) {\r\n            qrm = queryResult.any; // default query result;\r\n        } else {\r\n            if (qrm !== parseInt(qrm) || (qrm & badMask) === badMask || qrm < 1 || qrm > 6) {\r\n                error = new TypeError(npm.text.invalidMask);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!error && (!pgFormatting || entityType)) {\r\n        try {\r\n            // use 'pg-promise' implementation of values formatting;\r\n            if (entityType) {\r\n                params = undefined;\r\n                query = npm.formatting.formatEntity(query, values, {capSQL, type: entityType});\r\n            } else {\r\n                query = npm.formatting.formatQuery(query, values);\r\n            }\r\n        } catch (e) {\r\n            if (entityType) {\r\n                let prefix = entityType === `func` ? `select * from` : `call`;\r\n                if (capSQL) {\r\n                    prefix = prefix.toUpperCase();\r\n                }\r\n                query = prefix + ` ` + query + `(...)`;\r\n            } else {\r\n                params = values;\r\n            }\r\n            error = e instanceof Error ? e : new npm.utils.InternalError(e);\r\n        }\r\n    }\r\n\r\n    return $p((resolve, reject) => {\r\n\r\n        if (notifyReject()) {\r\n            return;\r\n        }\r\n        error = Events.query(opt, getContext());\r\n        if (notifyReject()) {\r\n            return;\r\n        }\r\n        try {\r\n            const start = Date.now();\r\n            ctx.db.client.query(query, params, (err, result) => {\r\n                let data, multiResult, lastResult = result;\r\n                if (err) {\r\n                    // istanbul ignore if (auto-testing connectivity issues is too problematic)\r\n                    if (npm.utils.isConnectivityError(err)) {\r\n                        ctx.db.client.$connectionError = err;\r\n                    }\r\n                    error = err;\r\n                } else {\r\n                    multiResult = Array.isArray(result);\r\n                    if (multiResult) {\r\n                        lastResult = result[result.length - 1];\r\n                        for (let i = 0; i < result.length; i++) {\r\n                            const r = result[i];\r\n                            error = Events.receive(opt, r.rows, r, getContext());\r\n                            if (error) {\r\n                                break;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        result.duration = Date.now() - start;\r\n                        error = Events.receive(opt, result.rows, result, getContext());\r\n                    }\r\n                }\r\n                if (!error) {\r\n                    data = lastResult;\r\n                    if (special) {\r\n                        if (special.isMultiResult) {\r\n                            data = multiResult ? result : [result]; // method .multiResult() is called\r\n                        }\r\n                        // else, method .result() is called\r\n                    } else {\r\n                        data = data.rows;\r\n                        const len = data.length;\r\n                        if (len) {\r\n                            if (len > 1 && qrm & queryResult.one) {\r\n                                // one row was expected, but returned multiple;\r\n                                error = new QueryResultError(qrec.multiple, lastResult, query, params);\r\n                            } else {\r\n                                if (!(qrm & (queryResult.one | queryResult.many))) {\r\n                                    // no data should have been returned;\r\n                                    error = new QueryResultError(qrec.notEmpty, lastResult, query, params);\r\n                                } else {\r\n                                    if (!(qrm & queryResult.many)) {\r\n                                        data = data[0];\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            // no data returned;\r\n                            if (qrm & queryResult.none) {\r\n                                if (qrm & queryResult.one) {\r\n                                    data = null;\r\n                                } else {\r\n                                    data = qrm & queryResult.many ? data : null;\r\n                                }\r\n                            } else {\r\n                                error = new QueryResultError(qrec.noData, lastResult, query, params);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!notifyReject()) {\r\n                    resolve(data);\r\n                }\r\n            });\r\n        } catch (e) {\r\n            // this can only happen as a result of an internal failure within node-postgres,\r\n            // like during a sudden loss of communications, which is impossible to reproduce\r\n            // automatically, so removing it from the test coverage:\r\n            // istanbul ignore next\r\n            error = e;\r\n        }\r\n\r\n        function getContext() {\r\n            let client;\r\n            if (ctx.db) {\r\n                client = ctx.db.client;\r\n            } else {\r\n                error = new Error(npm.text.looseQuery);\r\n            }\r\n            return {\r\n                client, query, params,\r\n                dc: ctx.dc,\r\n                ctx: ctx.ctx\r\n            };\r\n        }\r\n\r\n        notifyReject();\r\n\r\n        function notifyReject() {\r\n            const context = getContext();\r\n            if (error) {\r\n                if (error instanceof InternalError) {\r\n                    error = error.error;\r\n                }\r\n                Events.error(opt, error, context);\r\n                reject(error);\r\n                return true;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nmodule.exports = config => {\r\n    return function (ctx, query, values, qrm) {\r\n        return $query.call(this, ctx, query, values, qrm, config);\r\n    };\r\n};\r\n"]},"metadata":{},"sourceType":"script"}