{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\nconst {\n  InnerState\n} = require(`../inner-state`);\n\nconst {\n  assertOptions\n} = require(`assert-options`);\n\nconst npm = {\n  os: require(`os`),\n  utils: require(`../utils`),\n  formatting: require(`../formatting`),\n  patterns: require(`../patterns`)\n};\n/**\r\n *\r\n * @class helpers.Column\r\n * @description\r\n *\r\n * Read-only structure with details for a single column. Used primarily by {@link helpers.ColumnSet ColumnSet}.\r\n *\r\n * The class parses details into a template, to be used for query generation.\r\n *\r\n * @param {string|helpers.ColumnConfig} col\r\n * Column details, depending on the type.\r\n *\r\n * When it is a string, it is expected to contain a name for both the column and the source property, assuming that the two are the same.\r\n * The name must adhere to JavaScript syntax for variable names. The name can be appended with any format modifier as supported by\r\n * {@link formatting.format as.format} (`^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`), which is then removed from the name and put\r\n * into property `mod`. If the name starts with `?`, it is removed, while setting flag `cnd` = `true`.\r\n *\r\n * If the string doesn't adhere to the above requirements, the method will throw {@link external:TypeError TypeError} = `Invalid column syntax`.\r\n *\r\n * When `col` is a simple {@link helpers.ColumnConfig ColumnConfig}-like object, it is used as an input configurator to set all the properties\r\n * of the class.\r\n *\r\n * @property {string} name\r\n * Destination column name + source property name (if `prop` is skipped). The name must adhere to JavaScript syntax for variables,\r\n * unless `prop` is specified, in which case `name` represents only the column name, and therefore can be any non-empty string.\r\n *\r\n * @property {string} [prop]\r\n * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.\r\n *\r\n * It is ignored when it is the same as `name`.\r\n *\r\n * @property {string} [mod]\r\n * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`.\r\n *\r\n * @property {string} [cast]\r\n * Server-side type casting, without `::` in front.\r\n *\r\n * @property {boolean} [cnd]\r\n * Conditional column flag.\r\n *\r\n * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and\r\n * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.\r\n *\r\n * It can be set from a string initialization, by adding `?` in front of the name.\r\n *\r\n * @property {*} [def]\r\n * Default value for the property, to be used only when the source object doesn't have the property.\r\n * It is ignored when property `init` is set.\r\n *\r\n * @property {helpers.initCB} [init]\r\n * Override callback for the value.\r\n *\r\n * @property {helpers.skipCB} [skip]\r\n * An override for skipping columns dynamically.\r\n *\r\n * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods\r\n * {@link helpers.insert insert} and {@link helpers.values values}.\r\n *\r\n * It is also ignored when conditional flag `cnd` is set.\r\n *\r\n * @returns {helpers.Column}\r\n *\r\n * @see\r\n * {@link helpers.ColumnConfig ColumnConfig},\r\n * {@link helpers.Column#castText castText},\r\n * {@link helpers.Column#escapedName escapedName},\r\n * {@link helpers.Column#variable variable}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')({\r\n *     capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * const Column = pgp.helpers.Column;\r\n *\r\n * // creating a column from just a name:\r\n * const col1 = new Column('colName');\r\n * console.log(col1);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * // }\r\n *\r\n * // creating a column from a name + modifier:\r\n * const col2 = new Column('colName:csv');\r\n * console.log(col2);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * //    mod: \":csv\"\r\n * // }\r\n *\r\n * // creating a column from a configurator:\r\n * const col3 = new Column({\r\n *     name: 'colName', // required\r\n *     prop: 'propName', // optional\r\n *     mod: '^', // optional\r\n *     def: 123 // optional\r\n * });\r\n * console.log(col3);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * //    prop: \"propName\"\r\n * //    mod: \"^\"\r\n * //    def: 123\r\n * // }\r\n *\r\n */\n\nclass Column extends InnerState {\n  constructor(col) {\n    super();\n\n    if (typeof col === `string`) {\n      const info = parseColumn(col);\n      this.name = info.name;\n\n      if (`mod` in info) {\n        this.mod = info.mod;\n      }\n\n      if (`cnd` in info) {\n        this.cnd = info.cnd;\n      }\n    } else {\n      col = assertOptions(col, [`name`, `prop`, `mod`, `cast`, `cnd`, `def`, `init`, `skip`]);\n\n      if (`name` in col) {\n        if (!npm.utils.isText(col.name)) {\n          throw new TypeError(`Invalid 'name' value: ${npm.utils.toJson(col.name)}. A non-empty string was expected.`);\n        }\n\n        if (npm.utils.isNull(col.prop) && !isValidVariable(col.name)) {\n          throw new TypeError(`Invalid 'name' syntax: ${npm.utils.toJson(col.name)}.`);\n        }\n\n        this.name = col.name; // column name + property name (if 'prop' isn't specified)\n\n        if (!npm.utils.isNull(col.prop)) {\n          if (!npm.utils.isText(col.prop)) {\n            throw new TypeError(`Invalid 'prop' value: ${npm.utils.toJson(col.prop)}. A non-empty string was expected.`);\n          }\n\n          if (!isValidVariable(col.prop)) {\n            throw new TypeError(`Invalid 'prop' syntax: ${npm.utils.toJson(col.prop)}.`);\n          }\n\n          if (col.prop !== col.name) {\n            // optional property name, if different from the column's name;\n            this.prop = col.prop;\n          }\n        }\n\n        if (!npm.utils.isNull(col.mod)) {\n          if (typeof col.mod !== `string` || !isValidMod(col.mod)) {\n            throw new TypeError(`Invalid 'mod' value: ${npm.utils.toJson(col.mod)}.`);\n          }\n\n          this.mod = col.mod; // optional format modifier;\n        }\n\n        if (!npm.utils.isNull(col.cast)) {\n          this.cast = parseCast(col.cast); // optional SQL type casting\n        }\n\n        if (`cnd` in col) {\n          this.cnd = !!col.cnd;\n        }\n\n        if (`def` in col) {\n          this.def = col.def; // optional default\n        }\n\n        if (typeof col.init === `function`) {\n          this.init = col.init; // optional value override (overrides 'def' also)\n        }\n\n        if (typeof col.skip === `function`) {\n          this.skip = col.skip;\n        }\n      } else {\n        throw new TypeError(`Invalid column details.`);\n      }\n    }\n\n    const variable = `\\${` + (this.prop || this.name) + (this.mod || ``) + `}`;\n    const castText = this.cast ? `::` + this.cast : ``;\n    const escapedName = npm.formatting.as.name(this.name);\n    this.extendState({\n      variable,\n      castText,\n      escapedName\n    });\n    Object.freeze(this);\n  }\n  /**\r\n   * @name helpers.Column#variable\r\n   * @type string\r\n   * @readonly\r\n   * @description\r\n   * Full-syntax formatting variable, ready for direct use in query templates.\r\n   *\r\n   * @example\r\n   *\r\n   * const cs = new pgp.helpers.ColumnSet([\r\n   *     'id',\r\n   *     'coordinate:json',\r\n   *     {\r\n   *         name: 'places',\r\n   *         mod: ':csv',\r\n   *         cast: 'int[]'\r\n   *     }\r\n   * ]);\r\n   *\r\n   * // cs.columns[0].variable = ${id}\r\n   * // cs.columns[1].variable = ${coordinate:json}\r\n   * // cs.columns[2].variable = ${places:csv}::int[]\r\n   */\n\n\n  get variable() {\n    return this._inner.variable;\n  }\n  /**\r\n   * @name helpers.Column#castText\r\n   * @type string\r\n   * @readonly\r\n   * @description\r\n   * Full-syntax sql type casting, if there is any, or else an empty string.\r\n   */\n\n\n  get castText() {\n    return this._inner.castText;\n  }\n  /**\r\n   * @name helpers.Column#escapedName\r\n   * @type string\r\n   * @readonly\r\n   * @description\r\n   * Escaped name of the column, ready to be injected into queries directly.\r\n   *\r\n   */\n\n\n  get escapedName() {\n    return this._inner.escapedName;\n  }\n\n}\n\nfunction parseCast(name) {\n  if (typeof name === `string`) {\n    const s = name.replace(/^[:\\s]*|\\s*$/g, ``);\n\n    if (s) {\n      return s;\n    }\n  }\n\n  throw new TypeError(`Invalid 'cast' value: ${npm.utils.toJson(name)}.`);\n}\n\nfunction parseColumn(name) {\n  const m = name.match(npm.patterns.validColumn);\n\n  if (m && m[0] === name) {\n    const res = {};\n\n    if (name[0] === `?`) {\n      res.cnd = true;\n      name = name.substr(1);\n    }\n\n    const mod = name.match(npm.patterns.hasValidModifier);\n\n    if (mod) {\n      res.name = name.substr(0, mod.index);\n      res.mod = mod[0];\n    } else {\n      res.name = name;\n    }\n\n    return res;\n  }\n\n  throw new TypeError(`Invalid column syntax: ${npm.utils.toJson(name)}.`);\n}\n\nfunction isValidMod(mod) {\n  return npm.patterns.validModifiers.indexOf(mod) !== -1;\n}\n\nfunction isValidVariable(name) {\n  const m = name.match(npm.patterns.validVariable);\n  return !!m && m[0] === name;\n}\n/**\r\n * @method helpers.Column#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\n\n\nColumn.prototype.toString = function (level) {\n  level = level > 0 ? parseInt(level) : 0;\n  const gap0 = npm.utils.messageGap(level),\n        gap1 = npm.utils.messageGap(level + 1),\n        lines = [gap0 + `Column {`, gap1 + `name: ` + npm.utils.toJson(this.name)];\n\n  if (`prop` in this) {\n    lines.push(gap1 + `prop: ` + npm.utils.toJson(this.prop));\n  }\n\n  if (`mod` in this) {\n    lines.push(gap1 + `mod: ` + npm.utils.toJson(this.mod));\n  }\n\n  if (`cast` in this) {\n    lines.push(gap1 + `cast: ` + npm.utils.toJson(this.cast));\n  }\n\n  if (`cnd` in this) {\n    lines.push(gap1 + `cnd: ` + npm.utils.toJson(this.cnd));\n  }\n\n  if (`def` in this) {\n    lines.push(gap1 + `def: ` + npm.utils.toJson(this.def));\n  }\n\n  if (`init` in this) {\n    lines.push(gap1 + `init: [Function]`);\n  }\n\n  if (`skip` in this) {\n    lines.push(gap1 + `skip: [Function]`);\n  }\n\n  lines.push(gap0 + `}`);\n  return lines.join(npm.os.EOL);\n};\n\nnpm.utils.addInspection(Column, function () {\n  return this.toString();\n});\n/**\r\n * @typedef helpers.ColumnConfig\r\n * @description\r\n * A simple structure with column details, to be passed into the {@link helpers.Column Column} constructor for initialization.\r\n *\r\n * @property {string} name\r\n * Destination column name + source property name (if `prop` is skipped). The name must adhere to JavaScript syntax for variables,\r\n * unless `prop` is specified, in which case `name` represents only the column name, and therefore can be any non-empty string.\r\n *\r\n * @property {string} [prop]\r\n * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.\r\n *\r\n * It is ignored when it is the same as `name`.\r\n *\r\n * @property {string} [mod]\r\n * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`.\r\n *\r\n * @property {string} [cast]\r\n * Server-side type casting. Leading `::` is allowed, but not needed (automatically removed when specified).\r\n *\r\n * @property {boolean} [cnd]\r\n * Conditional column flag.\r\n *\r\n * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and\r\n * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.\r\n *\r\n * It can be set from a string initialization, by adding `?` in front of the name.\r\n *\r\n * @property {*} [def]\r\n * Default value for the property, to be used only when the source object doesn't have the property.\r\n * It is ignored when property `init` is set.\r\n *\r\n * @property {helpers.initCB} [init]\r\n * Override callback for the value.\r\n *\r\n * @property {helpers.skipCB} [skip]\r\n * An override for skipping columns dynamically.\r\n *\r\n * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods\r\n * {@link helpers.insert insert} and {@link helpers.values values}.\r\n *\r\n * It is also ignored when conditional flag `cnd` is set.\r\n *\r\n */\n\n/**\r\n * @callback helpers.initCB\r\n * @description\r\n * A callback function type used by parameter `init` within {@link helpers.ColumnConfig ColumnConfig}.\r\n *\r\n * It works as an override for the corresponding property value in the `source` object.\r\n *\r\n * The function is called with `this` set to the `source` object.\r\n *\r\n * @param {*} col\r\n * Column-to-property descriptor.\r\n *\r\n * @param {object} col.source\r\n * The source object, equals to `this` that's passed into the function.\r\n *\r\n * @param {string} col.name\r\n * Resolved name of the property within the `source` object, i.e. the value of `name` when `prop` is not used\r\n * for the column, or the value of `prop` when it is specified.\r\n *\r\n * @param {*} col.value\r\n *\r\n * Property value, set to one of the following:\r\n *\r\n * - Value of the property within the `source` object (`value` = `source[name]`), if the property exists\r\n * - If the property doesn't exist and `def` is set in the column, then `value` is set to the value of `def`\r\n * - If the property doesn't exist and `def` is not set in the column, then `value` is set to `undefined`\r\n *\r\n * @param {boolean} col.exists\r\n * Indicates whether the property exists in the `source` object (`exists = name in source`).\r\n *\r\n * @returns {*}\r\n * The new value to be used for the corresponding column.\r\n */\n\n/**\r\n * @callback helpers.skipCB\r\n * @description\r\n * A callback function type used by parameter `skip` within {@link helpers.ColumnConfig ColumnConfig}.\r\n *\r\n * It is to dynamically determine when the property with specified `name` in the `source` object is to be skipped.\r\n *\r\n * The function is called with `this` set to the `source` object.\r\n *\r\n * @param {*} col\r\n * Column-to-property descriptor.\r\n *\r\n * @param {object} col.source\r\n * The source object, equals to `this` that's passed into the function.\r\n *\r\n * @param {string} col.name\r\n * Resolved name of the property within the `source` object, i.e. the value of `name` when `prop` is not used\r\n * for the column, or the value of `prop` when it is specified.\r\n *\r\n * @param {*} col.value\r\n *\r\n * Property value, set to one of the following:\r\n *\r\n * - Value of the property within the `source` object (`value` = `source[name]`), if the property exists\r\n * - If the property doesn't exist and `def` is set in the column, then `value` is set to the value of `def`\r\n * - If the property doesn't exist and `def` is not set in the column, then `value` is set to `undefined`\r\n *\r\n * @param {boolean} col.exists\r\n * Indicates whether the property exists in the `source` object (`exists = name in source`).\r\n *\r\n * @returns {boolean}\r\n * A truthy value that indicates whether the column is to be skipped.\r\n *\r\n */\n\nmodule.exports = {\n  Column\n};","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg-promise/lib/helpers/column.js"],"names":["InnerState","require","assertOptions","npm","os","utils","formatting","patterns","Column","constructor","col","info","parseColumn","name","mod","cnd","isText","TypeError","toJson","isNull","prop","isValidVariable","isValidMod","cast","parseCast","def","init","skip","variable","castText","escapedName","as","extendState","Object","freeze","_inner","s","replace","m","match","validColumn","res","substr","hasValidModifier","index","validModifiers","indexOf","validVariable","prototype","toString","level","parseInt","gap0","messageGap","gap1","lines","push","join","EOL","addInspection","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {InnerState} = require(`../inner-state`);\r\nconst {assertOptions} = require(`assert-options`);\r\n\r\nconst npm = {\r\n    os: require(`os`),\r\n    utils: require(`../utils`),\r\n    formatting: require(`../formatting`),\r\n    patterns: require(`../patterns`)\r\n};\r\n\r\n/**\r\n *\r\n * @class helpers.Column\r\n * @description\r\n *\r\n * Read-only structure with details for a single column. Used primarily by {@link helpers.ColumnSet ColumnSet}.\r\n *\r\n * The class parses details into a template, to be used for query generation.\r\n *\r\n * @param {string|helpers.ColumnConfig} col\r\n * Column details, depending on the type.\r\n *\r\n * When it is a string, it is expected to contain a name for both the column and the source property, assuming that the two are the same.\r\n * The name must adhere to JavaScript syntax for variable names. The name can be appended with any format modifier as supported by\r\n * {@link formatting.format as.format} (`^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`), which is then removed from the name and put\r\n * into property `mod`. If the name starts with `?`, it is removed, while setting flag `cnd` = `true`.\r\n *\r\n * If the string doesn't adhere to the above requirements, the method will throw {@link external:TypeError TypeError} = `Invalid column syntax`.\r\n *\r\n * When `col` is a simple {@link helpers.ColumnConfig ColumnConfig}-like object, it is used as an input configurator to set all the properties\r\n * of the class.\r\n *\r\n * @property {string} name\r\n * Destination column name + source property name (if `prop` is skipped). The name must adhere to JavaScript syntax for variables,\r\n * unless `prop` is specified, in which case `name` represents only the column name, and therefore can be any non-empty string.\r\n *\r\n * @property {string} [prop]\r\n * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.\r\n *\r\n * It is ignored when it is the same as `name`.\r\n *\r\n * @property {string} [mod]\r\n * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`.\r\n *\r\n * @property {string} [cast]\r\n * Server-side type casting, without `::` in front.\r\n *\r\n * @property {boolean} [cnd]\r\n * Conditional column flag.\r\n *\r\n * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and\r\n * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.\r\n *\r\n * It can be set from a string initialization, by adding `?` in front of the name.\r\n *\r\n * @property {*} [def]\r\n * Default value for the property, to be used only when the source object doesn't have the property.\r\n * It is ignored when property `init` is set.\r\n *\r\n * @property {helpers.initCB} [init]\r\n * Override callback for the value.\r\n *\r\n * @property {helpers.skipCB} [skip]\r\n * An override for skipping columns dynamically.\r\n *\r\n * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods\r\n * {@link helpers.insert insert} and {@link helpers.values values}.\r\n *\r\n * It is also ignored when conditional flag `cnd` is set.\r\n *\r\n * @returns {helpers.Column}\r\n *\r\n * @see\r\n * {@link helpers.ColumnConfig ColumnConfig},\r\n * {@link helpers.Column#castText castText},\r\n * {@link helpers.Column#escapedName escapedName},\r\n * {@link helpers.Column#variable variable}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')({\r\n *     capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * const Column = pgp.helpers.Column;\r\n *\r\n * // creating a column from just a name:\r\n * const col1 = new Column('colName');\r\n * console.log(col1);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * // }\r\n *\r\n * // creating a column from a name + modifier:\r\n * const col2 = new Column('colName:csv');\r\n * console.log(col2);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * //    mod: \":csv\"\r\n * // }\r\n *\r\n * // creating a column from a configurator:\r\n * const col3 = new Column({\r\n *     name: 'colName', // required\r\n *     prop: 'propName', // optional\r\n *     mod: '^', // optional\r\n *     def: 123 // optional\r\n * });\r\n * console.log(col3);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * //    prop: \"propName\"\r\n * //    mod: \"^\"\r\n * //    def: 123\r\n * // }\r\n *\r\n */\r\nclass Column extends InnerState {\r\n\r\n    constructor(col) {\r\n        super();\r\n\r\n        if (typeof col === `string`) {\r\n            const info = parseColumn(col);\r\n            this.name = info.name;\r\n            if (`mod` in info) {\r\n                this.mod = info.mod;\r\n            }\r\n            if (`cnd` in info) {\r\n                this.cnd = info.cnd;\r\n            }\r\n        } else {\r\n            col = assertOptions(col, [`name`, `prop`, `mod`, `cast`, `cnd`, `def`, `init`, `skip`]);\r\n            if (`name` in col) {\r\n                if (!npm.utils.isText(col.name)) {\r\n                    throw new TypeError(`Invalid 'name' value: ${npm.utils.toJson(col.name)}. A non-empty string was expected.`);\r\n                }\r\n                if (npm.utils.isNull(col.prop) && !isValidVariable(col.name)) {\r\n                    throw new TypeError(`Invalid 'name' syntax: ${npm.utils.toJson(col.name)}.`);\r\n                }\r\n                this.name = col.name; // column name + property name (if 'prop' isn't specified)\r\n\r\n                if (!npm.utils.isNull(col.prop)) {\r\n                    if (!npm.utils.isText(col.prop)) {\r\n                        throw new TypeError(`Invalid 'prop' value: ${npm.utils.toJson(col.prop)}. A non-empty string was expected.`);\r\n                    }\r\n                    if (!isValidVariable(col.prop)) {\r\n                        throw new TypeError(`Invalid 'prop' syntax: ${npm.utils.toJson(col.prop)}.`);\r\n                    }\r\n                    if (col.prop !== col.name) {\r\n                        // optional property name, if different from the column's name;\r\n                        this.prop = col.prop;\r\n                    }\r\n                }\r\n                if (!npm.utils.isNull(col.mod)) {\r\n                    if (typeof col.mod !== `string` || !isValidMod(col.mod)) {\r\n                        throw new TypeError(`Invalid 'mod' value: ${npm.utils.toJson(col.mod)}.`);\r\n                    }\r\n                    this.mod = col.mod; // optional format modifier;\r\n                }\r\n                if (!npm.utils.isNull(col.cast)) {\r\n                    this.cast = parseCast(col.cast); // optional SQL type casting\r\n                }\r\n                if (`cnd` in col) {\r\n                    this.cnd = !!col.cnd;\r\n                }\r\n                if (`def` in col) {\r\n                    this.def = col.def; // optional default\r\n                }\r\n                if (typeof col.init === `function`) {\r\n                    this.init = col.init; // optional value override (overrides 'def' also)\r\n                }\r\n                if (typeof col.skip === `function`) {\r\n                    this.skip = col.skip;\r\n                }\r\n            } else {\r\n                throw new TypeError(`Invalid column details.`);\r\n            }\r\n        }\r\n\r\n        const variable = `\\${` + (this.prop || this.name) + (this.mod || ``) + `}`;\r\n        const castText = this.cast ? (`::` + this.cast) : ``;\r\n        const escapedName = npm.formatting.as.name(this.name);\r\n\r\n        this.extendState({variable, castText, escapedName});\r\n        Object.freeze(this);\r\n    }\r\n\r\n    /**\r\n     * @name helpers.Column#variable\r\n     * @type string\r\n     * @readonly\r\n     * @description\r\n     * Full-syntax formatting variable, ready for direct use in query templates.\r\n     *\r\n     * @example\r\n     *\r\n     * const cs = new pgp.helpers.ColumnSet([\r\n     *     'id',\r\n     *     'coordinate:json',\r\n     *     {\r\n     *         name: 'places',\r\n     *         mod: ':csv',\r\n     *         cast: 'int[]'\r\n     *     }\r\n     * ]);\r\n     *\r\n     * // cs.columns[0].variable = ${id}\r\n     * // cs.columns[1].variable = ${coordinate:json}\r\n     * // cs.columns[2].variable = ${places:csv}::int[]\r\n     */\r\n    get variable() {\r\n        return this._inner.variable;\r\n    }\r\n\r\n    /**\r\n     * @name helpers.Column#castText\r\n     * @type string\r\n     * @readonly\r\n     * @description\r\n     * Full-syntax sql type casting, if there is any, or else an empty string.\r\n     */\r\n    get castText() {\r\n        return this._inner.castText;\r\n    }\r\n\r\n    /**\r\n     * @name helpers.Column#escapedName\r\n     * @type string\r\n     * @readonly\r\n     * @description\r\n     * Escaped name of the column, ready to be injected into queries directly.\r\n     *\r\n     */\r\n    get escapedName() {\r\n        return this._inner.escapedName;\r\n    }\r\n\r\n}\r\n\r\nfunction parseCast(name) {\r\n    if (typeof name === `string`) {\r\n        const s = name.replace(/^[:\\s]*|\\s*$/g, ``);\r\n        if (s) {\r\n            return s;\r\n        }\r\n    }\r\n    throw new TypeError(`Invalid 'cast' value: ${npm.utils.toJson(name)}.`);\r\n}\r\n\r\nfunction parseColumn(name) {\r\n    const m = name.match(npm.patterns.validColumn);\r\n    if (m && m[0] === name) {\r\n        const res = {};\r\n        if (name[0] === `?`) {\r\n            res.cnd = true;\r\n            name = name.substr(1);\r\n        }\r\n        const mod = name.match(npm.patterns.hasValidModifier);\r\n        if (mod) {\r\n            res.name = name.substr(0, mod.index);\r\n            res.mod = mod[0];\r\n        } else {\r\n            res.name = name;\r\n        }\r\n        return res;\r\n    }\r\n    throw new TypeError(`Invalid column syntax: ${npm.utils.toJson(name)}.`);\r\n}\r\n\r\nfunction isValidMod(mod) {\r\n    return npm.patterns.validModifiers.indexOf(mod) !== -1;\r\n}\r\n\r\nfunction isValidVariable(name) {\r\n    const m = name.match(npm.patterns.validVariable);\r\n    return !!m && m[0] === name;\r\n}\r\n\r\n/**\r\n * @method helpers.Column#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nColumn.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    const gap0 = npm.utils.messageGap(level),\r\n        gap1 = npm.utils.messageGap(level + 1),\r\n        lines = [\r\n            gap0 + `Column {`,\r\n            gap1 + `name: ` + npm.utils.toJson(this.name)\r\n        ];\r\n    if (`prop` in this) {\r\n        lines.push(gap1 + `prop: ` + npm.utils.toJson(this.prop));\r\n    }\r\n    if (`mod` in this) {\r\n        lines.push(gap1 + `mod: ` + npm.utils.toJson(this.mod));\r\n    }\r\n    if (`cast` in this) {\r\n        lines.push(gap1 + `cast: ` + npm.utils.toJson(this.cast));\r\n    }\r\n    if (`cnd` in this) {\r\n        lines.push(gap1 + `cnd: ` + npm.utils.toJson(this.cnd));\r\n    }\r\n    if (`def` in this) {\r\n        lines.push(gap1 + `def: ` + npm.utils.toJson(this.def));\r\n    }\r\n    if (`init` in this) {\r\n        lines.push(gap1 + `init: [Function]`);\r\n    }\r\n    if (`skip` in this) {\r\n        lines.push(gap1 + `skip: [Function]`);\r\n    }\r\n    lines.push(gap0 + `}`);\r\n    return lines.join(npm.os.EOL);\r\n};\r\n\r\nnpm.utils.addInspection(Column, function () {\r\n    return this.toString();\r\n});\r\n\r\n/**\r\n * @typedef helpers.ColumnConfig\r\n * @description\r\n * A simple structure with column details, to be passed into the {@link helpers.Column Column} constructor for initialization.\r\n *\r\n * @property {string} name\r\n * Destination column name + source property name (if `prop` is skipped). The name must adhere to JavaScript syntax for variables,\r\n * unless `prop` is specified, in which case `name` represents only the column name, and therefore can be any non-empty string.\r\n *\r\n * @property {string} [prop]\r\n * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.\r\n *\r\n * It is ignored when it is the same as `name`.\r\n *\r\n * @property {string} [mod]\r\n * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`.\r\n *\r\n * @property {string} [cast]\r\n * Server-side type casting. Leading `::` is allowed, but not needed (automatically removed when specified).\r\n *\r\n * @property {boolean} [cnd]\r\n * Conditional column flag.\r\n *\r\n * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and\r\n * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.\r\n *\r\n * It can be set from a string initialization, by adding `?` in front of the name.\r\n *\r\n * @property {*} [def]\r\n * Default value for the property, to be used only when the source object doesn't have the property.\r\n * It is ignored when property `init` is set.\r\n *\r\n * @property {helpers.initCB} [init]\r\n * Override callback for the value.\r\n *\r\n * @property {helpers.skipCB} [skip]\r\n * An override for skipping columns dynamically.\r\n *\r\n * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods\r\n * {@link helpers.insert insert} and {@link helpers.values values}.\r\n *\r\n * It is also ignored when conditional flag `cnd` is set.\r\n *\r\n */\r\n\r\n/**\r\n * @callback helpers.initCB\r\n * @description\r\n * A callback function type used by parameter `init` within {@link helpers.ColumnConfig ColumnConfig}.\r\n *\r\n * It works as an override for the corresponding property value in the `source` object.\r\n *\r\n * The function is called with `this` set to the `source` object.\r\n *\r\n * @param {*} col\r\n * Column-to-property descriptor.\r\n *\r\n * @param {object} col.source\r\n * The source object, equals to `this` that's passed into the function.\r\n *\r\n * @param {string} col.name\r\n * Resolved name of the property within the `source` object, i.e. the value of `name` when `prop` is not used\r\n * for the column, or the value of `prop` when it is specified.\r\n *\r\n * @param {*} col.value\r\n *\r\n * Property value, set to one of the following:\r\n *\r\n * - Value of the property within the `source` object (`value` = `source[name]`), if the property exists\r\n * - If the property doesn't exist and `def` is set in the column, then `value` is set to the value of `def`\r\n * - If the property doesn't exist and `def` is not set in the column, then `value` is set to `undefined`\r\n *\r\n * @param {boolean} col.exists\r\n * Indicates whether the property exists in the `source` object (`exists = name in source`).\r\n *\r\n * @returns {*}\r\n * The new value to be used for the corresponding column.\r\n */\r\n\r\n/**\r\n * @callback helpers.skipCB\r\n * @description\r\n * A callback function type used by parameter `skip` within {@link helpers.ColumnConfig ColumnConfig}.\r\n *\r\n * It is to dynamically determine when the property with specified `name` in the `source` object is to be skipped.\r\n *\r\n * The function is called with `this` set to the `source` object.\r\n *\r\n * @param {*} col\r\n * Column-to-property descriptor.\r\n *\r\n * @param {object} col.source\r\n * The source object, equals to `this` that's passed into the function.\r\n *\r\n * @param {string} col.name\r\n * Resolved name of the property within the `source` object, i.e. the value of `name` when `prop` is not used\r\n * for the column, or the value of `prop` when it is specified.\r\n *\r\n * @param {*} col.value\r\n *\r\n * Property value, set to one of the following:\r\n *\r\n * - Value of the property within the `source` object (`value` = `source[name]`), if the property exists\r\n * - If the property doesn't exist and `def` is set in the column, then `value` is set to the value of `def`\r\n * - If the property doesn't exist and `def` is not set in the column, then `value` is set to `undefined`\r\n *\r\n * @param {boolean} col.exists\r\n * Indicates whether the property exists in the `source` object (`exists = name in source`).\r\n *\r\n * @returns {boolean}\r\n * A truthy value that indicates whether the column is to be skipped.\r\n *\r\n */\r\n\r\nmodule.exports = {Column};\r\n"]},"metadata":{},"sourceType":"script"}