{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\nconst {\n  Events\n} = require(`./events`);\n\nconst {\n  assertOptions\n} = require(`assert-options`);\n\nconst {\n  resultQuery,\n  multiResultQuery,\n  streamQuery\n} = require(`./special-query`);\n\nconst {\n  ConnectionContext\n} = require(`./context`);\n\nconst {\n  DatabasePool\n} = require(`./database-pool`);\n\nconst {\n  queryResult\n} = require(`./query-result`);\n\nconst npm = {\n  utils: require(`./utils`),\n  pubUtils: require(`./utils/public`),\n  connect: require(`./connect`),\n  query: require(`./query`),\n  task: require(`./task`),\n  text: require(`./text`)\n};\n/**\r\n * @class Database\r\n * @description\r\n *\r\n * Represents the database protocol, extensible via event {@link event:extend extend}.\r\n * This type is not available directly, it can only be created via the library's base call.\r\n *\r\n * **IMPORTANT:**\r\n *\r\n * For any given connection, you should only create a single {@link Database} object in a separate module,\r\n * to be shared in your application (see the code example below). If instead you keep creating the {@link Database}\r\n * object dynamically, your application will suffer from loss in performance, and will be getting a warning in a\r\n * development environment (when `NODE_ENV` = `development`):\r\n *\r\n * `WARNING: Creating a duplicate database object for the same connection.`\r\n *\r\n * If you ever see this warning, rectify your {@link Database} object initialization, so there is only one object\r\n * per connection details. See the example provided below.\r\n *\r\n * See also: property `noWarnings` in {@link module:pg-promise Initialization Options}.\r\n *\r\n * Note however, that in special cases you may need to re-create the database object, if its connection pool has been\r\n * shut-down externally. And in this case the library won't be showing any warning.\r\n *\r\n * @param {string|object} cn\r\n * Database connection details, which can be:\r\n *\r\n * - a configuration object\r\n * - a connection string\r\n *\r\n * For details see {@link https://github.com/vitaly-t/pg-promise/wiki/Connection-Syntax Connection Syntax}.\r\n *\r\n * The value can be accessed from the database object via property {@link Database.$cn $cn}.\r\n *\r\n * @param {*} [dc]\r\n * Database Context.\r\n *\r\n * Any object or value to be propagated through the protocol, to allow implementations and event handling\r\n * that depend on the database context.\r\n *\r\n * This is mainly to facilitate the use of multiple databases which may need separate protocol extensions,\r\n * or different implementations within a single task / transaction callback, depending on the database context.\r\n *\r\n * This parameter also adds uniqueness to the connection context that's used in combination with the connection\r\n * parameters, i.e. use of unique database context will prevent getting the warning about creating a duplicate\r\n * Database object.\r\n *\r\n * The value can be accessed from the database object via property {@link Database#$dc $dc}.\r\n *\r\n * @returns {Database}\r\n *\r\n * @see\r\n *\r\n * {@link Database#query query},\r\n * {@link Database#none none},\r\n * {@link Database#one one},\r\n * {@link Database#oneOrNone oneOrNone},\r\n * {@link Database#many many},\r\n * {@link Database#manyOrNone manyOrNone},\r\n * {@link Database#any any},\r\n * {@link Database#func func},\r\n * {@link Database#proc proc},\r\n * {@link Database#result result},\r\n * {@link Database#multiResult multiResult},\r\n * {@link Database#multi multi},\r\n * {@link Database#map map},\r\n * {@link Database#each each},\r\n * {@link Database#stream stream},\r\n * {@link Database#task task},\r\n * {@link Database#taskIf taskIf},\r\n * {@link Database#tx tx},\r\n * {@link Database#txIf txIf},\r\n * {@link Database#connect connect},\r\n * {@link Database#$config $config},\r\n * {@link Database#$cn $cn},\r\n * {@link Database#$dc $dc},\r\n * {@link Database#$pool $pool},\r\n * {@link event:extend extend}\r\n *\r\n * @example\r\n * // Proper way to initialize and share the Database object\r\n *\r\n * // Loading and initializing the library:\r\n * const pgp = require('pg-promise')({\r\n *     // Initialization Options\r\n * });\r\n *\r\n * // Preparing the connection details:\r\n * const cn = 'postgres://username:password@host:port/database';\r\n *\r\n * // Creating a new database instance from the connection details:\r\n * const db = pgp(cn);\r\n *\r\n * // Exporting the database object for shared use:\r\n * module.exports = db;\r\n */\n\nfunction Database(cn, dc, config) {\n  const dbThis = this,\n        $p = config.promise,\n        poolConnection = typeof cn === `string` ? {\n    connectionString: cn\n  } : cn,\n        pool = new config.pgp.pg.Pool(poolConnection),\n        endMethod = pool.end;\n  let destroyed;\n\n  pool.end = cb => {\n    const res = endMethod.call(pool, cb);\n    dbThis.$destroy();\n    return res;\n  };\n\n  pool.on(`error`, onError);\n  /**\r\n   * @method Database#connect\r\n   *\r\n   * @description\r\n   * Acquires a new or existing connection, depending on the current state of the connection pool, and parameter `direct`.\r\n   *\r\n   * This method creates a shared connection for executing a chain of queries against it. The connection must be released\r\n   * in the end of the chain by calling `done()` on the connection object.\r\n   *\r\n   * Method `done` takes one optional parameter - boolean `kill` flag, to signal the connection pool that you want it to kill\r\n   * the physical connection. This flag is ignored for direct connections, as they always auto-close when released.\r\n   *\r\n   * It should not be used just for chaining queries on the same connection, methods {@link Database#task task} and\r\n   * {@link Database#tx tx} (for transactions) are to be used for that. This method is primarily for special cases, like\r\n   * `LISTEN` notifications.\r\n   *\r\n   * **NOTE:** Even though this method exposes a {@link external:Client Client} object via property `client`,\r\n   * you cannot call `client.end()` directly, or it will print an error into the console:\r\n   * `Abnormal client.end() call, due to invalid code or failed server connection.`\r\n   * You should only call method `done()` to release the connection.\r\n   *\r\n   * @param {object} [options]\r\n   * Connection Options.\r\n   *\r\n   * @param {boolean} [options.direct=false]\r\n   * Creates a new connection directly, as a stand-alone {@link external:Client Client} object, bypassing the connection pool.\r\n   *\r\n   * By default, all connections are acquired from the connection pool. But if you set this option, the library will instead\r\n   * create a new {@link external:Client Client} object directly (separately from the pool), and then call its `connect` method.\r\n   *\r\n   * **WARNING:**\r\n   *\r\n   * Do not use this option for regular query execution, because it exclusively occupies one physical channel, and it cannot scale.\r\n   * This option is only suitable for global connection usage, such as event listeners.\r\n   *\r\n   * @param {function} [options.onLost]\r\n   * Notification callback of the lost/broken connection, called with the following parameters:\r\n   *  - `err` - the original connectivity error\r\n   *  - `e` - error context object, which contains:\r\n   *    - `cn` - safe connection string/config (with the password hashed);\r\n   *    - `dc` - Database Context, as was used during {@link Database} construction;\r\n   *    - `start` - Date/Time (`Date` type) when the connection was established;\r\n   *    - `client` - {@link external:Client Client} object that has lost the connection.\r\n   *\r\n   * The notification is mostly valuable with `direct: true`, to be able to re-connect direct/permanent connections by calling\r\n   * method {@link Database#connect connect} again.\r\n   *\r\n   * You do not need to call `done` on lost connections, as it happens automatically. However, if you had event listeners\r\n   * set up on the connection's `client` object, you should remove them to avoid leaks:\r\n   *\r\n   * ```js\r\n   * function onLostConnection(err, e) {\r\n   *     e.client.removeListener('my-event', myHandler);\r\n   * }\r\n   * ```\r\n   *\r\n   * For a complete example see $[Robust Listeners].\r\n   *\r\n   * @returns {external:Promise}\r\n   * A promise object that represents the connection result:\r\n   *  - resolves with the complete {@link Database} protocol, extended with:\r\n   *    - property `client` of type {@link external:Client Client} that represents the open connection\r\n   *    - method `done` that must be called in the end, in order to release the connection\r\n   *    - methods `batch`, `page` and `sequence`, same as inside a {@link Task}\r\n   *  - rejects with a connection-related error when it fails to connect.\r\n   *\r\n   * @see\r\n   * {@link Database#task Database.task},\r\n   * {@link Database#taskIf Database.taskIf},\r\n   * {@link Database#tx Database.tx},\r\n   * {@link Database#txIf Database.txIf}\r\n   *\r\n   * @example\r\n   *\r\n   * let sco; // shared connection object;\r\n   *\r\n   * db.connect()\r\n   *     .then(obj => {\r\n   *         // obj.client = new connected Client object;\r\n   *\r\n   *         sco = obj; // save the connection object;\r\n   *\r\n   *         // execute all the queries you need:\r\n   *         return sco.any('SELECT * FROM Users');\r\n   *     })\r\n   *     .then(data => {\r\n   *         // success\r\n   *     })\r\n   *     .catch(error => {\r\n   *         // error\r\n   *     })\r\n   *     .finally(() => {\r\n   *         // release the connection, if it was successful:\r\n   *         if (sco) {\r\n   *             // if you pass `true` into method done, i.e. done(true),\r\n   *             // it will make the pool kill the physical connection.\r\n   *             sco.done();\r\n   *         }\r\n   *     });\r\n   *\r\n   */\n\n  this.connect = function (options) {\n    options = options || {};\n    const ctx = createContext();\n    ctx.cnOptions = options;\n    const self = {\n      query(query, values, qrm) {\n        if (!ctx.db) {\n          return $p.reject(new Error(npm.text.queryDisconnected));\n        }\n\n        return config.$npm.query.call(this, ctx, query, values, qrm);\n      },\n\n      done(kill) {\n        if (!ctx.db) {\n          throw new Error(npm.text.looseQuery);\n        }\n\n        ctx.disconnect(kill);\n      },\n\n      batch(values, opt) {\n        return config.$npm.spex.batch.call(this, values, opt);\n      },\n\n      page(source, opt) {\n        return config.$npm.spex.page.call(this, source, opt);\n      },\n\n      sequence(source, opt) {\n        return config.$npm.spex.sequence.call(this, source, opt);\n      }\n\n    };\n    const connection = options.direct ? config.$npm.connect.direct(ctx) : config.$npm.connect.pool(ctx, dbThis);\n    return connection.then(db => {\n      ctx.connect(db);\n      self.client = db.client;\n      extend(ctx, self);\n      return self;\n    });\n  };\n  /**\r\n   * @method Database#query\r\n   *\r\n   * @description\r\n   * Base query method that executes a generic query, expecting the return data according to parameter `qrm`.\r\n   *\r\n   * It performs the following steps:\r\n   *\r\n   *  1. Validates and formats the query via {@link formatting.format as.format}, according to the `query` and `values` passed in;\r\n   *  2. For a root-level query (against the {@link Database} object), it requests a new connection from the pool;\r\n   *  3. Executes the query;\r\n   *  4. For a root-level query (against the {@link Database} object), it releases the connection back to the pool;\r\n   *  5. Resolves/rejects, according to the data returned from the query and the value of `qrm`.\r\n   *\r\n   * Direct use of this method is not suitable for chaining queries, for performance reasons. It should be done\r\n   * through either task or transaction context, see $[Chaining Queries].\r\n   *\r\n   * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n   *\r\n   * @param {string|function|object} query\r\n   * Query to be executed, which can be any of the following types:\r\n   * - A non-empty query string\r\n   * - A function that returns a query string or another function, i.e. recursive resolution\r\n   *   is supported, passing in `values` as `this`, and as the first parameter.\r\n   * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n   * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n   * - {@link QueryFile} object\r\n   *\r\n   * @param {array|value|function} [values]\r\n   * Query formatting parameter(s), or a function that returns it.\r\n   *\r\n   * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n   * - a single value - to replace all `$1` occurrences\r\n   * - an array of values - to replace all `$1`, `$2`, ... variables\r\n   * - an object - to apply $[Named Parameters] formatting\r\n   *\r\n   * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n   * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n   * as an override for its internal `values`.\r\n   *\r\n   * @param {queryResult} [qrm=queryResult.any]\r\n   * {@link queryResult Query Result Mask}\r\n   *\r\n   * @returns {external:Promise}\r\n   * A promise object that represents the query result according to `qrm`.\r\n   */\n\n\n  this.query = function (query, values, qrm) {\n    const self = this,\n          ctx = createContext();\n    return config.$npm.connect.pool(ctx, dbThis).then(db => {\n      ctx.connect(db);\n      return config.$npm.query.call(self, ctx, query, values, qrm);\n    }).then(data => {\n      ctx.disconnect();\n      return data;\n    }).catch(error => {\n      ctx.disconnect();\n      return $p.reject(error);\n    });\n  };\n  /**\r\n   * @member {object} Database#$config\r\n   * @readonly\r\n   * @description\r\n   * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n   *\r\n   * Properties available in the object:\r\n   * - `pgp` - instance of the entire library after initialization\r\n   * - `options` - the library's {@link module:pg-promise Initialization Options} object\r\n   * - `promiseLib` - instance of the promise library that's used\r\n   * - `promise` - generic promise interface that uses `promiseLib` via 4 basic methods:\r\n   *   - `promise((resolve, reject) => {})` - to create a new promise\r\n   *   - `promise.resolve(value)` - to resolve with a value\r\n   *   - `promise.reject(reason)` - to reject with a reason\r\n   *   - `promise.all(iterable)` - to resolve an iterable list of promises\r\n   * - `version` - this library's version\r\n   * - `$npm` _(hidden property)_ - internal module cache\r\n   *\r\n   * @example\r\n   *\r\n   * // Using the promise protocol as configured by pg-promise:\r\n   *\r\n   * const $p = db.$config.promise;\r\n   *\r\n   * const resolvedPromise = $p.resolve('some data');\r\n   * const rejectedPromise = $p.reject('some reason');\r\n   *\r\n   * const newPromise = $p((resolve, reject) => {\r\n   *     // call either resolve(data) or reject(reason) here\r\n   * });\r\n   */\n\n\n  npm.utils.addReadProp(this, `$config`, config, true);\n  /**\r\n   * @member {string|object} Database#$cn\r\n   * @readonly\r\n   * @description\r\n   * Database connection, as was passed in during the object's construction.\r\n   *\r\n   * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n   *\r\n   * @see Database\r\n   */\n\n  npm.utils.addReadProp(this, `$cn`, cn, true);\n  /**\r\n   * @member {*} Database#$dc\r\n   * @readonly\r\n   * @description\r\n   * Database Context, as was passed in during the object's construction.\r\n   *\r\n   * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n   *\r\n   * @see Database\r\n   */\n\n  npm.utils.addReadProp(this, `$dc`, dc, true);\n  /**\r\n   * @member {external:pg-pool} Database#$pool\r\n   * @readonly\r\n   * @description\r\n   * A $[pg-pool] object associated with the database object, as each {@link Database} creates its own $[pg-pool] instance.\r\n   *\r\n   * This is a hidden property, primarily for integrating type {@link Database} with third-party libraries that support\r\n   * $[pg-pool] directly. Note however, that if you pass the pool object into a library that calls `pool.end()`, you will no longer be able\r\n   * to use this {@link Database} object, and each query method will be rejecting with {@link external:Error Error} =\r\n   * `Connection pool of the database object has been destroyed.`\r\n   *\r\n   * You can also use this object to shut down the pool, by calling `$pool.end()`.\r\n   *\r\n   * For more details see $[Library de-initialization].\r\n   *\r\n   * @see\r\n   * {@link Database}\r\n   * {@link module:pg-promise~end pgp.end}\r\n   *\r\n   * @example\r\n   *\r\n   * // Shutting down the connection pool of this database object,\r\n   * // after all queries have finished in a run-though process:\r\n   *\r\n   * .then(() => {}) // processing the data\r\n   * .catch() => {}) // handling the error\r\n   * .finally(db.$pool.end); // shutting down the pool\r\n   *\r\n   */\n\n  npm.utils.addReadProp(this, `$pool`, pool, true);\n  /**\r\n   * @member {function} Database.$destroy\r\n   * @readonly\r\n   * @private\r\n   * @description\r\n   * Permanently shuts down the database object.\r\n   */\n\n  npm.utils.addReadProp(this, `$destroy`, () => {\n    if (!destroyed) {\n      if (!pool.ending) {\n        endMethod.call(pool);\n      }\n\n      DatabasePool.unregister(dbThis);\n      pool.removeListener(`error`, onError);\n      destroyed = true;\n    }\n  }, true);\n  DatabasePool.register(this);\n  extend(createContext(), this); // extending root protocol;\n\n  function createContext() {\n    return new ConnectionContext({\n      cn,\n      dc,\n      options: config.options\n    });\n  } // Optional value-transformation helper:\n\n\n  function transform(value, cb, thisArg) {\n    return typeof cb === `function` ? value.then(data => cb.call(thisArg, data)) : value;\n  } ////////////////////////////////////////////////////\n  // Injects additional methods into an access object,\n  // extending the protocol's base method 'query'.\n\n\n  function extend(ctx, obj) {\n    /**\r\n     * @method Database#none\r\n     * @description\r\n     * Executes a query that expects no data to be returned. If the query returns any data,\r\n     * the method rejects.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise<null>}\r\n     * A promise object that represents the query result:\r\n     * - When no records are returned, it resolves with `null`.\r\n     * - When any data is returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n     *   - `.message` = `No return data was expected.`\r\n     *   - `.code` = {@link errors.queryResultErrorCode.notEmpty queryResultErrorCode.notEmpty}\r\n     */\n    obj.none = function (query, values) {\n      return obj.query.call(this, query, values, queryResult.none);\n    };\n    /**\r\n     * @method Database#one\r\n     * @description\r\n     * Executes a query that expects exactly 1 row to be returned. When 0 or more than 1 rows are returned,\r\n     * the method rejects.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {function} [cb]\r\n     * Value-transformation callback, to allow in-line value change.\r\n     * When specified, the returned value replaces the original one.\r\n     *\r\n     * The function takes only one parameter - value resolved from the query.\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the transformation callback.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result:\r\n     * - When 1 row is returned, it resolves with that row as a single object.\r\n     * - When no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n     *   - `.message` = `No data returned from the query.`\r\n     *   - `.code` = {@link errors.queryResultErrorCode.noData queryResultErrorCode.noData}\r\n     * - When multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n     *   - `.message` = `Multiple rows were not expected.`\r\n     *   - `.code` = {@link errors.queryResultErrorCode.multiple queryResultErrorCode.multiple}\r\n     * - Resolves with the new value, if transformation callback `cb` was specified.\r\n     *\r\n     * @see\r\n     * {@link Database#oneOrNone oneOrNone}\r\n     *\r\n     * @example\r\n     *\r\n     * // a query with in-line value transformation:\r\n     * db.one('INSERT INTO Events VALUES($1) RETURNING id', [123], event => event.id)\r\n     *     .then(data => {\r\n     *         // data = a new event id, rather than an object with it\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * // a query with in-line value transformation + conversion:\r\n     * db.one('SELECT count(*) FROM Users', [], c => +c.count)\r\n     *     .then(count => {\r\n     *         // count = a proper integer value, rather than an object with a string\r\n     *     });\r\n     *\r\n     */\n\n\n    obj.one = function (query, values, cb, thisArg) {\n      const v = obj.query.call(this, query, values, queryResult.one);\n      return transform(v, cb, thisArg);\n    };\n    /**\r\n     * @method Database#many\r\n     * @description\r\n     * Executes a query that expects one or more rows to be returned. When the query returns no rows, the method rejects.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result:\r\n     * - When 1 or more rows are returned, it resolves with the array of rows.\r\n     * - When no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n     *   - `.message` = `No data returned from the query.`\r\n     *   - `.code` = {@link errors.queryResultErrorCode.noData queryResultErrorCode.noData}\r\n     */\n\n\n    obj.many = function (query, values) {\n      return obj.query.call(this, query, values, queryResult.many);\n    };\n    /**\r\n     * @method Database#oneOrNone\r\n     * @description\r\n     * Executes a query that expects 0 or 1 rows to be returned. It resolves with the row-object when 1 row is returned,\r\n     * or with `null` when nothing is returned. When the query returns more than 1 row, the method rejects.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {function} [cb]\r\n     * Value-transformation callback, to allow in-line value change.\r\n     * When specified, the returned value replaces the original one.\r\n     *\r\n     * The function takes only one parameter - value resolved from the query.\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the transformation callback.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result:\r\n     * - When no rows are returned, it resolves with `null`.\r\n     * - When 1 row is returned, it resolves with that row as a single object.\r\n     * - When multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n     *   - `.message` = `Multiple rows were not expected.`\r\n     *   - `.code` = {@link errors.queryResultErrorCode.multiple queryResultErrorCode.multiple}\r\n     * - Resolves with the new value, if transformation callback `cb` was specified.\r\n     *\r\n     * @see\r\n     * {@link Database#one one},\r\n     * {@link Database#none none},\r\n     * {@link Database#manyOrNone manyOrNone}\r\n     *\r\n     * @example\r\n     *\r\n     * // a query with in-line value transformation:\r\n     * db.oneOrNone('SELECT id FROM Events WHERE type = $1', ['entry'], e => e && e.id)\r\n     *     .then(data => {\r\n     *         // data = the event id or null (rather than object or null)\r\n     *     });\r\n     *\r\n     */\n\n\n    obj.oneOrNone = function (query, values, cb, thisArg) {\n      const v = obj.query.call(this, query, values, queryResult.one | queryResult.none);\n      return transform(v, cb, thisArg);\n    };\n    /**\r\n     * @method Database#manyOrNone\r\n     * @description\r\n     * Executes a query that can return any number of rows.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise<Array>}\r\n     * A promise object that represents the query result:\r\n     * - When no rows are returned, it resolves with an empty array.\r\n     * - When 1 or more rows are returned, it resolves with the array of rows.\r\n     *\r\n     * @see\r\n     * {@link Database#any any},\r\n     * {@link Database#many many},\r\n     * {@link Database#none none}\r\n     *\r\n     */\n\n\n    obj.manyOrNone = function (query, values) {\n      return obj.query.call(this, query, values, queryResult.many | queryResult.none);\n    };\n    /**\r\n     * @method Database#any\r\n     * @description\r\n     * Executes a query that can return any number of rows.\r\n     * This is simply a shorter alias for method {@link Database#manyOrNone manyOrNone}.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise<Array>}\r\n     * A promise object that represents the query result:\r\n     * - When no rows are returned, it resolves with an empty array.\r\n     * - When 1 or more rows are returned, it resolves with the array of rows.\r\n     *\r\n     * @see\r\n     * {@link Database#manyOrNone manyOrNone},\r\n     * {@link Database#map map},\r\n     * {@link Database#each each}\r\n     *\r\n     */\n\n\n    obj.any = function (query, values) {\n      return obj.query.call(this, query, values, queryResult.any);\n    };\n    /**\r\n     * @method Database#result\r\n     * @description\r\n     * Executes a query without any expectation for the return data, and resolves with the\r\n     * original $[Result] object when successful.\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {function} [cb]\r\n     * Value-transformation callback, to allow in-line value change.\r\n     * When specified, the returned value replaces the original one.\r\n     *\r\n     * The function takes only one parameter - value resolved from the query.\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the transformation callback.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result:\r\n     * - resolves with the original $[Result] object (by default);\r\n     * - resolves with the new value, if transformation callback `cb` was specified.\r\n     *\r\n     * @example\r\n     *\r\n     * // use of value transformation:\r\n     * // deleting rows and returning the number of rows deleted\r\n     * db.result('DELETE FROM Events WHERE id = $1', [123], r => r.rowCount)\r\n     *     .then(data => {\r\n     *         // data = number of rows that were deleted\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * // use of value transformation:\r\n     * // getting only column details from a table\r\n     * db.result('SELECT * FROM Users LIMIT 0', null, r => r.fields)\r\n     *     .then(data => {\r\n     *         // data = array of column descriptors\r\n     *     });\r\n     *\r\n     */\n\n\n    obj.result = function (query, values, cb, thisArg) {\n      const v = obj.query.call(this, query, values, resultQuery);\n      return transform(v, cb, thisArg);\n    };\n    /**\r\n     * @method Database#multiResult\r\n     * @description\r\n     * Executes a multi-query string, without any expectation for the return data, and resolves with an array\r\n     * of the original $[Result] objects when successful.\r\n     *\r\n     * The operation is atomic, i.e. all queries are executed in a single transaction, unless there are explicit\r\n     * `BEGIN/COMMIT` commands included in the query string to divide it into multiple transactions.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Multi-query string to be executed, which can be any of the following types:\r\n     * - A non-empty string that can contain any number of queries\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise<external:Result[]>}\r\n     *\r\n     * @see {@link Database#multi multi}\r\n     *\r\n     */\n\n\n    obj.multiResult = function (query, values) {\n      return obj.query.call(this, query, values, multiResultQuery);\n    };\n    /**\r\n     * @method Database#multi\r\n     * @description\r\n     * Executes a multi-query string, without any expectation for the return data, and resolves with an array\r\n     * of arrays of rows when successful.\r\n     *\r\n     * The operation is atomic, i.e. all queries are executed in a single transaction, unless there are explicit\r\n     * `BEGIN/COMMIT` commands included in the query string to divide it into multiple transactions.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Multi-query string to be executed, which can be any of the following types:\r\n     * - A non-empty string that can contain any number of queries\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @returns {external:Promise<Array<Array>>}\r\n     *\r\n     * @see {@link Database#multiResult multiResult}\r\n     *\r\n     * @example\r\n     *\r\n     * db.multi('SELECT * FROM users;SELECT * FROM products')\r\n     *    .then(([users, products]) => {\r\n     *        // we get data from all queries at once\r\n     *    })\r\n     *    .catch(error => {\r\n     *        // error\r\n     *    });\r\n     */\n\n\n    obj.multi = function (query, values) {\n      return obj.query.call(this, query, values, multiResultQuery).then(data => data.map(a => a.rows));\n    };\n    /**\r\n     * @method Database#stream\r\n     * @description\r\n     * Custom data streaming, with the help of $[pg-query-stream].\r\n     *\r\n     * This method doesn't work with the $[Native Bindings], and if option `pgNative`\r\n     * is set, it will reject with `Streaming doesn't work with Native Bindings.`\r\n     *\r\n     * @param {QueryStream} qs\r\n     * Stream object of type $[QueryStream].\r\n     *\r\n     * @param {Database.streamInitCB} initCB\r\n     * Stream initialization callback.\r\n     *\r\n     * It is invoked with the same `this` context as the calling method.\r\n     *\r\n     * @returns {external:Promise}\r\n     * Result of the streaming operation.\r\n     *\r\n     * Once the streaming has finished successfully, the method resolves with\r\n     * `{processed, duration}`:\r\n     * - `processed` - total number of rows processed;\r\n     * - `duration` - streaming duration, in milliseconds.\r\n     *\r\n     * Possible rejections messages:\r\n     * - `Invalid or missing stream object.`\r\n     * - `Invalid stream state.`\r\n     * - `Invalid or missing stream initialization callback.`\r\n     */\n\n\n    obj.stream = function (qs, init) {\n      return obj.query.call(this, qs, init, streamQuery);\n    };\n    /**\r\n     * @method Database#func\r\n     * @description\r\n     * Executes a database function that returns a table, abbreviating the full syntax\r\n     * of `query('SELECT * FROM $1:alias($2:csv)', [funcName, values], qrm)`.\r\n     *\r\n     * @param {string} funcName\r\n     * Name of the function to be executed.\r\n     * When it is not same-case, or contains extended symbols, it is double-quoted,\r\n     * as per the `:alias` filter.\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Parameters for the function - one value | array of values | function returning value(s).\r\n     *\r\n     * @param {queryResult} [qrm=queryResult.any] - {@link queryResult Query Result Mask}.\r\n     *\r\n     * @returns {external:Promise}\r\n     *\r\n     * A promise object as returned from method {@link Database#query query}, according to parameter `qrm`.\r\n     *\r\n     * @see\r\n     * {@link Database#query query},\r\n     * {@link Database#proc proc}\r\n     */\n\n\n    obj.func = function (funcName, values, qrm) {\n      return obj.query.call(this, {\n        entity: funcName,\n        type: `func`\n      }, values, qrm);\n    };\n    /**\r\n     * @method Database#proc\r\n     * @description\r\n     * Executes a stored procedure by name, abbreviating the full syntax of\r\n     * `oneOrNone('CALL $1:alias($2:csv)', [procName, values], cb, thisArg)`.\r\n     *\r\n     * **NOTE:** This method uses the new `CALL` syntax that requires PostgreSQL v11 or later.\r\n     *\r\n     * @param {string} procName\r\n     * Name of the stored procedure to be executed.\r\n     * When it is not same-case, or contains extended symbols, it is double-quoted,\r\n     * as per the `:alias` filter.\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Parameters for the procedure - one value | array of values | function returning value(s).\r\n     *\r\n     * @param {function} [cb]\r\n     * Value-transformation callback, to allow in-line value change.\r\n     * When specified, the returned value replaces the original one.\r\n     *\r\n     * The function takes only one parameter - value resolved from the query.\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the transformation callback.\r\n     *\r\n     * @returns {external:Promise}\r\n     * When the procedure takes output parameters, a single object is returned, with\r\n     * properties for the output values. Otherwise, the method resolves with `null`.\r\n     * And if the value-transformation callback is provided, it overrides the result.\r\n     *\r\n     * @see\r\n     * {@link Database#func func}\r\n     */\n\n\n    obj.proc = function (procName, values, cb, thisArg) {\n      const v = obj.query.call(this, {\n        entity: procName,\n        type: `proc`\n      }, values, queryResult.one | queryResult.none);\n      return transform(v, cb, thisArg);\n    };\n    /**\r\n     * @method Database#map\r\n     * @description\r\n     * Creates a new array with the results of calling a provided function on every element in the array of rows\r\n     * resolved by method {@link Database#any any}.\r\n     *\r\n     * It is a convenience method to reduce the following code:\r\n     *\r\n     * ```js\r\n     * db.any(query, values)\r\n     *     .then(data => {\r\n     *         return data.map((row, index, data) => {\r\n     *              // return a new element\r\n     *         });\r\n     *     });\r\n     * ```\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} values\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {function} cb\r\n     * Function that produces an element of the new array, taking three arguments:\r\n     * - `row` - the current row object being processed in the array\r\n     * - `index` - the index of the current row being processed in the array\r\n     * - `data` - the original array of rows resolved by method {@link Database#any any}\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the callback.\r\n     *\r\n     * @returns {external:Promise<Array>}\r\n     * Resolves with the new array of values returned from the callback.\r\n     *\r\n     * @see\r\n     * {@link Database#any any},\r\n     * {@link Database#each each},\r\n     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map Array.map}\r\n     *\r\n     * @example\r\n     *\r\n     * db.map('SELECT id FROM Users WHERE status = $1', ['active'], row => row.id)\r\n     *     .then(data => {\r\n     *         // data = array of active user id-s\r\n     *     })\r\n     *     .catch(error => {\r\n     *        // error\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * db.tx(t => {\r\n     *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], row => {\r\n     *        return t.none('UPDATE Events SET checked = $1 WHERE userId = $2', [true, row.id]);\r\n     *     }).then(t.batch);\r\n     * })\r\n     *     .then(data => {\r\n     *         // success\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * // Build a list of active users, each with the list of user events:\r\n     * db.task(t => {\r\n     *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], user => {\r\n     *         return t.any('SELECT * FROM Events WHERE userId = $1', user.id)\r\n     *             .then(events=> {\r\n     *                 user.events = events;\r\n     *                 return user;\r\n     *             });\r\n     *     }).then(t.batch);\r\n     * })\r\n     *     .then(data => {\r\n     *         // success\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     */\n\n\n    obj.map = function (query, values, cb, thisArg) {\n      return obj.any.call(this, query, values).then(data => data.map(cb, thisArg));\n    };\n    /**\r\n     * @method Database#each\r\n     * @description\r\n     * Executes a provided function once per array element, for an array of rows resolved by method {@link Database#any any}.\r\n     *\r\n     * It is a convenience method to reduce the following code:\r\n     *\r\n     * ```js\r\n     * db.any(query, values)\r\n     *     .then(data => {\r\n     *         data.forEach((row, index, data) => {\r\n     *              // process the row\r\n     *         });\r\n     *         return data;\r\n     *     });\r\n     * ```\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {function} cb\r\n     * Function to execute for each row, taking three arguments:\r\n     * - `row` - the current row object being processed in the array\r\n     * - `index` - the index of the current row being processed in the array\r\n     * - `data` - the array of rows resolved by method {@link Database#any any}\r\n     *\r\n     * @param {*} [thisArg]\r\n     * Value to use as `this` when executing the callback.\r\n     *\r\n     * @returns {external:Promise<Array<Object>>}\r\n     * Resolves with the original array of rows.\r\n     *\r\n     * @see\r\n     * {@link Database#any any},\r\n     * {@link Database#map map},\r\n     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach Array.forEach}\r\n     *\r\n     * @example\r\n     *\r\n     * db.each('SELECT id, code, name FROM Events', [], row => {\r\n     *     row.code = parseInt(row.code);\r\n     * })\r\n     *     .then(data => {\r\n     *         // data = array of events, with 'code' converted into integer\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     */\n\n\n    obj.each = function (query, values, cb, thisArg) {\n      return obj.any.call(this, query, values).then(data => {\n        data.forEach(cb, thisArg);\n        return data;\n      });\n    };\n    /**\r\n     * @method Database#task\r\n     * @description\r\n     * Executes a callback function with automatically managed connection.\r\n     *\r\n     * When invoked on the root {@link Database} object, the method allocates the connection from the pool,\r\n     * executes the callback, and once finished - releases the connection back to the pool.\r\n     * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n     *\r\n     * This method should be used whenever executing more than one query at once, so the allocated connection\r\n     * is reused between all queries, and released only after the task has finished (see $[Chaining Queries]).\r\n     *\r\n     * The callback function is called with one parameter - database protocol (same as `this`), extended with methods\r\n     * {@link Task#batch batch}, {@link Task#page page}, {@link Task#sequence sequence}, plus property {@link Task#ctx ctx} -\r\n     * the task context object. See class {@link Task} for more details.\r\n     *\r\n     * @param {string|number|Object} [options]\r\n     * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n     *\r\n     * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n     * it is expected to be an object with options as listed below.\r\n     *\r\n     * @param {} [options.tag]\r\n     * Traceable context for the task (see $[tags]).\r\n     *\r\n     * @param {function} cb\r\n     * Task callback function, to return the result that will determine either success or failure for the operation.\r\n     *\r\n     * The function can be either the first of the second parameter passed into the method.\r\n     *\r\n     * It also can be an ES7 `async` function.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object with the result from the callback function.\r\n     *\r\n     * @see\r\n     * {@link Task},\r\n     * {@link Database#taskIf taskIf},\r\n     * {@link Database#tx tx},\r\n     * $[tags],\r\n     * $[Chaining Queries]\r\n     *\r\n     * @example\r\n     *\r\n     * db.task('my-task', t => {\r\n     *         // t.ctx = task context object\r\n     *\r\n     *         return t.one('SELECT id FROM Users WHERE name = $1', 'John')\r\n     *             .then(user => {\r\n     *                 return t.any('SELECT * FROM Events WHERE userId = $1', user.id);\r\n     *             });\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *         // data = as returned from the task's callback\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * // using an ES7 syntax for the callback:\r\n     * db.task('my-task', async t {\r\n     *         // t.ctx = task context object\r\n     *\r\n     *         const user = await t.one('SELECT id FROM Users WHERE name = $1', 'John');\r\n     *         return t.any('SELECT * FROM Events WHERE userId = $1', user.id);\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *         // data = as returned from the task's callback\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     */\n\n\n    obj.task = function () {\n      const args = npm.pubUtils.taskArgs(arguments);\n      assertOptions(args.options, [`tag`]);\n      return taskProcessor.call(this, args, false);\n    };\n    /**\r\n     * @method Database#taskIf\r\n     * @description\r\n     * Executes a conditional task that results in an actual new {@link Database#task task}, if either condition is met or\r\n     * when it is necessary (on the top level), or else it reuses the current connection context.\r\n     *\r\n     * The default condition is `not in task or transaction`, to start a task only if currently not inside another task or transaction,\r\n     * which is the same as calling the following:\r\n     *\r\n     * ```js\r\n     * db.taskIf({cnd: t => !t.ctx}, cb => {})\r\n     * ```\r\n     *\r\n     * It can be useful, if you want to simplify/reduce the task + log events footprint, by creating new tasks only when necessary.\r\n     *\r\n     * @param {string|number|Object} [options]\r\n     * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n     *\r\n     * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n     * it is expected to be an object with options as listed below.\r\n     *\r\n     * @param {} [options.tag]\r\n     * Traceable context for the task/transaction (see $[tags]).\r\n     *\r\n     * @param {boolean|function} [options.cnd]\r\n     * Condition for creating a ({@link Database#task task}), if it is met.\r\n     * It can be either a simple boolean, or a callback function that takes the task context as `this` and as the first parameter.\r\n     *\r\n     * Default condition (when it is not specified):\r\n     *\r\n     * ```js\r\n     * {cnd: t => !t.ctx}\r\n     * ```\r\n     *\r\n     * @param {function} cb\r\n     * Task callback function, to return the result that will determine either success or failure for the operation.\r\n     *\r\n     * The function can be either the first or the second parameter passed into the method.\r\n     *\r\n     * It also can be an ES7 `async` function.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object with the result from the callback function.\r\n     *\r\n     * @see\r\n     * {@link Task},\r\n     * {@link Database#task Database.task},\r\n     * {@link Database#tx Database.tx},\r\n     * {@link Database#txIf Database.txIf},\r\n     * {@link TaskContext}\r\n     *\r\n     */\n\n\n    obj.taskIf = function () {\n      const args = npm.pubUtils.taskArgs(arguments);\n      assertOptions(args.options, [`tag`, `cnd`]);\n\n      try {\n        let cnd = args.options.cnd;\n\n        if (`cnd` in args.options) {\n          cnd = typeof cnd === `function` ? cnd.call(obj, obj) : !!cnd;\n        } else {\n          cnd = !obj.ctx; // create task, if it is the top level\n        } // reusable only if condition fails, and not top-level:\n\n\n        args.options.reusable = !cnd && !!obj.ctx;\n      } catch (e) {\n        return $p.reject(e);\n      }\n\n      return taskProcessor.call(this, args, false);\n    };\n    /**\r\n     * @method Database#tx\r\n     * @description\r\n     * Executes a callback function as a transaction, with automatically managed connection.\r\n     *\r\n     * When invoked on the root {@link Database} object, the method allocates the connection from the pool,\r\n     * executes the callback, and once finished - releases the connection back to the pool.\r\n     * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n     *\r\n     * A transaction wraps a regular {@link Database#task task} into additional queries:\r\n     * - it executes `BEGIN` just before invoking the callback function\r\n     * - it executes `COMMIT`, if the callback didn't throw any error or return a rejected promise\r\n     * - it executes `ROLLBACK`, if the callback did throw an error or return a rejected promise\r\n     * - it executes corresponding `SAVEPOINT` commands when the method is called recursively.\r\n     *\r\n     * The callback function is called with one parameter - database protocol (same as `this`), extended with methods\r\n     * {@link Task#batch batch}, {@link Task#page page}, {@link Task#sequence sequence}, plus property {@link Task#ctx ctx} -\r\n     * the transaction context object. See class {@link Task} for more details.\r\n     *\r\n     * Note that transactions should be chosen over tasks only where necessary, because unlike regular tasks,\r\n     * transactions are blocking operations, and must be used with caution.\r\n     *\r\n     * @param {string|number|Object} [options]\r\n     * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n     *\r\n     * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n     * it is expected to be an object with options as listed below.\r\n     *\r\n     * @param {} [options.tag]\r\n     * Traceable context for the transaction (see $[tags]).\r\n     *\r\n     * @param {txMode.TransactionMode} [options.mode]\r\n     * Transaction Configuration Mode - extends the transaction-opening command with additional configuration.\r\n     *\r\n     * @param {function} cb\r\n     * Transaction callback function, to return the result that will determine either success or failure for the operation.\r\n     *\r\n     * The function can be either the first of the second parameter passed into the method.\r\n     *\r\n     * It also can be an ES7 `async` function.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object with the result from the callback function.\r\n     *\r\n     * @see\r\n     * {@link Task},\r\n     * {@link Database#task Database.task},\r\n     * {@link Database#taskIf Database.taskIf},\r\n     * {@link TaskContext},\r\n     * $[tags],\r\n     * $[Chaining Queries]\r\n     *\r\n     * @example\r\n     *\r\n     * db.tx('my-transaction', t => {\r\n     *         // t.ctx = transaction context object\r\n     *\r\n     *         return t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25])\r\n     *             .then(user => {\r\n     *                 return t.batch([\r\n     *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']),\r\n     *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'login'])\r\n     *                 ]);\r\n     *             });\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *         // data = as returned from the transaction's callback\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * // using an ES7 syntax for the callback:\r\n     * db.tx('my-transaction', async t {\r\n     *         // t.ctx = transaction context object\r\n     *\r\n     *         const user = await t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25]);\r\n     *         return t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']);\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *         // data = as returned from the transaction's callback\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     });\r\n     *\r\n     */\n\n\n    obj.tx = function () {\n      const args = npm.pubUtils.taskArgs(arguments);\n      assertOptions(args.options, [`tag`, `mode`]);\n      return taskProcessor.call(this, args, true);\n    };\n    /**\r\n     * @method Database#txIf\r\n     * @description\r\n     * Executes a conditional transaction that results in an actual transaction ({@link Database#tx tx}), if the condition is met,\r\n     * or else it executes a regular {@link Database#task task}.\r\n     *\r\n     * The default condition is `not in transaction`, to start a transaction only if currently not in transaction,\r\n     * or else start a task, which is the same as calling the following:\r\n     *\r\n     * ```js\r\n     * db.txIf({cnd: t => !t.ctx || !t.ctx.inTransaction}, cb => {})\r\n     * ```\r\n     *\r\n     * It is useful when you want to avoid $[Nested Transactions] - savepoints.\r\n     *\r\n     * @param {string|number|Object} [options]\r\n     * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n     *\r\n     * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n     * it is expected to be an object with options as listed below.\r\n     *\r\n     * @param {} [options.tag]\r\n     * Traceable context for the task/transaction (see $[tags]).\r\n     *\r\n     * @param {txMode.TransactionMode} [options.mode]\r\n     * Transaction Configuration Mode - extends the transaction-opening command with additional configuration.\r\n     *\r\n     * @param {boolean|function} [options.cnd]\r\n     * Condition for opening a transaction ({@link Database#tx tx}), if it is met, or a {@link Database#task task} when the condition is not met.\r\n     * It can be either a simple boolean, or a callback function that takes the task/tx context as `this` and as the first parameter.\r\n     *\r\n     * Default condition (when it is not specified):\r\n     *\r\n     * ```js\r\n     * {cnd: t => !t.ctx || !t.ctx.inTransaction}\r\n     * ```\r\n     *\r\n     * @param {boolean|function} [options.reusable=false]\r\n     * When `cnd` is/returns false, reuse context of the current task/transaction, if one exists.\r\n     * It can be either a simple boolean, or a callback function that takes the task/tx context as `this`\r\n     * and as the first parameter.\r\n     *\r\n     * By default, when `cnd` is/returns false, the method creates a new task. This option tells\r\n     * the method to reuse the current task/transaction context, and not create a new task.\r\n     *\r\n     * This option is ignored when executing against the top level of the protocol, because on\r\n     * that level, if no transaction is suddenly needed, a new task becomes necessary.\r\n     *\r\n     * @param {function} cb\r\n     * Transaction/task callback function, to return the result that will determine either\r\n     * success or failure for the operation.\r\n     *\r\n     * The function can be either the first or the second parameter passed into the method.\r\n     *\r\n     * It also can be an ES7 `async` function.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object with the result from the callback function.\r\n     *\r\n     * @see\r\n     * {@link Task},\r\n     * {@link Database#task Database.task},\r\n     * {@link Database#taskIf Database.taskIf},\r\n     * {@link Database#tx Database.tx},\r\n     * {@link TaskContext}\r\n     *\r\n     */\n\n\n    obj.txIf = function () {\n      const args = npm.pubUtils.taskArgs(arguments);\n      assertOptions(args.options, [`tag`, `mode`, `cnd`, `reusable`]);\n\n      try {\n        let cnd;\n\n        if (`cnd` in args.options) {\n          cnd = args.options.cnd;\n          cnd = typeof cnd === `function` ? cnd.call(obj, obj) : !!cnd;\n        } else {\n          cnd = !obj.ctx || !obj.ctx.inTransaction;\n        }\n\n        args.options.cnd = cnd;\n        const reusable = args.options.reusable;\n        args.options.reusable = !cnd && obj.ctx && typeof reusable === `function` ? reusable.call(obj, obj) : !!reusable;\n      } catch (e) {\n        return $p.reject(e);\n      }\n\n      return taskProcessor.call(this, args, args.options.cnd);\n    }; // Task method;\n    // Resolves with result from the callback function;\n\n\n    function taskProcessor(params, isTX) {\n      if (typeof params.cb !== `function`) {\n        return $p.reject(new TypeError(`Callback function is required.`));\n      }\n\n      if (params.options.reusable) {\n        return config.$npm.task.callback(obj.ctx, obj, params.cb, config);\n      }\n\n      const taskCtx = ctx.clone(); // task context object;\n\n      if (isTX) {\n        taskCtx.txLevel = taskCtx.txLevel >= 0 ? taskCtx.txLevel + 1 : 0;\n      }\n\n      taskCtx.inTransaction = taskCtx.txLevel >= 0;\n      taskCtx.level = taskCtx.level >= 0 ? taskCtx.level + 1 : 0;\n      taskCtx.cb = params.cb; // callback function;\n\n      taskCtx.mode = params.options.mode; // transaction mode;\n\n      if (this !== obj) {\n        taskCtx.context = this; // calling context object;\n      }\n\n      const tsk = new config.$npm.task.Task(taskCtx, params.options.tag, isTX, config);\n      taskCtx.taskCtx = tsk.ctx;\n      extend(taskCtx, tsk);\n\n      if (taskCtx.db) {\n        // reuse existing connection;\n        npm.utils.addReadProp(tsk.ctx, `useCount`, taskCtx.db.useCount);\n        addServerVersion(tsk.ctx, taskCtx.db.client);\n        return config.$npm.task.execute(taskCtx, tsk, isTX, config);\n      } // connection required;\n\n\n      return config.$npm.connect.pool(taskCtx, dbThis).then(db => {\n        taskCtx.connect(db);\n        npm.utils.addReadProp(tsk.ctx, `useCount`, db.useCount);\n        addServerVersion(tsk.ctx, db.client);\n        return config.$npm.task.execute(taskCtx, tsk, isTX, config);\n      }).then(data => {\n        taskCtx.disconnect();\n        return data;\n      }).catch(error => {\n        taskCtx.disconnect();\n        return $p.reject(error);\n      });\n    }\n\n    function addServerVersion(target, client) {\n      // Exclude else-case from coverage, because it can only occur with Native Bindings.\n      // istanbul ignore else\n      if (client.serverVersion) {\n        npm.utils.addReadProp(target, `serverVersion`, client.serverVersion);\n      }\n    } // lock all default properties to read-only,\n    // to prevent override by the client.\n\n\n    npm.utils.lock(obj, false, ctx.options); // extend the protocol;\n\n    Events.extend(ctx.options, obj, ctx.dc); // freeze the protocol permanently;\n\n    npm.utils.lock(obj, true, ctx.options);\n  }\n} // this event only happens when the connection is lost physically,\n// which cannot be tested automatically; removing from coverage:\n// istanbul ignore next\n\n\nfunction onError(err) {\n  // this client was never seen by pg-promise, which\n  // can happen if it failed to initialize\n  if (!err.client.$ctx) {\n    return;\n  }\n\n  const ctx = err.client.$ctx;\n  Events.error(ctx.options, err, {\n    cn: npm.utils.getSafeConnection(ctx.cn),\n    dc: ctx.dc\n  });\n}\n\nmodule.exports = config => {\n  const npmLocal = config.$npm;\n  npmLocal.connect = npmLocal.connect || npm.connect(config);\n  npmLocal.query = npmLocal.query || npm.query(config);\n  npmLocal.task = npmLocal.task || npm.task(config);\n  return Database;\n};\n/**\r\n * @callback Database.streamInitCB\r\n * @description\r\n * Stream initialization callback, used by {@link Database#stream Database.stream}.\r\n *\r\n * @param {external:Stream} stream\r\n * Stream object to initialize streaming.\r\n *\r\n * @example\r\n * const QueryStream = require('pg-query-stream');\r\n * const JSONStream = require('JSONStream');\r\n *\r\n * // you can also use pgp.as.format(query, values, options)\r\n * // to format queries properly, via pg-promise;\r\n * const qs = new QueryStream('SELECT * FROM users');\r\n *\r\n * db.stream(qs, stream => {\r\n *         // initiate streaming into the console:\r\n *         stream.pipe(JSONStream.stringify()).pipe(process.stdout);\r\n *     })\r\n *     .then(data => {\r\n *         console.log('Total rows processed:', data.processed,\r\n *           'Duration in milliseconds:', data.duration);\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n */\n\n/**\r\n * @external Stream\r\n * @see https://nodejs.org/api/stream.html\r\n */\n\n/**\r\n * @external pg-pool\r\n * @alias pg-pool\r\n * @see https://github.com/brianc/node-pg-pool\r\n */\n\n/**\r\n * @external Result\r\n * @see https://node-postgres.com/api/result\r\n */","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg-promise/lib/database.js"],"names":["Events","require","assertOptions","resultQuery","multiResultQuery","streamQuery","ConnectionContext","DatabasePool","queryResult","npm","utils","pubUtils","connect","query","task","text","Database","cn","dc","config","dbThis","$p","promise","poolConnection","connectionString","pool","pgp","pg","Pool","endMethod","end","destroyed","cb","res","call","$destroy","on","onError","options","ctx","createContext","cnOptions","self","values","qrm","db","reject","Error","queryDisconnected","$npm","done","kill","looseQuery","disconnect","batch","opt","spex","page","source","sequence","connection","direct","then","client","extend","data","catch","error","addReadProp","ending","unregister","removeListener","register","transform","value","thisArg","obj","none","one","v","many","oneOrNone","manyOrNone","any","result","multiResult","multi","map","a","rows","stream","qs","init","func","funcName","entity","type","proc","procName","each","forEach","args","taskArgs","arguments","taskProcessor","taskIf","cnd","reusable","e","tx","txIf","inTransaction","params","isTX","TypeError","callback","taskCtx","clone","txLevel","level","mode","context","tsk","Task","tag","useCount","addServerVersion","execute","target","serverVersion","lock","err","$ctx","getSafeConnection","module","exports","npmLocal"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {Events} = require(`./events`);\r\nconst {assertOptions} = require(`assert-options`);\r\nconst {resultQuery, multiResultQuery, streamQuery} = require(`./special-query`);\r\nconst {ConnectionContext} = require(`./context`);\r\nconst {DatabasePool} = require(`./database-pool`);\r\nconst {queryResult} = require(`./query-result`);\r\n\r\nconst npm = {\r\n    utils: require(`./utils`),\r\n    pubUtils: require(`./utils/public`),\r\n    connect: require(`./connect`),\r\n    query: require(`./query`),\r\n    task: require(`./task`),\r\n    text: require(`./text`)\r\n};\r\n\r\n/**\r\n * @class Database\r\n * @description\r\n *\r\n * Represents the database protocol, extensible via event {@link event:extend extend}.\r\n * This type is not available directly, it can only be created via the library's base call.\r\n *\r\n * **IMPORTANT:**\r\n *\r\n * For any given connection, you should only create a single {@link Database} object in a separate module,\r\n * to be shared in your application (see the code example below). If instead you keep creating the {@link Database}\r\n * object dynamically, your application will suffer from loss in performance, and will be getting a warning in a\r\n * development environment (when `NODE_ENV` = `development`):\r\n *\r\n * `WARNING: Creating a duplicate database object for the same connection.`\r\n *\r\n * If you ever see this warning, rectify your {@link Database} object initialization, so there is only one object\r\n * per connection details. See the example provided below.\r\n *\r\n * See also: property `noWarnings` in {@link module:pg-promise Initialization Options}.\r\n *\r\n * Note however, that in special cases you may need to re-create the database object, if its connection pool has been\r\n * shut-down externally. And in this case the library won't be showing any warning.\r\n *\r\n * @param {string|object} cn\r\n * Database connection details, which can be:\r\n *\r\n * - a configuration object\r\n * - a connection string\r\n *\r\n * For details see {@link https://github.com/vitaly-t/pg-promise/wiki/Connection-Syntax Connection Syntax}.\r\n *\r\n * The value can be accessed from the database object via property {@link Database.$cn $cn}.\r\n *\r\n * @param {*} [dc]\r\n * Database Context.\r\n *\r\n * Any object or value to be propagated through the protocol, to allow implementations and event handling\r\n * that depend on the database context.\r\n *\r\n * This is mainly to facilitate the use of multiple databases which may need separate protocol extensions,\r\n * or different implementations within a single task / transaction callback, depending on the database context.\r\n *\r\n * This parameter also adds uniqueness to the connection context that's used in combination with the connection\r\n * parameters, i.e. use of unique database context will prevent getting the warning about creating a duplicate\r\n * Database object.\r\n *\r\n * The value can be accessed from the database object via property {@link Database#$dc $dc}.\r\n *\r\n * @returns {Database}\r\n *\r\n * @see\r\n *\r\n * {@link Database#query query},\r\n * {@link Database#none none},\r\n * {@link Database#one one},\r\n * {@link Database#oneOrNone oneOrNone},\r\n * {@link Database#many many},\r\n * {@link Database#manyOrNone manyOrNone},\r\n * {@link Database#any any},\r\n * {@link Database#func func},\r\n * {@link Database#proc proc},\r\n * {@link Database#result result},\r\n * {@link Database#multiResult multiResult},\r\n * {@link Database#multi multi},\r\n * {@link Database#map map},\r\n * {@link Database#each each},\r\n * {@link Database#stream stream},\r\n * {@link Database#task task},\r\n * {@link Database#taskIf taskIf},\r\n * {@link Database#tx tx},\r\n * {@link Database#txIf txIf},\r\n * {@link Database#connect connect},\r\n * {@link Database#$config $config},\r\n * {@link Database#$cn $cn},\r\n * {@link Database#$dc $dc},\r\n * {@link Database#$pool $pool},\r\n * {@link event:extend extend}\r\n *\r\n * @example\r\n * // Proper way to initialize and share the Database object\r\n *\r\n * // Loading and initializing the library:\r\n * const pgp = require('pg-promise')({\r\n *     // Initialization Options\r\n * });\r\n *\r\n * // Preparing the connection details:\r\n * const cn = 'postgres://username:password@host:port/database';\r\n *\r\n * // Creating a new database instance from the connection details:\r\n * const db = pgp(cn);\r\n *\r\n * // Exporting the database object for shared use:\r\n * module.exports = db;\r\n */\r\nfunction Database(cn, dc, config) {\r\n\r\n    const dbThis = this,\r\n        $p = config.promise,\r\n        poolConnection = typeof cn === `string` ? {connectionString: cn} : cn,\r\n        pool = new config.pgp.pg.Pool(poolConnection),\r\n        endMethod = pool.end;\r\n\r\n    let destroyed;\r\n\r\n    pool.end = cb => {\r\n        const res = endMethod.call(pool, cb);\r\n        dbThis.$destroy();\r\n        return res;\r\n    };\r\n\r\n    pool.on(`error`, onError);\r\n\r\n    /**\r\n     * @method Database#connect\r\n     *\r\n     * @description\r\n     * Acquires a new or existing connection, depending on the current state of the connection pool, and parameter `direct`.\r\n     *\r\n     * This method creates a shared connection for executing a chain of queries against it. The connection must be released\r\n     * in the end of the chain by calling `done()` on the connection object.\r\n     *\r\n     * Method `done` takes one optional parameter - boolean `kill` flag, to signal the connection pool that you want it to kill\r\n     * the physical connection. This flag is ignored for direct connections, as they always auto-close when released.\r\n     *\r\n     * It should not be used just for chaining queries on the same connection, methods {@link Database#task task} and\r\n     * {@link Database#tx tx} (for transactions) are to be used for that. This method is primarily for special cases, like\r\n     * `LISTEN` notifications.\r\n     *\r\n     * **NOTE:** Even though this method exposes a {@link external:Client Client} object via property `client`,\r\n     * you cannot call `client.end()` directly, or it will print an error into the console:\r\n     * `Abnormal client.end() call, due to invalid code or failed server connection.`\r\n     * You should only call method `done()` to release the connection.\r\n     *\r\n     * @param {object} [options]\r\n     * Connection Options.\r\n     *\r\n     * @param {boolean} [options.direct=false]\r\n     * Creates a new connection directly, as a stand-alone {@link external:Client Client} object, bypassing the connection pool.\r\n     *\r\n     * By default, all connections are acquired from the connection pool. But if you set this option, the library will instead\r\n     * create a new {@link external:Client Client} object directly (separately from the pool), and then call its `connect` method.\r\n     *\r\n     * **WARNING:**\r\n     *\r\n     * Do not use this option for regular query execution, because it exclusively occupies one physical channel, and it cannot scale.\r\n     * This option is only suitable for global connection usage, such as event listeners.\r\n     *\r\n     * @param {function} [options.onLost]\r\n     * Notification callback of the lost/broken connection, called with the following parameters:\r\n     *  - `err` - the original connectivity error\r\n     *  - `e` - error context object, which contains:\r\n     *    - `cn` - safe connection string/config (with the password hashed);\r\n     *    - `dc` - Database Context, as was used during {@link Database} construction;\r\n     *    - `start` - Date/Time (`Date` type) when the connection was established;\r\n     *    - `client` - {@link external:Client Client} object that has lost the connection.\r\n     *\r\n     * The notification is mostly valuable with `direct: true`, to be able to re-connect direct/permanent connections by calling\r\n     * method {@link Database#connect connect} again.\r\n     *\r\n     * You do not need to call `done` on lost connections, as it happens automatically. However, if you had event listeners\r\n     * set up on the connection's `client` object, you should remove them to avoid leaks:\r\n     *\r\n     * ```js\r\n     * function onLostConnection(err, e) {\r\n     *     e.client.removeListener('my-event', myHandler);\r\n     * }\r\n     * ```\r\n     *\r\n     * For a complete example see $[Robust Listeners].\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the connection result:\r\n     *  - resolves with the complete {@link Database} protocol, extended with:\r\n     *    - property `client` of type {@link external:Client Client} that represents the open connection\r\n     *    - method `done` that must be called in the end, in order to release the connection\r\n     *    - methods `batch`, `page` and `sequence`, same as inside a {@link Task}\r\n     *  - rejects with a connection-related error when it fails to connect.\r\n     *\r\n     * @see\r\n     * {@link Database#task Database.task},\r\n     * {@link Database#taskIf Database.taskIf},\r\n     * {@link Database#tx Database.tx},\r\n     * {@link Database#txIf Database.txIf}\r\n     *\r\n     * @example\r\n     *\r\n     * let sco; // shared connection object;\r\n     *\r\n     * db.connect()\r\n     *     .then(obj => {\r\n     *         // obj.client = new connected Client object;\r\n     *\r\n     *         sco = obj; // save the connection object;\r\n     *\r\n     *         // execute all the queries you need:\r\n     *         return sco.any('SELECT * FROM Users');\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     })\r\n     *     .finally(() => {\r\n     *         // release the connection, if it was successful:\r\n     *         if (sco) {\r\n     *             // if you pass `true` into method done, i.e. done(true),\r\n     *             // it will make the pool kill the physical connection.\r\n     *             sco.done();\r\n     *         }\r\n     *     });\r\n     *\r\n     */\r\n    this.connect = function (options) {\r\n        options = options || {};\r\n        const ctx = createContext();\r\n        ctx.cnOptions = options;\r\n        const self = {\r\n            query(query, values, qrm) {\r\n                if (!ctx.db) {\r\n                    return $p.reject(new Error(npm.text.queryDisconnected));\r\n                }\r\n                return config.$npm.query.call(this, ctx, query, values, qrm);\r\n            },\r\n            done(kill) {\r\n                if (!ctx.db) {\r\n                    throw new Error(npm.text.looseQuery);\r\n                }\r\n                ctx.disconnect(kill);\r\n            },\r\n            batch(values, opt) {\r\n                return config.$npm.spex.batch.call(this, values, opt);\r\n            },\r\n            page(source, opt) {\r\n                return config.$npm.spex.page.call(this, source, opt);\r\n            },\r\n            sequence(source, opt) {\r\n                return config.$npm.spex.sequence.call(this, source, opt);\r\n            }\r\n        };\r\n        const connection = options.direct ? config.$npm.connect.direct(ctx) : config.$npm.connect.pool(ctx, dbThis);\r\n        return connection\r\n            .then(db => {\r\n                ctx.connect(db);\r\n                self.client = db.client;\r\n                extend(ctx, self);\r\n                return self;\r\n            });\r\n    };\r\n\r\n    /**\r\n     * @method Database#query\r\n     *\r\n     * @description\r\n     * Base query method that executes a generic query, expecting the return data according to parameter `qrm`.\r\n     *\r\n     * It performs the following steps:\r\n     *\r\n     *  1. Validates and formats the query via {@link formatting.format as.format}, according to the `query` and `values` passed in;\r\n     *  2. For a root-level query (against the {@link Database} object), it requests a new connection from the pool;\r\n     *  3. Executes the query;\r\n     *  4. For a root-level query (against the {@link Database} object), it releases the connection back to the pool;\r\n     *  5. Resolves/rejects, according to the data returned from the query and the value of `qrm`.\r\n     *\r\n     * Direct use of this method is not suitable for chaining queries, for performance reasons. It should be done\r\n     * through either task or transaction context, see $[Chaining Queries].\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {queryResult} [qrm=queryResult.any]\r\n     * {@link queryResult Query Result Mask}\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result according to `qrm`.\r\n     */\r\n    this.query = function (query, values, qrm) {\r\n        const self = this, ctx = createContext();\r\n        return config.$npm.connect.pool(ctx, dbThis)\r\n            .then(db => {\r\n                ctx.connect(db);\r\n                return config.$npm.query.call(self, ctx, query, values, qrm);\r\n            })\r\n            .then(data => {\r\n                ctx.disconnect();\r\n                return data;\r\n            })\r\n            .catch(error => {\r\n                ctx.disconnect();\r\n                return $p.reject(error);\r\n            });\r\n    };\r\n\r\n    /**\r\n     * @member {object} Database#$config\r\n     * @readonly\r\n     * @description\r\n     * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n     *\r\n     * Properties available in the object:\r\n     * - `pgp` - instance of the entire library after initialization\r\n     * - `options` - the library's {@link module:pg-promise Initialization Options} object\r\n     * - `promiseLib` - instance of the promise library that's used\r\n     * - `promise` - generic promise interface that uses `promiseLib` via 4 basic methods:\r\n     *   - `promise((resolve, reject) => {})` - to create a new promise\r\n     *   - `promise.resolve(value)` - to resolve with a value\r\n     *   - `promise.reject(reason)` - to reject with a reason\r\n     *   - `promise.all(iterable)` - to resolve an iterable list of promises\r\n     * - `version` - this library's version\r\n     * - `$npm` _(hidden property)_ - internal module cache\r\n     *\r\n     * @example\r\n     *\r\n     * // Using the promise protocol as configured by pg-promise:\r\n     *\r\n     * const $p = db.$config.promise;\r\n     *\r\n     * const resolvedPromise = $p.resolve('some data');\r\n     * const rejectedPromise = $p.reject('some reason');\r\n     *\r\n     * const newPromise = $p((resolve, reject) => {\r\n     *     // call either resolve(data) or reject(reason) here\r\n     * });\r\n     */\r\n    npm.utils.addReadProp(this, `$config`, config, true);\r\n\r\n    /**\r\n     * @member {string|object} Database#$cn\r\n     * @readonly\r\n     * @description\r\n     * Database connection, as was passed in during the object's construction.\r\n     *\r\n     * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n     *\r\n     * @see Database\r\n     */\r\n    npm.utils.addReadProp(this, `$cn`, cn, true);\r\n\r\n    /**\r\n     * @member {*} Database#$dc\r\n     * @readonly\r\n     * @description\r\n     * Database Context, as was passed in during the object's construction.\r\n     *\r\n     * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n     *\r\n     * @see Database\r\n     */\r\n    npm.utils.addReadProp(this, `$dc`, dc, true);\r\n\r\n    /**\r\n     * @member {external:pg-pool} Database#$pool\r\n     * @readonly\r\n     * @description\r\n     * A $[pg-pool] object associated with the database object, as each {@link Database} creates its own $[pg-pool] instance.\r\n     *\r\n     * This is a hidden property, primarily for integrating type {@link Database} with third-party libraries that support\r\n     * $[pg-pool] directly. Note however, that if you pass the pool object into a library that calls `pool.end()`, you will no longer be able\r\n     * to use this {@link Database} object, and each query method will be rejecting with {@link external:Error Error} =\r\n     * `Connection pool of the database object has been destroyed.`\r\n     *\r\n     * You can also use this object to shut down the pool, by calling `$pool.end()`.\r\n     *\r\n     * For more details see $[Library de-initialization].\r\n     *\r\n     * @see\r\n     * {@link Database}\r\n     * {@link module:pg-promise~end pgp.end}\r\n     *\r\n     * @example\r\n     *\r\n     * // Shutting down the connection pool of this database object,\r\n     * // after all queries have finished in a run-though process:\r\n     *\r\n     * .then(() => {}) // processing the data\r\n     * .catch() => {}) // handling the error\r\n     * .finally(db.$pool.end); // shutting down the pool\r\n     *\r\n     */\r\n    npm.utils.addReadProp(this, `$pool`, pool, true);\r\n\r\n    /**\r\n     * @member {function} Database.$destroy\r\n     * @readonly\r\n     * @private\r\n     * @description\r\n     * Permanently shuts down the database object.\r\n     */\r\n    npm.utils.addReadProp(this, `$destroy`, () => {\r\n        if (!destroyed) {\r\n            if (!pool.ending) {\r\n                endMethod.call(pool);\r\n            }\r\n            DatabasePool.unregister(dbThis);\r\n            pool.removeListener(`error`, onError);\r\n            destroyed = true;\r\n        }\r\n    }, true);\r\n\r\n    DatabasePool.register(this);\r\n\r\n    extend(createContext(), this); // extending root protocol;\r\n\r\n    function createContext() {\r\n        return new ConnectionContext({cn, dc, options: config.options});\r\n    }\r\n\r\n    // Optional value-transformation helper:\r\n    function transform(value, cb, thisArg) {\r\n        return typeof cb === `function` ? value.then(data => cb.call(thisArg, data)) : value;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////\r\n    // Injects additional methods into an access object,\r\n    // extending the protocol's base method 'query'.\r\n    function extend(ctx, obj) {\r\n\r\n        /**\r\n         * @method Database#none\r\n         * @description\r\n         * Executes a query that expects no data to be returned. If the query returns any data,\r\n         * the method rejects.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise<null>}\r\n         * A promise object that represents the query result:\r\n         * - When no records are returned, it resolves with `null`.\r\n         * - When any data is returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `No return data was expected.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.notEmpty queryResultErrorCode.notEmpty}\r\n         */\r\n        obj.none = function (query, values) {\r\n            return obj.query.call(this, query, values, queryResult.none);\r\n        };\r\n\r\n        /**\r\n         * @method Database#one\r\n         * @description\r\n         * Executes a query that expects exactly 1 row to be returned. When 0 or more than 1 rows are returned,\r\n         * the method rejects.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} [cb]\r\n         * Value-transformation callback, to allow in-line value change.\r\n         * When specified, the returned value replaces the original one.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - When 1 row is returned, it resolves with that row as a single object.\r\n         * - When no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `No data returned from the query.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.noData queryResultErrorCode.noData}\r\n         * - When multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `Multiple rows were not expected.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.multiple queryResultErrorCode.multiple}\r\n         * - Resolves with the new value, if transformation callback `cb` was specified.\r\n         *\r\n         * @see\r\n         * {@link Database#oneOrNone oneOrNone}\r\n         *\r\n         * @example\r\n         *\r\n         * // a query with in-line value transformation:\r\n         * db.one('INSERT INTO Events VALUES($1) RETURNING id', [123], event => event.id)\r\n         *     .then(data => {\r\n         *         // data = a new event id, rather than an object with it\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // a query with in-line value transformation + conversion:\r\n         * db.one('SELECT count(*) FROM Users', [], c => +c.count)\r\n         *     .then(count => {\r\n         *         // count = a proper integer value, rather than an object with a string\r\n         *     });\r\n         *\r\n         */\r\n        obj.one = function (query, values, cb, thisArg) {\r\n            const v = obj.query.call(this, query, values, queryResult.one);\r\n            return transform(v, cb, thisArg);\r\n        };\r\n\r\n        /**\r\n         * @method Database#many\r\n         * @description\r\n         * Executes a query that expects one or more rows to be returned. When the query returns no rows, the method rejects.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - When 1 or more rows are returned, it resolves with the array of rows.\r\n         * - When no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `No data returned from the query.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.noData queryResultErrorCode.noData}\r\n         */\r\n        obj.many = function (query, values) {\r\n            return obj.query.call(this, query, values, queryResult.many);\r\n        };\r\n\r\n        /**\r\n         * @method Database#oneOrNone\r\n         * @description\r\n         * Executes a query that expects 0 or 1 rows to be returned. It resolves with the row-object when 1 row is returned,\r\n         * or with `null` when nothing is returned. When the query returns more than 1 row, the method rejects.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} [cb]\r\n         * Value-transformation callback, to allow in-line value change.\r\n         * When specified, the returned value replaces the original one.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - When no rows are returned, it resolves with `null`.\r\n         * - When 1 row is returned, it resolves with that row as a single object.\r\n         * - When multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `Multiple rows were not expected.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.multiple queryResultErrorCode.multiple}\r\n         * - Resolves with the new value, if transformation callback `cb` was specified.\r\n         *\r\n         * @see\r\n         * {@link Database#one one},\r\n         * {@link Database#none none},\r\n         * {@link Database#manyOrNone manyOrNone}\r\n         *\r\n         * @example\r\n         *\r\n         * // a query with in-line value transformation:\r\n         * db.oneOrNone('SELECT id FROM Events WHERE type = $1', ['entry'], e => e && e.id)\r\n         *     .then(data => {\r\n         *         // data = the event id or null (rather than object or null)\r\n         *     });\r\n         *\r\n         */\r\n        obj.oneOrNone = function (query, values, cb, thisArg) {\r\n            const v = obj.query.call(this, query, values, queryResult.one | queryResult.none);\r\n            return transform(v, cb, thisArg);\r\n        };\r\n\r\n        /**\r\n         * @method Database#manyOrNone\r\n         * @description\r\n         * Executes a query that can return any number of rows.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise<Array>}\r\n         * A promise object that represents the query result:\r\n         * - When no rows are returned, it resolves with an empty array.\r\n         * - When 1 or more rows are returned, it resolves with the array of rows.\r\n         *\r\n         * @see\r\n         * {@link Database#any any},\r\n         * {@link Database#many many},\r\n         * {@link Database#none none}\r\n         *\r\n         */\r\n        obj.manyOrNone = function (query, values) {\r\n            return obj.query.call(this, query, values, queryResult.many | queryResult.none);\r\n        };\r\n\r\n        /**\r\n         * @method Database#any\r\n         * @description\r\n         * Executes a query that can return any number of rows.\r\n         * This is simply a shorter alias for method {@link Database#manyOrNone manyOrNone}.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise<Array>}\r\n         * A promise object that represents the query result:\r\n         * - When no rows are returned, it resolves with an empty array.\r\n         * - When 1 or more rows are returned, it resolves with the array of rows.\r\n         *\r\n         * @see\r\n         * {@link Database#manyOrNone manyOrNone},\r\n         * {@link Database#map map},\r\n         * {@link Database#each each}\r\n         *\r\n         */\r\n        obj.any = function (query, values) {\r\n            return obj.query.call(this, query, values, queryResult.any);\r\n        };\r\n\r\n        /**\r\n         * @method Database#result\r\n         * @description\r\n         * Executes a query without any expectation for the return data, and resolves with the\r\n         * original $[Result] object when successful.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} [cb]\r\n         * Value-transformation callback, to allow in-line value change.\r\n         * When specified, the returned value replaces the original one.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - resolves with the original $[Result] object (by default);\r\n         * - resolves with the new value, if transformation callback `cb` was specified.\r\n         *\r\n         * @example\r\n         *\r\n         * // use of value transformation:\r\n         * // deleting rows and returning the number of rows deleted\r\n         * db.result('DELETE FROM Events WHERE id = $1', [123], r => r.rowCount)\r\n         *     .then(data => {\r\n         *         // data = number of rows that were deleted\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // use of value transformation:\r\n         * // getting only column details from a table\r\n         * db.result('SELECT * FROM Users LIMIT 0', null, r => r.fields)\r\n         *     .then(data => {\r\n         *         // data = array of column descriptors\r\n         *     });\r\n         *\r\n         */\r\n        obj.result = function (query, values, cb, thisArg) {\r\n            const v = obj.query.call(this, query, values, resultQuery);\r\n            return transform(v, cb, thisArg);\r\n        };\r\n\r\n        /**\r\n         * @method Database#multiResult\r\n         * @description\r\n         * Executes a multi-query string, without any expectation for the return data, and resolves with an array\r\n         * of the original $[Result] objects when successful.\r\n         *\r\n         * The operation is atomic, i.e. all queries are executed in a single transaction, unless there are explicit\r\n         * `BEGIN/COMMIT` commands included in the query string to divide it into multiple transactions.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Multi-query string to be executed, which can be any of the following types:\r\n         * - A non-empty string that can contain any number of queries\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise<external:Result[]>}\r\n         *\r\n         * @see {@link Database#multi multi}\r\n         *\r\n         */\r\n        obj.multiResult = function (query, values) {\r\n            return obj.query.call(this, query, values, multiResultQuery);\r\n        };\r\n\r\n        /**\r\n         * @method Database#multi\r\n         * @description\r\n         * Executes a multi-query string, without any expectation for the return data, and resolves with an array\r\n         * of arrays of rows when successful.\r\n         *\r\n         * The operation is atomic, i.e. all queries are executed in a single transaction, unless there are explicit\r\n         * `BEGIN/COMMIT` commands included in the query string to divide it into multiple transactions.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Multi-query string to be executed, which can be any of the following types:\r\n         * - A non-empty string that can contain any number of queries\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise<Array<Array>>}\r\n         *\r\n         * @see {@link Database#multiResult multiResult}\r\n         *\r\n         * @example\r\n         *\r\n         * db.multi('SELECT * FROM users;SELECT * FROM products')\r\n         *    .then(([users, products]) => {\r\n         *        // we get data from all queries at once\r\n         *    })\r\n         *    .catch(error => {\r\n         *        // error\r\n         *    });\r\n         */\r\n        obj.multi = function (query, values) {\r\n            return obj.query.call(this, query, values, multiResultQuery)\r\n                .then(data => data.map(a => a.rows));\r\n        };\r\n\r\n        /**\r\n         * @method Database#stream\r\n         * @description\r\n         * Custom data streaming, with the help of $[pg-query-stream].\r\n         *\r\n         * This method doesn't work with the $[Native Bindings], and if option `pgNative`\r\n         * is set, it will reject with `Streaming doesn't work with Native Bindings.`\r\n         *\r\n         * @param {QueryStream} qs\r\n         * Stream object of type $[QueryStream].\r\n         *\r\n         * @param {Database.streamInitCB} initCB\r\n         * Stream initialization callback.\r\n         *\r\n         * It is invoked with the same `this` context as the calling method.\r\n         *\r\n         * @returns {external:Promise}\r\n         * Result of the streaming operation.\r\n         *\r\n         * Once the streaming has finished successfully, the method resolves with\r\n         * `{processed, duration}`:\r\n         * - `processed` - total number of rows processed;\r\n         * - `duration` - streaming duration, in milliseconds.\r\n         *\r\n         * Possible rejections messages:\r\n         * - `Invalid or missing stream object.`\r\n         * - `Invalid stream state.`\r\n         * - `Invalid or missing stream initialization callback.`\r\n         */\r\n        obj.stream = function (qs, init) {\r\n            return obj.query.call(this, qs, init, streamQuery);\r\n        };\r\n\r\n        /**\r\n         * @method Database#func\r\n         * @description\r\n         * Executes a database function that returns a table, abbreviating the full syntax\r\n         * of `query('SELECT * FROM $1:alias($2:csv)', [funcName, values], qrm)`.\r\n         *\r\n         * @param {string} funcName\r\n         * Name of the function to be executed.\r\n         * When it is not same-case, or contains extended symbols, it is double-quoted,\r\n         * as per the `:alias` filter.\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Parameters for the function - one value | array of values | function returning value(s).\r\n         *\r\n         * @param {queryResult} [qrm=queryResult.any] - {@link queryResult Query Result Mask}.\r\n         *\r\n         * @returns {external:Promise}\r\n         *\r\n         * A promise object as returned from method {@link Database#query query}, according to parameter `qrm`.\r\n         *\r\n         * @see\r\n         * {@link Database#query query},\r\n         * {@link Database#proc proc}\r\n         */\r\n        obj.func = function (funcName, values, qrm) {\r\n            return obj.query.call(this, {entity: funcName, type: `func`}, values, qrm);\r\n        };\r\n\r\n        /**\r\n         * @method Database#proc\r\n         * @description\r\n         * Executes a stored procedure by name, abbreviating the full syntax of\r\n         * `oneOrNone('CALL $1:alias($2:csv)', [procName, values], cb, thisArg)`.\r\n         *\r\n         * **NOTE:** This method uses the new `CALL` syntax that requires PostgreSQL v11 or later.\r\n         *\r\n         * @param {string} procName\r\n         * Name of the stored procedure to be executed.\r\n         * When it is not same-case, or contains extended symbols, it is double-quoted,\r\n         * as per the `:alias` filter.\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Parameters for the procedure - one value | array of values | function returning value(s).\r\n         *\r\n         * @param {function} [cb]\r\n         * Value-transformation callback, to allow in-line value change.\r\n         * When specified, the returned value replaces the original one.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * When the procedure takes output parameters, a single object is returned, with\r\n         * properties for the output values. Otherwise, the method resolves with `null`.\r\n         * And if the value-transformation callback is provided, it overrides the result.\r\n         *\r\n         * @see\r\n         * {@link Database#func func}\r\n         */\r\n        obj.proc = function (procName, values, cb, thisArg) {\r\n            const v = obj.query.call(this, {\r\n                entity: procName,\r\n                type: `proc`\r\n            }, values, queryResult.one | queryResult.none);\r\n            return transform(v, cb, thisArg);\r\n        };\r\n\r\n        /**\r\n         * @method Database#map\r\n         * @description\r\n         * Creates a new array with the results of calling a provided function on every element in the array of rows\r\n         * resolved by method {@link Database#any any}.\r\n         *\r\n         * It is a convenience method to reduce the following code:\r\n         *\r\n         * ```js\r\n         * db.any(query, values)\r\n         *     .then(data => {\r\n         *         return data.map((row, index, data) => {\r\n         *              // return a new element\r\n         *         });\r\n         *     });\r\n         * ```\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} values\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} cb\r\n         * Function that produces an element of the new array, taking three arguments:\r\n         * - `row` - the current row object being processed in the array\r\n         * - `index` - the index of the current row being processed in the array\r\n         * - `data` - the original array of rows resolved by method {@link Database#any any}\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the callback.\r\n         *\r\n         * @returns {external:Promise<Array>}\r\n         * Resolves with the new array of values returned from the callback.\r\n         *\r\n         * @see\r\n         * {@link Database#any any},\r\n         * {@link Database#each each},\r\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map Array.map}\r\n         *\r\n         * @example\r\n         *\r\n         * db.map('SELECT id FROM Users WHERE status = $1', ['active'], row => row.id)\r\n         *     .then(data => {\r\n         *         // data = array of active user id-s\r\n         *     })\r\n         *     .catch(error => {\r\n         *        // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * db.tx(t => {\r\n         *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], row => {\r\n         *        return t.none('UPDATE Events SET checked = $1 WHERE userId = $2', [true, row.id]);\r\n         *     }).then(t.batch);\r\n         * })\r\n         *     .then(data => {\r\n         *         // success\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // Build a list of active users, each with the list of user events:\r\n         * db.task(t => {\r\n         *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], user => {\r\n         *         return t.any('SELECT * FROM Events WHERE userId = $1', user.id)\r\n         *             .then(events=> {\r\n         *                 user.events = events;\r\n         *                 return user;\r\n         *             });\r\n         *     }).then(t.batch);\r\n         * })\r\n         *     .then(data => {\r\n         *         // success\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */\r\n        obj.map = function (query, values, cb, thisArg) {\r\n            return obj.any.call(this, query, values)\r\n                .then(data => data.map(cb, thisArg));\r\n        };\r\n\r\n        /**\r\n         * @method Database#each\r\n         * @description\r\n         * Executes a provided function once per array element, for an array of rows resolved by method {@link Database#any any}.\r\n         *\r\n         * It is a convenience method to reduce the following code:\r\n         *\r\n         * ```js\r\n         * db.any(query, values)\r\n         *     .then(data => {\r\n         *         data.forEach((row, index, data) => {\r\n         *              // process the row\r\n         *         });\r\n         *         return data;\r\n         *     });\r\n         * ```\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} cb\r\n         * Function to execute for each row, taking three arguments:\r\n         * - `row` - the current row object being processed in the array\r\n         * - `index` - the index of the current row being processed in the array\r\n         * - `data` - the array of rows resolved by method {@link Database#any any}\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the callback.\r\n         *\r\n         * @returns {external:Promise<Array<Object>>}\r\n         * Resolves with the original array of rows.\r\n         *\r\n         * @see\r\n         * {@link Database#any any},\r\n         * {@link Database#map map},\r\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach Array.forEach}\r\n         *\r\n         * @example\r\n         *\r\n         * db.each('SELECT id, code, name FROM Events', [], row => {\r\n         *     row.code = parseInt(row.code);\r\n         * })\r\n         *     .then(data => {\r\n         *         // data = array of events, with 'code' converted into integer\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */\r\n        obj.each = function (query, values, cb, thisArg) {\r\n            return obj.any.call(this, query, values)\r\n                .then(data => {\r\n                    data.forEach(cb, thisArg);\r\n                    return data;\r\n                });\r\n        };\r\n\r\n        /**\r\n         * @method Database#task\r\n         * @description\r\n         * Executes a callback function with automatically managed connection.\r\n         *\r\n         * When invoked on the root {@link Database} object, the method allocates the connection from the pool,\r\n         * executes the callback, and once finished - releases the connection back to the pool.\r\n         * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n         *\r\n         * This method should be used whenever executing more than one query at once, so the allocated connection\r\n         * is reused between all queries, and released only after the task has finished (see $[Chaining Queries]).\r\n         *\r\n         * The callback function is called with one parameter - database protocol (same as `this`), extended with methods\r\n         * {@link Task#batch batch}, {@link Task#page page}, {@link Task#sequence sequence}, plus property {@link Task#ctx ctx} -\r\n         * the task context object. See class {@link Task} for more details.\r\n         *\r\n         * @param {string|number|Object} [options]\r\n         * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n         *\r\n         * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n         * it is expected to be an object with options as listed below.\r\n         *\r\n         * @param {} [options.tag]\r\n         * Traceable context for the task (see $[tags]).\r\n         *\r\n         * @param {function} cb\r\n         * Task callback function, to return the result that will determine either success or failure for the operation.\r\n         *\r\n         * The function can be either the first of the second parameter passed into the method.\r\n         *\r\n         * It also can be an ES7 `async` function.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object with the result from the callback function.\r\n         *\r\n         * @see\r\n         * {@link Task},\r\n         * {@link Database#taskIf taskIf},\r\n         * {@link Database#tx tx},\r\n         * $[tags],\r\n         * $[Chaining Queries]\r\n         *\r\n         * @example\r\n         *\r\n         * db.task('my-task', t => {\r\n         *         // t.ctx = task context object\r\n         *\r\n         *         return t.one('SELECT id FROM Users WHERE name = $1', 'John')\r\n         *             .then(user => {\r\n         *                 return t.any('SELECT * FROM Events WHERE userId = $1', user.id);\r\n         *             });\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the task's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // using an ES7 syntax for the callback:\r\n         * db.task('my-task', async t {\r\n         *         // t.ctx = task context object\r\n         *\r\n         *         const user = await t.one('SELECT id FROM Users WHERE name = $1', 'John');\r\n         *         return t.any('SELECT * FROM Events WHERE userId = $1', user.id);\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the task's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */\r\n        obj.task = function () {\r\n            const args = npm.pubUtils.taskArgs(arguments);\r\n            assertOptions(args.options, [`tag`]);\r\n            return taskProcessor.call(this, args, false);\r\n        };\r\n\r\n        /**\r\n         * @method Database#taskIf\r\n         * @description\r\n         * Executes a conditional task that results in an actual new {@link Database#task task}, if either condition is met or\r\n         * when it is necessary (on the top level), or else it reuses the current connection context.\r\n         *\r\n         * The default condition is `not in task or transaction`, to start a task only if currently not inside another task or transaction,\r\n         * which is the same as calling the following:\r\n         *\r\n         * ```js\r\n         * db.taskIf({cnd: t => !t.ctx}, cb => {})\r\n         * ```\r\n         *\r\n         * It can be useful, if you want to simplify/reduce the task + log events footprint, by creating new tasks only when necessary.\r\n         *\r\n         * @param {string|number|Object} [options]\r\n         * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n         *\r\n         * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n         * it is expected to be an object with options as listed below.\r\n         *\r\n         * @param {} [options.tag]\r\n         * Traceable context for the task/transaction (see $[tags]).\r\n         *\r\n         * @param {boolean|function} [options.cnd]\r\n         * Condition for creating a ({@link Database#task task}), if it is met.\r\n         * It can be either a simple boolean, or a callback function that takes the task context as `this` and as the first parameter.\r\n         *\r\n         * Default condition (when it is not specified):\r\n         *\r\n         * ```js\r\n         * {cnd: t => !t.ctx}\r\n         * ```\r\n         *\r\n         * @param {function} cb\r\n         * Task callback function, to return the result that will determine either success or failure for the operation.\r\n         *\r\n         * The function can be either the first or the second parameter passed into the method.\r\n         *\r\n         * It also can be an ES7 `async` function.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object with the result from the callback function.\r\n         *\r\n         * @see\r\n         * {@link Task},\r\n         * {@link Database#task Database.task},\r\n         * {@link Database#tx Database.tx},\r\n         * {@link Database#txIf Database.txIf},\r\n         * {@link TaskContext}\r\n         *\r\n         */\r\n        obj.taskIf = function () {\r\n            const args = npm.pubUtils.taskArgs(arguments);\r\n            assertOptions(args.options, [`tag`, `cnd`]);\r\n            try {\r\n                let cnd = args.options.cnd;\r\n                if (`cnd` in args.options) {\r\n                    cnd = typeof cnd === `function` ? cnd.call(obj, obj) : !!cnd;\r\n                } else {\r\n                    cnd = !obj.ctx; // create task, if it is the top level\r\n                }\r\n                // reusable only if condition fails, and not top-level:\r\n                args.options.reusable = !cnd && !!obj.ctx;\r\n            } catch (e) {\r\n                return $p.reject(e);\r\n            }\r\n            return taskProcessor.call(this, args, false);\r\n        };\r\n\r\n        /**\r\n         * @method Database#tx\r\n         * @description\r\n         * Executes a callback function as a transaction, with automatically managed connection.\r\n         *\r\n         * When invoked on the root {@link Database} object, the method allocates the connection from the pool,\r\n         * executes the callback, and once finished - releases the connection back to the pool.\r\n         * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n         *\r\n         * A transaction wraps a regular {@link Database#task task} into additional queries:\r\n         * - it executes `BEGIN` just before invoking the callback function\r\n         * - it executes `COMMIT`, if the callback didn't throw any error or return a rejected promise\r\n         * - it executes `ROLLBACK`, if the callback did throw an error or return a rejected promise\r\n         * - it executes corresponding `SAVEPOINT` commands when the method is called recursively.\r\n         *\r\n         * The callback function is called with one parameter - database protocol (same as `this`), extended with methods\r\n         * {@link Task#batch batch}, {@link Task#page page}, {@link Task#sequence sequence}, plus property {@link Task#ctx ctx} -\r\n         * the transaction context object. See class {@link Task} for more details.\r\n         *\r\n         * Note that transactions should be chosen over tasks only where necessary, because unlike regular tasks,\r\n         * transactions are blocking operations, and must be used with caution.\r\n         *\r\n         * @param {string|number|Object} [options]\r\n         * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n         *\r\n         * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n         * it is expected to be an object with options as listed below.\r\n         *\r\n         * @param {} [options.tag]\r\n         * Traceable context for the transaction (see $[tags]).\r\n         *\r\n         * @param {txMode.TransactionMode} [options.mode]\r\n         * Transaction Configuration Mode - extends the transaction-opening command with additional configuration.\r\n         *\r\n         * @param {function} cb\r\n         * Transaction callback function, to return the result that will determine either success or failure for the operation.\r\n         *\r\n         * The function can be either the first of the second parameter passed into the method.\r\n         *\r\n         * It also can be an ES7 `async` function.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object with the result from the callback function.\r\n         *\r\n         * @see\r\n         * {@link Task},\r\n         * {@link Database#task Database.task},\r\n         * {@link Database#taskIf Database.taskIf},\r\n         * {@link TaskContext},\r\n         * $[tags],\r\n         * $[Chaining Queries]\r\n         *\r\n         * @example\r\n         *\r\n         * db.tx('my-transaction', t => {\r\n         *         // t.ctx = transaction context object\r\n         *\r\n         *         return t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25])\r\n         *             .then(user => {\r\n         *                 return t.batch([\r\n         *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']),\r\n         *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'login'])\r\n         *                 ]);\r\n         *             });\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the transaction's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // using an ES7 syntax for the callback:\r\n         * db.tx('my-transaction', async t {\r\n         *         // t.ctx = transaction context object\r\n         *\r\n         *         const user = await t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25]);\r\n         *         return t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']);\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the transaction's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */\r\n        obj.tx = function () {\r\n            const args = npm.pubUtils.taskArgs(arguments);\r\n            assertOptions(args.options, [`tag`, `mode`]);\r\n            return taskProcessor.call(this, args, true);\r\n        };\r\n\r\n        /**\r\n         * @method Database#txIf\r\n         * @description\r\n         * Executes a conditional transaction that results in an actual transaction ({@link Database#tx tx}), if the condition is met,\r\n         * or else it executes a regular {@link Database#task task}.\r\n         *\r\n         * The default condition is `not in transaction`, to start a transaction only if currently not in transaction,\r\n         * or else start a task, which is the same as calling the following:\r\n         *\r\n         * ```js\r\n         * db.txIf({cnd: t => !t.ctx || !t.ctx.inTransaction}, cb => {})\r\n         * ```\r\n         *\r\n         * It is useful when you want to avoid $[Nested Transactions] - savepoints.\r\n         *\r\n         * @param {string|number|Object} [options]\r\n         * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n         *\r\n         * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n         * it is expected to be an object with options as listed below.\r\n         *\r\n         * @param {} [options.tag]\r\n         * Traceable context for the task/transaction (see $[tags]).\r\n         *\r\n         * @param {txMode.TransactionMode} [options.mode]\r\n         * Transaction Configuration Mode - extends the transaction-opening command with additional configuration.\r\n         *\r\n         * @param {boolean|function} [options.cnd]\r\n         * Condition for opening a transaction ({@link Database#tx tx}), if it is met, or a {@link Database#task task} when the condition is not met.\r\n         * It can be either a simple boolean, or a callback function that takes the task/tx context as `this` and as the first parameter.\r\n         *\r\n         * Default condition (when it is not specified):\r\n         *\r\n         * ```js\r\n         * {cnd: t => !t.ctx || !t.ctx.inTransaction}\r\n         * ```\r\n         *\r\n         * @param {boolean|function} [options.reusable=false]\r\n         * When `cnd` is/returns false, reuse context of the current task/transaction, if one exists.\r\n         * It can be either a simple boolean, or a callback function that takes the task/tx context as `this`\r\n         * and as the first parameter.\r\n         *\r\n         * By default, when `cnd` is/returns false, the method creates a new task. This option tells\r\n         * the method to reuse the current task/transaction context, and not create a new task.\r\n         *\r\n         * This option is ignored when executing against the top level of the protocol, because on\r\n         * that level, if no transaction is suddenly needed, a new task becomes necessary.\r\n         *\r\n         * @param {function} cb\r\n         * Transaction/task callback function, to return the result that will determine either\r\n         * success or failure for the operation.\r\n         *\r\n         * The function can be either the first or the second parameter passed into the method.\r\n         *\r\n         * It also can be an ES7 `async` function.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object with the result from the callback function.\r\n         *\r\n         * @see\r\n         * {@link Task},\r\n         * {@link Database#task Database.task},\r\n         * {@link Database#taskIf Database.taskIf},\r\n         * {@link Database#tx Database.tx},\r\n         * {@link TaskContext}\r\n         *\r\n         */\r\n        obj.txIf = function () {\r\n            const args = npm.pubUtils.taskArgs(arguments);\r\n            assertOptions(args.options, [`tag`, `mode`, `cnd`, `reusable`]);\r\n            try {\r\n                let cnd;\r\n                if (`cnd` in args.options) {\r\n                    cnd = args.options.cnd;\r\n                    cnd = typeof cnd === `function` ? cnd.call(obj, obj) : !!cnd;\r\n                } else {\r\n                    cnd = !obj.ctx || !obj.ctx.inTransaction;\r\n                }\r\n                args.options.cnd = cnd;\r\n                const reusable = args.options.reusable;\r\n                args.options.reusable = !cnd && obj.ctx && typeof reusable === `function` ? reusable.call(obj, obj) : !!reusable;\r\n            } catch (e) {\r\n                return $p.reject(e);\r\n            }\r\n            return taskProcessor.call(this, args, args.options.cnd);\r\n        };\r\n\r\n        // Task method;\r\n        // Resolves with result from the callback function;\r\n        function taskProcessor(params, isTX) {\r\n\r\n            if (typeof params.cb !== `function`) {\r\n                return $p.reject(new TypeError(`Callback function is required.`));\r\n            }\r\n\r\n            if (params.options.reusable) {\r\n                return config.$npm.task.callback(obj.ctx, obj, params.cb, config);\r\n            }\r\n\r\n            const taskCtx = ctx.clone(); // task context object;\r\n            if (isTX) {\r\n                taskCtx.txLevel = taskCtx.txLevel >= 0 ? (taskCtx.txLevel + 1) : 0;\r\n            }\r\n            taskCtx.inTransaction = taskCtx.txLevel >= 0;\r\n            taskCtx.level = taskCtx.level >= 0 ? (taskCtx.level + 1) : 0;\r\n            taskCtx.cb = params.cb; // callback function;\r\n            taskCtx.mode = params.options.mode; // transaction mode;\r\n            if (this !== obj) {\r\n                taskCtx.context = this; // calling context object;\r\n            }\r\n\r\n            const tsk = new config.$npm.task.Task(taskCtx, params.options.tag, isTX, config);\r\n            taskCtx.taskCtx = tsk.ctx;\r\n            extend(taskCtx, tsk);\r\n\r\n            if (taskCtx.db) {\r\n                // reuse existing connection;\r\n                npm.utils.addReadProp(tsk.ctx, `useCount`, taskCtx.db.useCount);\r\n                addServerVersion(tsk.ctx, taskCtx.db.client);\r\n                return config.$npm.task.execute(taskCtx, tsk, isTX, config);\r\n            }\r\n\r\n            // connection required;\r\n            return config.$npm.connect.pool(taskCtx, dbThis)\r\n                .then(db => {\r\n                    taskCtx.connect(db);\r\n                    npm.utils.addReadProp(tsk.ctx, `useCount`, db.useCount);\r\n                    addServerVersion(tsk.ctx, db.client);\r\n                    return config.$npm.task.execute(taskCtx, tsk, isTX, config);\r\n                })\r\n                .then(data => {\r\n                    taskCtx.disconnect();\r\n                    return data;\r\n                })\r\n                .catch(error => {\r\n                    taskCtx.disconnect();\r\n                    return $p.reject(error);\r\n                });\r\n        }\r\n\r\n        function addServerVersion(target, client) {\r\n            // Exclude else-case from coverage, because it can only occur with Native Bindings.\r\n            // istanbul ignore else\r\n            if (client.serverVersion) {\r\n                npm.utils.addReadProp(target, `serverVersion`, client.serverVersion);\r\n            }\r\n        }\r\n\r\n        // lock all default properties to read-only,\r\n        // to prevent override by the client.\r\n        npm.utils.lock(obj, false, ctx.options);\r\n\r\n        // extend the protocol;\r\n        Events.extend(ctx.options, obj, ctx.dc);\r\n\r\n        // freeze the protocol permanently;\r\n        npm.utils.lock(obj, true, ctx.options);\r\n    }\r\n\r\n}\r\n\r\n// this event only happens when the connection is lost physically,\r\n// which cannot be tested automatically; removing from coverage:\r\n// istanbul ignore next\r\nfunction onError(err) {\r\n    // this client was never seen by pg-promise, which\r\n    // can happen if it failed to initialize\r\n    if (!err.client.$ctx) {\r\n        return;\r\n    }\r\n    const ctx = err.client.$ctx;\r\n    Events.error(ctx.options, err, {\r\n        cn: npm.utils.getSafeConnection(ctx.cn),\r\n        dc: ctx.dc\r\n    });\r\n}\r\n\r\nmodule.exports = config => {\r\n    const npmLocal = config.$npm;\r\n    npmLocal.connect = npmLocal.connect || npm.connect(config);\r\n    npmLocal.query = npmLocal.query || npm.query(config);\r\n    npmLocal.task = npmLocal.task || npm.task(config);\r\n    return Database;\r\n};\r\n\r\n/**\r\n * @callback Database.streamInitCB\r\n * @description\r\n * Stream initialization callback, used by {@link Database#stream Database.stream}.\r\n *\r\n * @param {external:Stream} stream\r\n * Stream object to initialize streaming.\r\n *\r\n * @example\r\n * const QueryStream = require('pg-query-stream');\r\n * const JSONStream = require('JSONStream');\r\n *\r\n * // you can also use pgp.as.format(query, values, options)\r\n * // to format queries properly, via pg-promise;\r\n * const qs = new QueryStream('SELECT * FROM users');\r\n *\r\n * db.stream(qs, stream => {\r\n *         // initiate streaming into the console:\r\n *         stream.pipe(JSONStream.stringify()).pipe(process.stdout);\r\n *     })\r\n *     .then(data => {\r\n *         console.log('Total rows processed:', data.processed,\r\n *           'Duration in milliseconds:', data.duration);\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n */\r\n\r\n/**\r\n * @external Stream\r\n * @see https://nodejs.org/api/stream.html\r\n */\r\n\r\n/**\r\n * @external pg-pool\r\n * @alias pg-pool\r\n * @see https://github.com/brianc/node-pg-pool\r\n */\r\n\r\n/**\r\n * @external Result\r\n * @see https://node-postgres.com/api/result\r\n */\r\n"]},"metadata":{},"sourceType":"script"}