{"ast":null,"code":"const npm = {\n  u: require('util'),\n  os: require('os'),\n  utils: require('../utils/static')\n};\n/**\r\n * @class errors.BatchError\r\n * @augments external:Error\r\n * @description\r\n * This type represents all errors rejected by method {@link batch}, except for {@link external:TypeError TypeError}\r\n * when the method receives invalid input parameters.\r\n *\r\n * @property {string} name\r\n * Standard {@link external:Error Error} property - error type name = `BatchError`.\r\n *\r\n * @property {string} message\r\n * Standard {@link external:Error Error} property - the error message.\r\n *\r\n * It represents the message of the first error encountered in the batch, and is a safe\r\n * version of using `first.message`.\r\n *\r\n * @property {string} stack\r\n * Standard {@link external:Error Error} property - the stack trace.\r\n *\r\n * @property {array} data\r\n * Array of objects `{success, result, [origin]}`:\r\n * - `success` = true/false, indicates whether the corresponding value in the input array was resolved.\r\n * - `result` = resolved data, if `success`=`true`, or else the rejection reason.\r\n * - `origin` - set only when failed as a result of an unsuccessful call into the notification callback\r\n *    (parameter `cb` of method {@link batch})\r\n *\r\n * The array has the same size as the input one that was passed into method {@link batch}, providing direct mapping.\r\n *\r\n * @property {} stat\r\n * Resolution Statistics.\r\n *\r\n * @property {number} stat.total\r\n * Total number of elements in the batch.\r\n *\r\n * @property {number} stat.succeeded\r\n * Number of resolved values in the batch.\r\n *\r\n * @property {number} stat.failed\r\n * Number of rejected values in the batch.\r\n *\r\n * @property {number} stat.duration\r\n * Time in milliseconds it took to settle all values.\r\n *\r\n * @property {} first\r\n * The very first error within the batch, with support for nested batch results, it is also the same error\r\n * as $[promise.all] would provide.\r\n *\r\n * @see {@link batch}\r\n *\r\n */\n\nclass BatchError extends Error {\n  constructor(result, errors, duration) {\n    function getErrors() {\n      const err = new Array(errors.length);\n\n      for (let i = 0; i < errors.length; i++) {\n        err[i] = result[errors[i]].result;\n\n        if (err[i] instanceof BatchError) {\n          err[i] = err[i].getErrors();\n        }\n      }\n\n      npm.utils.extend(err, '$isErrorList', true);\n      return err;\n    }\n\n    const e = getErrors();\n    let first = e[0];\n\n    while (first && first.$isErrorList) {\n      first = first[0];\n    }\n\n    let message;\n\n    if (first instanceof Error) {\n      message = first.message;\n    } else {\n      if (typeof first !== 'string') {\n        first = npm.u.inspect(first);\n      }\n\n      message = first;\n    }\n\n    super(message);\n    this.name = this.constructor.name;\n    this.data = result; // we do not show it within the inspect, because when the error\n    // happens for a nested result, the output becomes a mess.\n\n    this.first = first;\n    this.stat = {\n      total: result.length,\n      succeeded: result.length - e.length,\n      failed: e.length,\n      duration: duration\n    };\n    this.getErrors = getErrors;\n    Error.captureStackTrace(this, this.constructor);\n  }\n  /**\r\n   * @method errors.BatchError.getErrors\r\n   * @description\r\n   * Returns the complete list of errors only.\r\n   *\r\n   * It supports nested batch results, presented as a sub-array.\r\n   *\r\n   * @returns {array}\r\n   */\n\n\n}\n/**\r\n * @method errors.BatchError.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the error.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * The output is an abbreviated version of the error, because the complete error\r\n * is often too much for displaying or even logging, as a batch can be of any size.\r\n * Therefore, only errors are rendered from the `data` property, alongside their indexes,\r\n * and only up to the first 5, to avoid polluting the screen or the log file.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\n\n\nBatchError.prototype.toString = function (level) {\n  level = level > 0 ? parseInt(level) : 0;\n  const gap0 = npm.utils.messageGap(level),\n        gap1 = npm.utils.messageGap(level + 1),\n        gap2 = npm.utils.messageGap(level + 2),\n        lines = ['BatchError {', gap1 + 'stat: { total: ' + this.stat.total + ', succeeded: ' + this.stat.succeeded + ', failed: ' + this.stat.failed + ', duration: ' + this.stat.duration + ' }', gap1 + 'errors: [']; // In order to avoid polluting the error log or the console, \n  // we limit the log output to the top 5 errors:\n\n  const maxErrors = 5;\n  let counter = 0;\n  this.data.forEach((d, index) => {\n    if (!d.success && counter < maxErrors) {\n      lines.push(gap2 + index + ': ' + npm.utils.formatError(d.result, level + 2));\n      counter++;\n    }\n  });\n  lines.push(gap1 + ']');\n  lines.push(gap0 + '}');\n  return lines.join(npm.os.EOL);\n};\n\nnpm.utils.addInspection(BatchError, function () {\n  return this.toString();\n});\nmodule.exports = {\n  BatchError\n};","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/spex/lib/errors/batch.js"],"names":["npm","u","require","os","utils","BatchError","Error","constructor","result","errors","duration","getErrors","err","Array","length","i","extend","e","first","$isErrorList","message","inspect","name","data","stat","total","succeeded","failed","captureStackTrace","prototype","toString","level","parseInt","gap0","messageGap","gap1","gap2","lines","maxErrors","counter","forEach","d","index","success","push","formatError","join","EOL","addInspection","module","exports"],"mappings":"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","sourcesContent":["const npm = {\r\n    u: require('util'),\r\n    os: require('os'),\r\n    utils: require('../utils/static')\r\n};\r\n\r\n/**\r\n * @class errors.BatchError\r\n * @augments external:Error\r\n * @description\r\n * This type represents all errors rejected by method {@link batch}, except for {@link external:TypeError TypeError}\r\n * when the method receives invalid input parameters.\r\n *\r\n * @property {string} name\r\n * Standard {@link external:Error Error} property - error type name = `BatchError`.\r\n *\r\n * @property {string} message\r\n * Standard {@link external:Error Error} property - the error message.\r\n *\r\n * It represents the message of the first error encountered in the batch, and is a safe\r\n * version of using `first.message`.\r\n *\r\n * @property {string} stack\r\n * Standard {@link external:Error Error} property - the stack trace.\r\n *\r\n * @property {array} data\r\n * Array of objects `{success, result, [origin]}`:\r\n * - `success` = true/false, indicates whether the corresponding value in the input array was resolved.\r\n * - `result` = resolved data, if `success`=`true`, or else the rejection reason.\r\n * - `origin` - set only when failed as a result of an unsuccessful call into the notification callback\r\n *    (parameter `cb` of method {@link batch})\r\n *\r\n * The array has the same size as the input one that was passed into method {@link batch}, providing direct mapping.\r\n *\r\n * @property {} stat\r\n * Resolution Statistics.\r\n *\r\n * @property {number} stat.total\r\n * Total number of elements in the batch.\r\n *\r\n * @property {number} stat.succeeded\r\n * Number of resolved values in the batch.\r\n *\r\n * @property {number} stat.failed\r\n * Number of rejected values in the batch.\r\n *\r\n * @property {number} stat.duration\r\n * Time in milliseconds it took to settle all values.\r\n *\r\n * @property {} first\r\n * The very first error within the batch, with support for nested batch results, it is also the same error\r\n * as $[promise.all] would provide.\r\n *\r\n * @see {@link batch}\r\n *\r\n */\r\nclass BatchError extends Error {\r\n\r\n    constructor(result, errors, duration) {\r\n\r\n        function getErrors() {\r\n            const err = new Array(errors.length);\r\n            for (let i = 0; i < errors.length; i++) {\r\n                err[i] = result[errors[i]].result;\r\n                if (err[i] instanceof BatchError) {\r\n                    err[i] = err[i].getErrors();\r\n                }\r\n            }\r\n            npm.utils.extend(err, '$isErrorList', true);\r\n            return err;\r\n        }\r\n\r\n        const e = getErrors();\r\n\r\n        let first = e[0];\r\n\r\n        while (first && first.$isErrorList) {\r\n            first = first[0];\r\n        }\r\n\r\n        let message;\r\n\r\n        if (first instanceof Error) {\r\n            message = first.message;\r\n        } else {\r\n            if (typeof first !== 'string') {\r\n                first = npm.u.inspect(first);\r\n            }\r\n            message = first;\r\n        }\r\n\r\n        super(message);\r\n        this.name = this.constructor.name;\r\n\r\n        this.data = result;\r\n\r\n        // we do not show it within the inspect, because when the error\r\n        // happens for a nested result, the output becomes a mess.\r\n        this.first = first;\r\n\r\n        this.stat = {\r\n            total: result.length,\r\n            succeeded: result.length - e.length,\r\n            failed: e.length,\r\n            duration: duration\r\n        };\r\n\r\n        this.getErrors = getErrors;\r\n\r\n        Error.captureStackTrace(this, this.constructor);\r\n    }\r\n\r\n    /**\r\n     * @method errors.BatchError.getErrors\r\n     * @description\r\n     * Returns the complete list of errors only.\r\n     *\r\n     * It supports nested batch results, presented as a sub-array.\r\n     *\r\n     * @returns {array}\r\n     */\r\n}\r\n\r\n/**\r\n * @method errors.BatchError.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the error.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * The output is an abbreviated version of the error, because the complete error\r\n * is often too much for displaying or even logging, as a batch can be of any size.\r\n * Therefore, only errors are rendered from the `data` property, alongside their indexes,\r\n * and only up to the first 5, to avoid polluting the screen or the log file.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nBatchError.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    const gap0 = npm.utils.messageGap(level),\r\n        gap1 = npm.utils.messageGap(level + 1),\r\n        gap2 = npm.utils.messageGap(level + 2),\r\n        lines = [\r\n            'BatchError {',\r\n            gap1 + 'stat: { total: ' + this.stat.total + ', succeeded: ' + this.stat.succeeded +\r\n            ', failed: ' + this.stat.failed + ', duration: ' + this.stat.duration + ' }',\r\n            gap1 + 'errors: ['\r\n        ];\r\n\r\n    // In order to avoid polluting the error log or the console, \r\n    // we limit the log output to the top 5 errors:\r\n    const maxErrors = 5;\r\n    let counter = 0;\r\n    this.data.forEach((d, index) => {\r\n        if (!d.success && counter < maxErrors) {\r\n            lines.push(gap2 + index + ': ' + npm.utils.formatError(d.result, level + 2));\r\n            counter++;\r\n        }\r\n    });\r\n    lines.push(gap1 + ']');\r\n    lines.push(gap0 + '}');\r\n    return lines.join(npm.os.EOL);\r\n};\r\n\r\nnpm.utils.addInspection(BatchError, function () {\r\n    return this.toString();\r\n});\r\n\r\nmodule.exports = {BatchError};\r\n\r\n"]},"metadata":{},"sourceType":"script"}