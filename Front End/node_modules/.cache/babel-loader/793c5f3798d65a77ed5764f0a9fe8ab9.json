{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\nconst {\n  InnerState\n} = require(`../inner-state`);\n\nconst {\n  assertOptions\n} = require(`assert-options`);\n\nconst {\n  TableName\n} = require(`./table-name`);\n\nconst {\n  Column\n} = require(`./column`);\n\nconst npm = {\n  os: require(`os`),\n  utils: require(`../utils`),\n  formatting: require(`../formatting`)\n};\n/**\r\n * @class helpers.ColumnSet\r\n * @description\r\n * Performance-optimized, read-only structure with query-formatting columns.\r\n *\r\n * In order to avail from performance optimization provided by this class, it should be created\r\n * only once, statically, and then reused.\r\n *\r\n * @param {object|helpers.Column|array} columns\r\n * Columns information object, depending on the type:\r\n *\r\n * - When it is a simple object, its properties are enumerated to represent both column names and property names\r\n *   within the source objects. See also option `inherit` that's applicable in this case.\r\n *\r\n * - When it is a single {@link helpers.Column Column} object, property {@link helpers.ColumnSet#columns columns} is initialized with\r\n *   just a single column. It is not a unique situation when only a single column is required for an update operation.\r\n *\r\n * - When it is an array, each element is assumed to represent details for a column. If the element is already of type {@link helpers.Column Column},\r\n *   it is used directly; otherwise the element is passed into {@link helpers.Column Column} constructor for initialization.\r\n *   On any duplicate column name (case-sensitive) it will throw {@link external:Error Error} = `Duplicate column name \"name\".`\r\n *\r\n * - When it is none of the above, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'columns' specified.`\r\n *\r\n * @param {object} [options]\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [options.table]\r\n * Table details.\r\n *\r\n * When it is a non-null value, and not a {@link helpers.TableName TableName} object, a new {@link helpers.TableName TableName} is constructed from the value.\r\n *\r\n * It can be used as the default for methods {@link helpers.insert insert} and {@link helpers.update update} when their parameter\r\n * `table` is omitted, and for logging purposes.\r\n *\r\n * @param {boolean} [options.inherit = false]\r\n * Use inherited properties in addition to the object's own properties.\r\n *\r\n * By default, only the object's own properties are enumerated for column names.\r\n *\r\n * @returns {helpers.ColumnSet}\r\n *\r\n * @see\r\n *\r\n * {@link helpers.ColumnSet#columns columns},\r\n * {@link helpers.ColumnSet#names names},\r\n * {@link helpers.ColumnSet#table table},\r\n * {@link helpers.ColumnSet#variables variables} |\r\n * {@link helpers.ColumnSet#assign assign},\r\n * {@link helpers.ColumnSet#assignColumns assignColumns},\r\n * {@link helpers.ColumnSet#extend extend},\r\n * {@link helpers.ColumnSet#merge merge},\r\n * {@link helpers.ColumnSet#prepare prepare}\r\n *\r\n * @example\r\n *\r\n * // A complex insert/update object scenario for table 'purchases' in schema 'fiscal'.\r\n * // For a good performance, you should declare such objects once and then reuse them.\r\n * //\r\n * // Column Requirements:\r\n * //\r\n * // 1. Property 'id' is only to be used for a WHERE condition in updates\r\n * // 2. Property 'list' needs to be formatted as a csv\r\n * // 3. Property 'code' is to be used as raw text, and to be defaulted to 0 when the\r\n * //    property is missing in the source object\r\n * // 4. Property 'log' is a JSON object with 'log-entry' for the column name\r\n * // 5. Property 'data' requires SQL type casting '::int[]'\r\n * // 6. Property 'amount' needs to be set to 100, if it is 0\r\n * // 7. Property 'total' must be skipped during updates, if 'amount' was 0, plus its\r\n * //    column name is 'total-val'\r\n *\r\n * const cs = new pgp.helpers.ColumnSet([\r\n *     '?id', // ColumnConfig equivalent: {name: 'id', cnd: true}\r\n *     'list:csv', // ColumnConfig equivalent: {name: 'list', mod: ':csv'}\r\n *     {\r\n *         name: 'code',\r\n *         mod: '^', // format as raw text\r\n *         def: 0 // default to 0 when the property doesn't exist\r\n *     },\r\n *     {\r\n *         name: 'log-entry',\r\n *         prop: 'log',\r\n *         mod: ':json' // format as JSON\r\n *     },\r\n *     {\r\n *         name: 'data',\r\n *         cast: 'int[]' // use SQL type casting '::int[]'\r\n *     },\r\n *     {\r\n *         name: 'amount',\r\n *         init: col => {\r\n *             // set to 100, if the value is 0:\r\n *             return col.value === 0 ? 100 : col.value;\r\n *         }\r\n *     },\r\n *     {\r\n *         name: 'total-val',\r\n *         prop: 'total',\r\n *         skip: col => {\r\n *             // skip from updates, if 'amount' is 0:\r\n *             return col.source.amount === 0;\r\n *         }\r\n *     }\r\n * ], {table: {table: 'purchases', schema: 'fiscal'}});\r\n *\r\n * // Alternatively, you could take the table declaration out:\r\n * // const table = new pgp.helpers.TableName('purchases', 'fiscal');\r\n *\r\n * console.log(cs); // console output for the object:\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"fiscal\".\"purchases\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"id\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"list\"\r\n * //            mod: \":csv\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"code\"\r\n * //            mod: \"^\"\r\n * //            def: 0\r\n * //        }\r\n * //        Column {\r\n * //            name: \"log-entry\"\r\n * //            prop: \"log\"\r\n * //            mod: \":json\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"data\"\r\n * //            cast: \"int[]\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"amount\"\r\n * //            init: [Function]\r\n * //        }\r\n * //        Column {\r\n * //            name: \"total-val\"\r\n * //            prop: \"total\"\r\n * //            skip: [Function]\r\n * //        }\r\n * //    ]\r\n * // }\r\n */\n\nclass ColumnSet extends InnerState {\n  constructor(columns, opt) {\n    super();\n\n    if (!columns || typeof columns !== `object`) {\n      throw new TypeError(`Invalid parameter 'columns' specified.`);\n    }\n\n    opt = assertOptions(opt, [`table`, `inherit`]);\n\n    if (!npm.utils.isNull(opt.table)) {\n      this.table = opt.table instanceof TableName ? opt.table : new TableName(opt.table);\n    }\n    /**\r\n     * @name helpers.ColumnSet#table\r\n     * @type {helpers.TableName}\r\n     * @readonly\r\n     * @description\r\n     * Destination table. It can be specified for two purposes:\r\n     *\r\n     * - **primary:** to be used as the default table when it is omitted during a call into methods {@link helpers.insert insert} and {@link helpers.update update}\r\n     * - **secondary:** to be automatically written into the console (for logging purposes).\r\n     */\n\n    /**\r\n     * @name helpers.ColumnSet#columns\r\n     * @type helpers.Column[]\r\n     * @readonly\r\n     * @description\r\n     * Array of {@link helpers.Column Column} objects.\r\n     */\n\n\n    if (Array.isArray(columns)) {\n      const colNames = {};\n      this.columns = columns.map(c => {\n        const col = c instanceof Column ? c : new Column(c);\n\n        if (col.name in colNames) {\n          throw new Error(`Duplicate column name \"${col.name}\".`);\n        }\n\n        colNames[col.name] = true;\n        return col;\n      });\n    } else {\n      if (columns instanceof Column) {\n        this.columns = [columns];\n      } else {\n        this.columns = [];\n\n        for (const name in columns) {\n          if (opt.inherit || Object.prototype.hasOwnProperty.call(columns, name)) {\n            this.columns.push(new Column(name));\n          }\n        }\n      }\n    }\n\n    Object.freeze(this.columns);\n    Object.freeze(this);\n    this.extendState({\n      names: undefined,\n      variables: undefined,\n      updates: undefined,\n      isSimple: true\n    });\n\n    for (let i = 0; i < this.columns.length; i++) {\n      const c = this.columns[i]; // ColumnSet is simple when the source objects require no preparation,\n      // and should be used directly:\n\n      if (c.prop || c.init || `def` in c) {\n        this._inner.isSimple = false;\n        break;\n      }\n    }\n  }\n  /**\r\n   * @name helpers.ColumnSet#names\r\n   * @type string\r\n   * @readonly\r\n   * @description\r\n   * Returns a string - comma-separated list of all column names, properly escaped.\r\n   *\r\n   * @example\r\n   * const cs = new ColumnSet(['id^', {name: 'cells', cast: 'int[]'}, 'doc:json']);\r\n   * console.log(cs.names);\r\n   * //=> \"id\",\"cells\",\"doc\"\r\n   */\n\n\n  get names() {\n    const _i = this._inner;\n\n    if (!_i.names) {\n      _i.names = this.columns.map(c => c.escapedName).join();\n    }\n\n    return _i.names;\n  }\n  /**\r\n   * @name helpers.ColumnSet#variables\r\n   * @type string\r\n   * @readonly\r\n   * @description\r\n   * Returns a string - formatting template for all column values.\r\n   *\r\n   * @see {@link helpers.ColumnSet#assign assign}\r\n   *\r\n   * @example\r\n   * const cs = new ColumnSet(['id^', {name: 'cells', cast: 'int[]'}, 'doc:json']);\r\n   * console.log(cs.variables);\r\n   * //=> ${id^},${cells}::int[],${doc:json}\r\n   */\n\n\n  get variables() {\n    const _i = this._inner;\n\n    if (!_i.variables) {\n      _i.variables = this.columns.map(c => c.variable + c.castText).join();\n    }\n\n    return _i.variables;\n  }\n\n}\n/**\r\n * @method helpers.ColumnSet#assign\r\n * @description\r\n * Returns a formatting template of SET assignments, either generic or for a single object.\r\n *\r\n * The method is optimized to cache the output string when there are no columns that can be skipped dynamically.\r\n *\r\n * This method is primarily for internal use, that's why it does not validate the input.\r\n *\r\n * @param {object} [options]\r\n * Assignment/formatting options.\r\n *\r\n * @param {object} [options.source]\r\n * Source - a single object that contains values for columns.\r\n *\r\n * The object is only necessary to correctly apply the logic of skipping columns dynamically, based on the source data\r\n * and the rules defined in the {@link helpers.ColumnSet ColumnSet}. If, however, you do not care about that, then you do not need to specify any object.\r\n *\r\n * Note that even if you do not specify the object, the columns marked as conditional (`cnd: true`) will always be skipped.\r\n *\r\n * @param {string} [options.prefix]\r\n * In cases where needed, an alias prefix to be added before each column.\r\n *\r\n * @returns {string}\r\n * Comma-separated list of variable-to-column assignments.\r\n *\r\n * @see {@link helpers.ColumnSet#variables variables}\r\n *\r\n * @example\r\n *\r\n * const cs = new pgp.helpers.ColumnSet([\r\n *     '?first', // = {name: 'first', cnd: true}\r\n *     'second:json',\r\n *     {name: 'third', mod: ':raw', cast: 'text'}\r\n * ]);\r\n *\r\n * cs.assign();\r\n * //=> \"second\"=${second:json},\"third\"=${third:raw}::text\r\n *\r\n * cs.assign({prefix: 'a b c'});\r\n * //=> \"a b c\".\"second\"=${second:json},\"a b c\".\"third\"=${third:raw}::text\r\n */\n\n\nColumnSet.prototype.assign = function (options) {\n  const _i = this._inner;\n  const hasPrefix = options && options.prefix && typeof options.prefix === `string`;\n\n  if (_i.updates && !hasPrefix) {\n    return _i.updates;\n  }\n\n  let dynamic = hasPrefix;\n  const hasSource = options && options.source && typeof options.source === `object`;\n  let list = this.columns.filter(c => {\n    if (c.cnd) {\n      return false;\n    }\n\n    if (c.skip) {\n      dynamic = true;\n\n      if (hasSource) {\n        const a = colDesc(c, options.source);\n\n        if (c.skip.call(options.source, a)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  });\n  const prefix = hasPrefix ? npm.formatting.as.alias(options.prefix) + `.` : ``;\n  list = list.map(c => prefix + c.escapedName + `=` + c.variable + c.castText).join();\n\n  if (!dynamic) {\n    _i.updates = list;\n  }\n\n  return list;\n};\n/**\r\n * @method helpers.ColumnSet#assignColumns\r\n * @description\r\n * Generates assignments for all columns in the set, with support for aliases and column-skipping logic.\r\n * Aliases are set by using method {@link formatting.alias as.alias}.\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {string} [options.from]\r\n * Alias for the source columns.\r\n *\r\n * @param {string} [options.to]\r\n * Alias for the destination columns.\r\n *\r\n * @param {string | Array<string> | function} [options.skip]\r\n * Name(s) of the column(s) to be skipped (case-sensitive). It can be either a single string or an array of strings.\r\n *\r\n * It can also be a function - iterator, to be called for every column, passing in {@link helpers.Column Column} as\r\n * `this` context, and plus as a single parameter. The function would return a truthy value for every column that needs to be skipped.\r\n *\r\n * @returns {string}\r\n * A string of comma-separated column assignments.\r\n *\r\n * @example\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['id', 'city', 'street']);\r\n *\r\n * cs.assignColumns({from: 'EXCLUDED', skip: 'id'})\r\n * //=> \"city\"=EXCLUDED.\"city\",\"street\"=EXCLUDED.\"street\"\r\n *\r\n * @example\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', 'city', 'street']);\r\n *\r\n * cs.assignColumns({from: 'source', to: 'target', skip: c => c.cnd})\r\n * //=> target.\"city\"=source.\"city\",target.\"street\"=source.\"street\"\r\n *\r\n */\n\n\nColumnSet.prototype.assignColumns = function (options) {\n  options = assertOptions(options, [`from`, `to`, `skip`]);\n  const skip = typeof options.skip === `string` && [options.skip] || (Array.isArray(options.skip) || typeof options.skip === `function`) && options.skip;\n  const from = typeof options.from === `string` && options.from && npm.formatting.as.alias(options.from) + `.` || ``;\n  const to = typeof options.to === `string` && options.to && npm.formatting.as.alias(options.to) + `.` || ``;\n  const iterator = typeof skip === `function` ? c => !skip.call(c, c) : c => skip.indexOf(c.name) === -1;\n  const cols = skip ? this.columns.filter(iterator) : this.columns;\n  return cols.map(c => to + c.escapedName + `=` + from + c.escapedName).join();\n};\n/**\r\n * @method helpers.ColumnSet#extend\r\n * @description\r\n * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.\r\n *\r\n * If the two sets contain a column with the same `name` (case-sensitive), an error is thrown.\r\n *\r\n * @param {helpers.Column|helpers.ColumnSet|array} columns\r\n * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:\r\n * - it can also be of type {@link helpers.ColumnSet ColumnSet}\r\n * - it cannot be a simple object (properties enumeration is not supported here)\r\n *\r\n * @returns {helpers.ColumnSet}\r\n * New {@link helpers.ColumnSet ColumnSet} object with the extended/concatenated list of columns.\r\n *\r\n * @see\r\n * {@link helpers.Column Column},\r\n * {@link helpers.ColumnSet#merge merge}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')();\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['one', 'two'], {table: 'my-table'});\r\n * console.log(cs);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n * const csExtended = cs.extend(['three']);\r\n * console.log(csExtended);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"three\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n */\n\n\nColumnSet.prototype.extend = function (columns) {\n  let cs = columns;\n\n  if (!(cs instanceof ColumnSet)) {\n    cs = new ColumnSet(columns);\n  } // Any duplicate column will throw Error = 'Duplicate column name \"name\".',\n\n\n  return new ColumnSet(this.columns.concat(cs.columns), {\n    table: this.table\n  });\n};\n/**\r\n * @method helpers.ColumnSet#merge\r\n * @description\r\n * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.\r\n *\r\n * Items in `columns` with the same `name` (case-sensitive) override the original columns.\r\n *\r\n * @param {helpers.Column|helpers.ColumnSet|array} columns\r\n * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:\r\n * - it can also be of type {@link helpers.ColumnSet ColumnSet}\r\n * - it cannot be a simple object (properties enumeration is not supported here)\r\n *\r\n * @see\r\n * {@link helpers.Column Column},\r\n * {@link helpers.ColumnSet#extend extend}\r\n *\r\n * @returns {helpers.ColumnSet}\r\n * New {@link helpers.ColumnSet ColumnSet} object with the merged list of columns.\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')();\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?one', 'two:json'], {table: 'my-table'});\r\n * console.log(cs);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //            mod: \":json\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n * const csMerged = cs.merge(['two', 'three^']);\r\n * console.log(csMerged);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"three\"\r\n * //            mod: \"^\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n *\r\n */\n\n\nColumnSet.prototype.merge = function (columns) {\n  let cs = columns;\n\n  if (!(cs instanceof ColumnSet)) {\n    cs = new ColumnSet(columns);\n  }\n\n  const colNames = {},\n        cols = [];\n  this.columns.forEach((c, idx) => {\n    cols.push(c);\n    colNames[c.name] = idx;\n  });\n  cs.columns.forEach(c => {\n    if (c.name in colNames) {\n      cols[colNames[c.name]] = c;\n    } else {\n      cols.push(c);\n    }\n  });\n  return new ColumnSet(cols, {\n    table: this.table\n  });\n};\n/**\r\n * @method helpers.ColumnSet#prepare\r\n * @description\r\n * Prepares a source object to be formatted, by cloning it and applying the rules as set by the\r\n * columns configuration.\r\n *\r\n * This method is primarily for internal use, that's why it does not validate the input parameters.\r\n *\r\n * @param {object} source\r\n * The source object to be prepared, if required.\r\n *\r\n * It must be a non-`null` object, which the method does not validate, as it is\r\n * intended primarily for internal use by the library.\r\n *\r\n * @returns {object}\r\n * When the object needs to be prepared, the method returns a clone of the source object,\r\n * with all properties and values set according to the columns configuration.\r\n *\r\n * When the object does not need to be prepared, the original object is returned.\r\n */\n\n\nColumnSet.prototype.prepare = function (source) {\n  if (this._inner.isSimple) {\n    return source; // a simple ColumnSet requires no object preparation;\n  }\n\n  const target = {};\n  this.columns.forEach(c => {\n    const a = colDesc(c, source);\n\n    if (c.init) {\n      target[a.name] = c.init.call(source, a);\n    } else {\n      if (a.exists || `def` in c) {\n        target[a.name] = a.value;\n      }\n    }\n  });\n  return target;\n};\n\nfunction colDesc(column, source) {\n  const a = {\n    source,\n    name: column.prop || column.name\n  };\n  a.exists = a.name in source;\n\n  if (a.exists) {\n    a.value = source[a.name];\n  } else {\n    a.value = `def` in column ? column.def : undefined;\n  }\n\n  return a;\n}\n/**\r\n * @method helpers.ColumnSet#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\n\n\nColumnSet.prototype.toString = function (level) {\n  level = level > 0 ? parseInt(level) : 0;\n  const gap0 = npm.utils.messageGap(level),\n        gap1 = npm.utils.messageGap(level + 1),\n        lines = [`ColumnSet {`];\n\n  if (this.table) {\n    lines.push(gap1 + `table: ` + this.table);\n  }\n\n  if (this.columns.length) {\n    lines.push(gap1 + `columns: [`);\n    this.columns.forEach(c => {\n      lines.push(c.toString(2));\n    });\n    lines.push(gap1 + `]`);\n  } else {\n    lines.push(gap1 + `columns: []`);\n  }\n\n  lines.push(gap0 + `}`);\n  return lines.join(npm.os.EOL);\n};\n\nnpm.utils.addInspection(ColumnSet, function () {\n  return this.toString();\n});\nmodule.exports = {\n  ColumnSet\n};","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg-promise/lib/helpers/column-set.js"],"names":["InnerState","require","assertOptions","TableName","Column","npm","os","utils","formatting","ColumnSet","constructor","columns","opt","TypeError","isNull","table","Array","isArray","colNames","map","c","col","name","Error","inherit","Object","prototype","hasOwnProperty","call","push","freeze","extendState","names","undefined","variables","updates","isSimple","i","length","prop","init","_inner","_i","escapedName","join","variable","castText","assign","options","hasPrefix","prefix","dynamic","hasSource","source","list","filter","cnd","skip","a","colDesc","as","alias","assignColumns","from","to","iterator","indexOf","cols","extend","cs","concat","merge","forEach","idx","prepare","target","exists","value","column","def","toString","level","parseInt","gap0","messageGap","gap1","lines","EOL","addInspection","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {InnerState} = require(`../inner-state`);\r\nconst {assertOptions} = require(`assert-options`);\r\nconst {TableName} = require(`./table-name`);\r\nconst {Column} = require(`./column`);\r\n\r\nconst npm = {\r\n    os: require(`os`),\r\n    utils: require(`../utils`),\r\n    formatting: require(`../formatting`)\r\n};\r\n\r\n/**\r\n * @class helpers.ColumnSet\r\n * @description\r\n * Performance-optimized, read-only structure with query-formatting columns.\r\n *\r\n * In order to avail from performance optimization provided by this class, it should be created\r\n * only once, statically, and then reused.\r\n *\r\n * @param {object|helpers.Column|array} columns\r\n * Columns information object, depending on the type:\r\n *\r\n * - When it is a simple object, its properties are enumerated to represent both column names and property names\r\n *   within the source objects. See also option `inherit` that's applicable in this case.\r\n *\r\n * - When it is a single {@link helpers.Column Column} object, property {@link helpers.ColumnSet#columns columns} is initialized with\r\n *   just a single column. It is not a unique situation when only a single column is required for an update operation.\r\n *\r\n * - When it is an array, each element is assumed to represent details for a column. If the element is already of type {@link helpers.Column Column},\r\n *   it is used directly; otherwise the element is passed into {@link helpers.Column Column} constructor for initialization.\r\n *   On any duplicate column name (case-sensitive) it will throw {@link external:Error Error} = `Duplicate column name \"name\".`\r\n *\r\n * - When it is none of the above, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'columns' specified.`\r\n *\r\n * @param {object} [options]\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [options.table]\r\n * Table details.\r\n *\r\n * When it is a non-null value, and not a {@link helpers.TableName TableName} object, a new {@link helpers.TableName TableName} is constructed from the value.\r\n *\r\n * It can be used as the default for methods {@link helpers.insert insert} and {@link helpers.update update} when their parameter\r\n * `table` is omitted, and for logging purposes.\r\n *\r\n * @param {boolean} [options.inherit = false]\r\n * Use inherited properties in addition to the object's own properties.\r\n *\r\n * By default, only the object's own properties are enumerated for column names.\r\n *\r\n * @returns {helpers.ColumnSet}\r\n *\r\n * @see\r\n *\r\n * {@link helpers.ColumnSet#columns columns},\r\n * {@link helpers.ColumnSet#names names},\r\n * {@link helpers.ColumnSet#table table},\r\n * {@link helpers.ColumnSet#variables variables} |\r\n * {@link helpers.ColumnSet#assign assign},\r\n * {@link helpers.ColumnSet#assignColumns assignColumns},\r\n * {@link helpers.ColumnSet#extend extend},\r\n * {@link helpers.ColumnSet#merge merge},\r\n * {@link helpers.ColumnSet#prepare prepare}\r\n *\r\n * @example\r\n *\r\n * // A complex insert/update object scenario for table 'purchases' in schema 'fiscal'.\r\n * // For a good performance, you should declare such objects once and then reuse them.\r\n * //\r\n * // Column Requirements:\r\n * //\r\n * // 1. Property 'id' is only to be used for a WHERE condition in updates\r\n * // 2. Property 'list' needs to be formatted as a csv\r\n * // 3. Property 'code' is to be used as raw text, and to be defaulted to 0 when the\r\n * //    property is missing in the source object\r\n * // 4. Property 'log' is a JSON object with 'log-entry' for the column name\r\n * // 5. Property 'data' requires SQL type casting '::int[]'\r\n * // 6. Property 'amount' needs to be set to 100, if it is 0\r\n * // 7. Property 'total' must be skipped during updates, if 'amount' was 0, plus its\r\n * //    column name is 'total-val'\r\n *\r\n * const cs = new pgp.helpers.ColumnSet([\r\n *     '?id', // ColumnConfig equivalent: {name: 'id', cnd: true}\r\n *     'list:csv', // ColumnConfig equivalent: {name: 'list', mod: ':csv'}\r\n *     {\r\n *         name: 'code',\r\n *         mod: '^', // format as raw text\r\n *         def: 0 // default to 0 when the property doesn't exist\r\n *     },\r\n *     {\r\n *         name: 'log-entry',\r\n *         prop: 'log',\r\n *         mod: ':json' // format as JSON\r\n *     },\r\n *     {\r\n *         name: 'data',\r\n *         cast: 'int[]' // use SQL type casting '::int[]'\r\n *     },\r\n *     {\r\n *         name: 'amount',\r\n *         init: col => {\r\n *             // set to 100, if the value is 0:\r\n *             return col.value === 0 ? 100 : col.value;\r\n *         }\r\n *     },\r\n *     {\r\n *         name: 'total-val',\r\n *         prop: 'total',\r\n *         skip: col => {\r\n *             // skip from updates, if 'amount' is 0:\r\n *             return col.source.amount === 0;\r\n *         }\r\n *     }\r\n * ], {table: {table: 'purchases', schema: 'fiscal'}});\r\n *\r\n * // Alternatively, you could take the table declaration out:\r\n * // const table = new pgp.helpers.TableName('purchases', 'fiscal');\r\n *\r\n * console.log(cs); // console output for the object:\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"fiscal\".\"purchases\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"id\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"list\"\r\n * //            mod: \":csv\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"code\"\r\n * //            mod: \"^\"\r\n * //            def: 0\r\n * //        }\r\n * //        Column {\r\n * //            name: \"log-entry\"\r\n * //            prop: \"log\"\r\n * //            mod: \":json\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"data\"\r\n * //            cast: \"int[]\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"amount\"\r\n * //            init: [Function]\r\n * //        }\r\n * //        Column {\r\n * //            name: \"total-val\"\r\n * //            prop: \"total\"\r\n * //            skip: [Function]\r\n * //        }\r\n * //    ]\r\n * // }\r\n */\r\nclass ColumnSet extends InnerState {\r\n\r\n    constructor(columns, opt) {\r\n        super();\r\n\r\n        if (!columns || typeof columns !== `object`) {\r\n            throw new TypeError(`Invalid parameter 'columns' specified.`);\r\n        }\r\n\r\n        opt = assertOptions(opt, [`table`, `inherit`]);\r\n\r\n        if (!npm.utils.isNull(opt.table)) {\r\n            this.table = (opt.table instanceof TableName) ? opt.table : new TableName(opt.table);\r\n        }\r\n\r\n        /**\r\n         * @name helpers.ColumnSet#table\r\n         * @type {helpers.TableName}\r\n         * @readonly\r\n         * @description\r\n         * Destination table. It can be specified for two purposes:\r\n         *\r\n         * - **primary:** to be used as the default table when it is omitted during a call into methods {@link helpers.insert insert} and {@link helpers.update update}\r\n         * - **secondary:** to be automatically written into the console (for logging purposes).\r\n         */\r\n\r\n\r\n        /**\r\n         * @name helpers.ColumnSet#columns\r\n         * @type helpers.Column[]\r\n         * @readonly\r\n         * @description\r\n         * Array of {@link helpers.Column Column} objects.\r\n         */\r\n        if (Array.isArray(columns)) {\r\n            const colNames = {};\r\n            this.columns = columns.map(c => {\r\n                const col = (c instanceof Column) ? c : new Column(c);\r\n                if (col.name in colNames) {\r\n                    throw new Error(`Duplicate column name \"${col.name}\".`);\r\n                }\r\n                colNames[col.name] = true;\r\n                return col;\r\n            });\r\n        } else {\r\n            if (columns instanceof Column) {\r\n                this.columns = [columns];\r\n            } else {\r\n                this.columns = [];\r\n                for (const name in columns) {\r\n                    if (opt.inherit || Object.prototype.hasOwnProperty.call(columns, name)) {\r\n                        this.columns.push(new Column(name));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        Object.freeze(this.columns);\r\n        Object.freeze(this);\r\n\r\n        this.extendState({\r\n            names: undefined,\r\n            variables: undefined,\r\n            updates: undefined,\r\n            isSimple: true\r\n        });\r\n\r\n        for (let i = 0; i < this.columns.length; i++) {\r\n            const c = this.columns[i];\r\n            // ColumnSet is simple when the source objects require no preparation,\r\n            // and should be used directly:\r\n            if (c.prop || c.init || `def` in c) {\r\n                this._inner.isSimple = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @name helpers.ColumnSet#names\r\n     * @type string\r\n     * @readonly\r\n     * @description\r\n     * Returns a string - comma-separated list of all column names, properly escaped.\r\n     *\r\n     * @example\r\n     * const cs = new ColumnSet(['id^', {name: 'cells', cast: 'int[]'}, 'doc:json']);\r\n     * console.log(cs.names);\r\n     * //=> \"id\",\"cells\",\"doc\"\r\n     */\r\n    get names() {\r\n        const _i = this._inner;\r\n        if (!_i.names) {\r\n            _i.names = this.columns.map(c => c.escapedName).join();\r\n        }\r\n        return _i.names;\r\n    }\r\n\r\n    /**\r\n     * @name helpers.ColumnSet#variables\r\n     * @type string\r\n     * @readonly\r\n     * @description\r\n     * Returns a string - formatting template for all column values.\r\n     *\r\n     * @see {@link helpers.ColumnSet#assign assign}\r\n     *\r\n     * @example\r\n     * const cs = new ColumnSet(['id^', {name: 'cells', cast: 'int[]'}, 'doc:json']);\r\n     * console.log(cs.variables);\r\n     * //=> ${id^},${cells}::int[],${doc:json}\r\n     */\r\n    get variables() {\r\n        const _i = this._inner;\r\n        if (!_i.variables) {\r\n            _i.variables = this.columns.map(c => c.variable + c.castText).join();\r\n        }\r\n        return _i.variables;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @method helpers.ColumnSet#assign\r\n * @description\r\n * Returns a formatting template of SET assignments, either generic or for a single object.\r\n *\r\n * The method is optimized to cache the output string when there are no columns that can be skipped dynamically.\r\n *\r\n * This method is primarily for internal use, that's why it does not validate the input.\r\n *\r\n * @param {object} [options]\r\n * Assignment/formatting options.\r\n *\r\n * @param {object} [options.source]\r\n * Source - a single object that contains values for columns.\r\n *\r\n * The object is only necessary to correctly apply the logic of skipping columns dynamically, based on the source data\r\n * and the rules defined in the {@link helpers.ColumnSet ColumnSet}. If, however, you do not care about that, then you do not need to specify any object.\r\n *\r\n * Note that even if you do not specify the object, the columns marked as conditional (`cnd: true`) will always be skipped.\r\n *\r\n * @param {string} [options.prefix]\r\n * In cases where needed, an alias prefix to be added before each column.\r\n *\r\n * @returns {string}\r\n * Comma-separated list of variable-to-column assignments.\r\n *\r\n * @see {@link helpers.ColumnSet#variables variables}\r\n *\r\n * @example\r\n *\r\n * const cs = new pgp.helpers.ColumnSet([\r\n *     '?first', // = {name: 'first', cnd: true}\r\n *     'second:json',\r\n *     {name: 'third', mod: ':raw', cast: 'text'}\r\n * ]);\r\n *\r\n * cs.assign();\r\n * //=> \"second\"=${second:json},\"third\"=${third:raw}::text\r\n *\r\n * cs.assign({prefix: 'a b c'});\r\n * //=> \"a b c\".\"second\"=${second:json},\"a b c\".\"third\"=${third:raw}::text\r\n */\r\nColumnSet.prototype.assign = function (options) {\r\n    const _i = this._inner;\r\n    const hasPrefix = options && options.prefix && typeof options.prefix === `string`;\r\n    if (_i.updates && !hasPrefix) {\r\n        return _i.updates;\r\n    }\r\n    let dynamic = hasPrefix;\r\n    const hasSource = options && options.source && typeof options.source === `object`;\r\n    let list = this.columns.filter(c => {\r\n        if (c.cnd) {\r\n            return false;\r\n        }\r\n        if (c.skip) {\r\n            dynamic = true;\r\n            if (hasSource) {\r\n                const a = colDesc(c, options.source);\r\n                if (c.skip.call(options.source, a)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    });\r\n\r\n    const prefix = hasPrefix ? npm.formatting.as.alias(options.prefix) + `.` : ``;\r\n    list = list.map(c => prefix + c.escapedName + `=` + c.variable + c.castText).join();\r\n\r\n    if (!dynamic) {\r\n        _i.updates = list;\r\n    }\r\n    return list;\r\n};\r\n\r\n/**\r\n * @method helpers.ColumnSet#assignColumns\r\n * @description\r\n * Generates assignments for all columns in the set, with support for aliases and column-skipping logic.\r\n * Aliases are set by using method {@link formatting.alias as.alias}.\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {string} [options.from]\r\n * Alias for the source columns.\r\n *\r\n * @param {string} [options.to]\r\n * Alias for the destination columns.\r\n *\r\n * @param {string | Array<string> | function} [options.skip]\r\n * Name(s) of the column(s) to be skipped (case-sensitive). It can be either a single string or an array of strings.\r\n *\r\n * It can also be a function - iterator, to be called for every column, passing in {@link helpers.Column Column} as\r\n * `this` context, and plus as a single parameter. The function would return a truthy value for every column that needs to be skipped.\r\n *\r\n * @returns {string}\r\n * A string of comma-separated column assignments.\r\n *\r\n * @example\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['id', 'city', 'street']);\r\n *\r\n * cs.assignColumns({from: 'EXCLUDED', skip: 'id'})\r\n * //=> \"city\"=EXCLUDED.\"city\",\"street\"=EXCLUDED.\"street\"\r\n *\r\n * @example\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', 'city', 'street']);\r\n *\r\n * cs.assignColumns({from: 'source', to: 'target', skip: c => c.cnd})\r\n * //=> target.\"city\"=source.\"city\",target.\"street\"=source.\"street\"\r\n *\r\n */\r\nColumnSet.prototype.assignColumns = function (options) {\r\n    options = assertOptions(options, [`from`, `to`, `skip`]);\r\n    const skip = (typeof options.skip === `string` && [options.skip]) || ((Array.isArray(options.skip) || typeof options.skip === `function`) && options.skip);\r\n    const from = (typeof options.from === `string` && options.from && (npm.formatting.as.alias(options.from) + `.`)) || ``;\r\n    const to = (typeof options.to === `string` && options.to && (npm.formatting.as.alias(options.to) + `.`)) || ``;\r\n    const iterator = typeof skip === `function` ? c => !skip.call(c, c) : c => skip.indexOf(c.name) === -1;\r\n    const cols = skip ? this.columns.filter(iterator) : this.columns;\r\n    return cols.map(c => to + c.escapedName + `=` + from + c.escapedName).join();\r\n};\r\n\r\n/**\r\n * @method helpers.ColumnSet#extend\r\n * @description\r\n * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.\r\n *\r\n * If the two sets contain a column with the same `name` (case-sensitive), an error is thrown.\r\n *\r\n * @param {helpers.Column|helpers.ColumnSet|array} columns\r\n * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:\r\n * - it can also be of type {@link helpers.ColumnSet ColumnSet}\r\n * - it cannot be a simple object (properties enumeration is not supported here)\r\n *\r\n * @returns {helpers.ColumnSet}\r\n * New {@link helpers.ColumnSet ColumnSet} object with the extended/concatenated list of columns.\r\n *\r\n * @see\r\n * {@link helpers.Column Column},\r\n * {@link helpers.ColumnSet#merge merge}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')();\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['one', 'two'], {table: 'my-table'});\r\n * console.log(cs);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n * const csExtended = cs.extend(['three']);\r\n * console.log(csExtended);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"three\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n */\r\nColumnSet.prototype.extend = function (columns) {\r\n    let cs = columns;\r\n    if (!(cs instanceof ColumnSet)) {\r\n        cs = new ColumnSet(columns);\r\n    }\r\n    // Any duplicate column will throw Error = 'Duplicate column name \"name\".',\r\n    return new ColumnSet(this.columns.concat(cs.columns), {table: this.table});\r\n};\r\n\r\n/**\r\n * @method helpers.ColumnSet#merge\r\n * @description\r\n * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.\r\n *\r\n * Items in `columns` with the same `name` (case-sensitive) override the original columns.\r\n *\r\n * @param {helpers.Column|helpers.ColumnSet|array} columns\r\n * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:\r\n * - it can also be of type {@link helpers.ColumnSet ColumnSet}\r\n * - it cannot be a simple object (properties enumeration is not supported here)\r\n *\r\n * @see\r\n * {@link helpers.Column Column},\r\n * {@link helpers.ColumnSet#extend extend}\r\n *\r\n * @returns {helpers.ColumnSet}\r\n * New {@link helpers.ColumnSet ColumnSet} object with the merged list of columns.\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')();\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?one', 'two:json'], {table: 'my-table'});\r\n * console.log(cs);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //            mod: \":json\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n * const csMerged = cs.merge(['two', 'three^']);\r\n * console.log(csMerged);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"three\"\r\n * //            mod: \"^\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n *\r\n */\r\nColumnSet.prototype.merge = function (columns) {\r\n    let cs = columns;\r\n    if (!(cs instanceof ColumnSet)) {\r\n        cs = new ColumnSet(columns);\r\n    }\r\n    const colNames = {}, cols = [];\r\n    this.columns.forEach((c, idx) => {\r\n        cols.push(c);\r\n        colNames[c.name] = idx;\r\n    });\r\n    cs.columns.forEach(c => {\r\n        if (c.name in colNames) {\r\n            cols[colNames[c.name]] = c;\r\n        } else {\r\n            cols.push(c);\r\n        }\r\n    });\r\n    return new ColumnSet(cols, {table: this.table});\r\n};\r\n\r\n/**\r\n * @method helpers.ColumnSet#prepare\r\n * @description\r\n * Prepares a source object to be formatted, by cloning it and applying the rules as set by the\r\n * columns configuration.\r\n *\r\n * This method is primarily for internal use, that's why it does not validate the input parameters.\r\n *\r\n * @param {object} source\r\n * The source object to be prepared, if required.\r\n *\r\n * It must be a non-`null` object, which the method does not validate, as it is\r\n * intended primarily for internal use by the library.\r\n *\r\n * @returns {object}\r\n * When the object needs to be prepared, the method returns a clone of the source object,\r\n * with all properties and values set according to the columns configuration.\r\n *\r\n * When the object does not need to be prepared, the original object is returned.\r\n */\r\nColumnSet.prototype.prepare = function (source) {\r\n    if (this._inner.isSimple) {\r\n        return source; // a simple ColumnSet requires no object preparation;\r\n    }\r\n    const target = {};\r\n    this.columns.forEach(c => {\r\n        const a = colDesc(c, source);\r\n        if (c.init) {\r\n            target[a.name] = c.init.call(source, a);\r\n        } else {\r\n            if (a.exists || `def` in c) {\r\n                target[a.name] = a.value;\r\n            }\r\n        }\r\n    });\r\n    return target;\r\n};\r\n\r\nfunction colDesc(column, source) {\r\n    const a = {\r\n        source,\r\n        name: column.prop || column.name\r\n    };\r\n    a.exists = a.name in source;\r\n    if (a.exists) {\r\n        a.value = source[a.name];\r\n    } else {\r\n        a.value = `def` in column ? column.def : undefined;\r\n    }\r\n    return a;\r\n}\r\n\r\n/**\r\n * @method helpers.ColumnSet#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nColumnSet.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    const gap0 = npm.utils.messageGap(level),\r\n        gap1 = npm.utils.messageGap(level + 1),\r\n        lines = [\r\n            `ColumnSet {`\r\n        ];\r\n    if (this.table) {\r\n        lines.push(gap1 + `table: ` + this.table);\r\n    }\r\n    if (this.columns.length) {\r\n        lines.push(gap1 + `columns: [`);\r\n        this.columns.forEach(c => {\r\n            lines.push(c.toString(2));\r\n        });\r\n        lines.push(gap1 + `]`);\r\n    } else {\r\n        lines.push(gap1 + `columns: []`);\r\n    }\r\n    lines.push(gap0 + `}`);\r\n    return lines.join(npm.os.EOL);\r\n};\r\n\r\nnpm.utils.addInspection(ColumnSet, function () {\r\n    return this.toString();\r\n});\r\n\r\nmodule.exports = {ColumnSet};\r\n"]},"metadata":{},"sourceType":"script"}