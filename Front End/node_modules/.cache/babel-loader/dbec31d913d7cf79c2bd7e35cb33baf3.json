{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\nconst {\n  assertOptions\n} = require(`assert-options`);\n\nconst {\n  TableName\n} = require(`../table-name`);\n\nconst {\n  ColumnSet\n} = require(`../column-set`);\n\nconst npm = {\n  formatting: require(`../../formatting`),\n  utils: require(`../../utils`)\n};\n/**\r\n * @method helpers.update\r\n * @description\r\n * Generates a simplified `UPDATE` query for either one object or an array of objects.\r\n *\r\n * The resulting query needs a `WHERE` clause to be appended to it, to specify the update logic.\r\n * This is to allow for update conditions of any complexity that are easy to add.\r\n *\r\n * @param {object|object[]} data\r\n * An update object with properties for update values, or an array of such objects.\r\n *\r\n * When `data` is not a non-null object and not an array, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`\r\n *\r\n * When `data` is an empty array, it will throw {@link external:TypeError TypeError} = `Cannot generate an UPDATE from an empty array.`\r\n *\r\n * When `data` is an array that contains a non-object value, the method will throw {@link external:Error Error} =\r\n * `Invalid update object at index N.`\r\n *\r\n * @param {array|helpers.Column|helpers.ColumnSet} [columns]\r\n * Set of columns to be updated.\r\n *\r\n * It is optional when `data` is a single object, and required when `data` is an array of objects. If not specified for an array\r\n * of objects, the method will throw {@link external:TypeError TypeError} = `Parameter 'columns' is required when updating multiple records.`\r\n *\r\n * When `columns` is not a {@link helpers.ColumnSet ColumnSet} object, a temporary {@link helpers.ColumnSet ColumnSet}\r\n * is created - from the value of `columns` (if it was specified), or from the value of `data` (if it is not an array).\r\n *\r\n * When the final {@link helpers.ColumnSet ColumnSet} is empty (no columns in it), the method will throw\r\n * {@link external:Error Error} = `Cannot generate an UPDATE without any columns.`, unless option `emptyUpdate` was specified.\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [table]\r\n * Table to be updated.\r\n *\r\n * It is normally a required parameter. But when `columns` is passed in as a {@link helpers.ColumnSet ColumnSet} object\r\n * with `table` set in it, that will be used when this parameter isn't specified. When neither is available, the method\r\n * will throw {@link external:Error Error} = `Table name is unknown.`\r\n *\r\n * @param {object} [options]\r\n * An object with formatting options for multi-row `UPDATE` queries.\r\n *\r\n * @param {string} [options.tableAlias=t]\r\n * Name of the SQL variable that represents the destination table.\r\n *\r\n * @param {string} [options.valueAlias=v]\r\n * Name of the SQL variable that represents the values.\r\n *\r\n * @param {*} [options.emptyUpdate]\r\n * This is a convenience option, to avoid throwing an error when generating a conditional update results in no columns.\r\n *\r\n * When present, regardless of the value, this option overrides the method's behaviour when applying `skip` logic results in no columns,\r\n * i.e. when every column is being skipped.\r\n *\r\n * By default, in that situation the method throws {@link external:Error Error} = `Cannot generate an UPDATE without any columns.`\r\n * But when this option is present, the method will instead return whatever value the option was passed.\r\n *\r\n * @returns {*}\r\n * An `UPDATE` query string that needs a `WHERE` condition appended.\r\n *\r\n * If it results in an empty update, and option `emptyUpdate` was passed in, then the method returns the value\r\n * to which the option was set.\r\n *\r\n * @see\r\n *  {@link helpers.Column Column},\r\n *  {@link helpers.ColumnSet ColumnSet},\r\n *  {@link helpers.TableName TableName}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')({\r\n *    capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * const dataSingle = {id: 1, val: 123, msg: 'hello'};\r\n * const dataMulti = [{id: 1, val: 123, msg: 'hello'}, {id: 2, val: 456, msg: 'world!'}];\r\n *\r\n * // Although column details can be taken from the data object, it is not\r\n * // a likely scenario for an update, unless updating the whole table:\r\n *\r\n * pgp.helpers.update(dataSingle, null, 'my-table');\r\n * //=> UPDATE \"my-table\" SET \"id\"=1,\"val\"=123,\"msg\"='hello'\r\n *\r\n * @example\r\n *\r\n * // A typical single-object update:\r\n *\r\n * // Dynamic conditions must be escaped/formatted properly:\r\n * const condition = pgp.as.format(' WHERE id = ${id}', dataSingle);\r\n *\r\n * pgp.helpers.update(dataSingle, ['val', 'msg'], 'my-table') + condition;\r\n * //=> UPDATE \"my-table\" SET \"val\"=123,\"msg\"='hello' WHERE id = 1\r\n *\r\n * @example\r\n *\r\n * // Column details are required for a multi-row `UPDATE`;\r\n * // Adding '?' in front of a column name means it is only for a WHERE condition:\r\n *\r\n * pgp.helpers.update(dataMulti, ['?id', 'val', 'msg'], 'my-table') + ' WHERE v.id = t.id';\r\n * //=> UPDATE \"my-table\" AS t SET \"val\"=v.\"val\",\"msg\"=v.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS v(\"id\",\"val\",\"msg\") WHERE v.id = t.id\r\n *\r\n * @example\r\n *\r\n * // Column details from a reusable ColumnSet (recommended for performance):\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', 'val', 'msg'], {table: 'my-table'});\r\n *\r\n * pgp.helpers.update(dataMulti, cs) + ' WHERE v.id = t.id';\r\n * //=> UPDATE \"my-table\" AS t SET \"val\"=v.\"val\",\"msg\"=v.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS v(\"id\",\"val\",\"msg\") WHERE v.id = t.id\r\n *\r\n * @example\r\n *\r\n * // Using parameter `options` to change the default alias names:\r\n *\r\n * pgp.helpers.update(dataMulti, cs, null, {tableAlias: 'X', valueAlias: 'Y'}) + ' WHERE Y.id = X.id';\r\n * //=> UPDATE \"my-table\" AS X SET \"val\"=Y.\"val\",\"msg\"=Y.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS Y(\"id\",\"val\",\"msg\") WHERE Y.id = X.id\r\n *\r\n * @example\r\n *\r\n * // Handling an empty update\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', '?name'], {table: 'tt'}); // no actual update-able columns\r\n * const result = pgp.helpers.update(dataMulti, cs, null, {emptyUpdate: 123});\r\n * if(result === 123) {\r\n *    // We know the update is empty, i.e. no columns that can be updated;\r\n *    // And it didn't throw because we specified `emptyUpdate` option.\r\n * }\r\n */\n\nfunction update(data, columns, table, options, capSQL) {\n  if (!data || typeof data !== `object`) {\n    throw new TypeError(`Invalid parameter 'data' specified.`);\n  }\n\n  const isArray = Array.isArray(data);\n\n  if (isArray && !data.length) {\n    throw new TypeError(`Cannot generate an UPDATE from an empty array.`);\n  }\n\n  if (columns instanceof ColumnSet) {\n    if (npm.utils.isNull(table)) {\n      table = columns.table;\n    }\n  } else {\n    if (isArray && npm.utils.isNull(columns)) {\n      throw new TypeError(`Parameter 'columns' is required when updating multiple records.`);\n    }\n\n    columns = new ColumnSet(columns || data);\n  }\n\n  options = assertOptions(options, [`tableAlias`, `valueAlias`, `emptyUpdate`]);\n  const format = npm.formatting.as.format,\n        useEmptyUpdate = (`emptyUpdate` in options),\n        fmOptions = {\n    capSQL\n  };\n\n  if (isArray) {\n    const tableAlias = npm.formatting.as.alias(npm.utils.isNull(options.tableAlias) ? `t` : options.tableAlias);\n    const valueAlias = npm.formatting.as.alias(npm.utils.isNull(options.valueAlias) ? `v` : options.valueAlias);\n    const q = capSQL ? sql.multi.capCase : sql.multi.lowCase;\n    const actualColumns = columns.columns.filter(c => !c.cnd);\n\n    if (checkColumns(actualColumns)) {\n      return options.emptyUpdate;\n    }\n\n    checkTable();\n    const targetCols = actualColumns.map(c => c.escapedName + `=` + valueAlias + `.` + c.escapedName).join();\n    const values = data.map((d, index) => {\n      if (!d || typeof d !== `object`) {\n        throw new Error(`Invalid update object at index ${index}.`);\n      }\n\n      return `(` + format(columns.variables, columns.prepare(d), fmOptions) + `)`;\n    }).join();\n    return format(q, [table.name, tableAlias, targetCols, values, valueAlias, columns.names], fmOptions);\n  }\n\n  const updates = columns.assign({\n    source: data\n  });\n\n  if (checkColumns(updates)) {\n    return options.emptyUpdate;\n  }\n\n  checkTable();\n  const query = capSQL ? sql.single.capCase : sql.single.lowCase;\n  return format(query, table.name) + format(updates, columns.prepare(data), fmOptions);\n\n  function checkTable() {\n    if (table && !(table instanceof TableName)) {\n      table = new TableName(table);\n    }\n\n    if (!table) {\n      throw new Error(`Table name is unknown.`);\n    }\n  }\n\n  function checkColumns(cols) {\n    if (!cols.length) {\n      if (useEmptyUpdate) {\n        return true;\n      }\n\n      throw new Error(`Cannot generate an UPDATE without any columns.`);\n    }\n  }\n}\n\nconst sql = {\n  single: {\n    lowCase: `update $1^ set `,\n    capCase: `UPDATE $1^ SET `\n  },\n  multi: {\n    lowCase: `update $1^ as $2^ set $3^ from (values$4^) as $5^($6^)`,\n    capCase: `UPDATE $1^ AS $2^ SET $3^ FROM (VALUES$4^) AS $5^($6^)`\n  }\n};\nmodule.exports = {\n  update\n};","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg-promise/lib/helpers/methods/update.js"],"names":["assertOptions","require","TableName","ColumnSet","npm","formatting","utils","update","data","columns","table","options","capSQL","TypeError","isArray","Array","length","isNull","format","as","useEmptyUpdate","fmOptions","tableAlias","alias","valueAlias","q","sql","multi","capCase","lowCase","actualColumns","filter","c","cnd","checkColumns","emptyUpdate","checkTable","targetCols","map","escapedName","join","values","d","index","Error","variables","prepare","name","names","updates","assign","source","query","single","cols","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {assertOptions} = require(`assert-options`);\r\nconst {TableName} = require(`../table-name`);\r\nconst {ColumnSet} = require(`../column-set`);\r\n\r\nconst npm = {\r\n    formatting: require(`../../formatting`),\r\n    utils: require(`../../utils`)\r\n};\r\n\r\n/**\r\n * @method helpers.update\r\n * @description\r\n * Generates a simplified `UPDATE` query for either one object or an array of objects.\r\n *\r\n * The resulting query needs a `WHERE` clause to be appended to it, to specify the update logic.\r\n * This is to allow for update conditions of any complexity that are easy to add.\r\n *\r\n * @param {object|object[]} data\r\n * An update object with properties for update values, or an array of such objects.\r\n *\r\n * When `data` is not a non-null object and not an array, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`\r\n *\r\n * When `data` is an empty array, it will throw {@link external:TypeError TypeError} = `Cannot generate an UPDATE from an empty array.`\r\n *\r\n * When `data` is an array that contains a non-object value, the method will throw {@link external:Error Error} =\r\n * `Invalid update object at index N.`\r\n *\r\n * @param {array|helpers.Column|helpers.ColumnSet} [columns]\r\n * Set of columns to be updated.\r\n *\r\n * It is optional when `data` is a single object, and required when `data` is an array of objects. If not specified for an array\r\n * of objects, the method will throw {@link external:TypeError TypeError} = `Parameter 'columns' is required when updating multiple records.`\r\n *\r\n * When `columns` is not a {@link helpers.ColumnSet ColumnSet} object, a temporary {@link helpers.ColumnSet ColumnSet}\r\n * is created - from the value of `columns` (if it was specified), or from the value of `data` (if it is not an array).\r\n *\r\n * When the final {@link helpers.ColumnSet ColumnSet} is empty (no columns in it), the method will throw\r\n * {@link external:Error Error} = `Cannot generate an UPDATE without any columns.`, unless option `emptyUpdate` was specified.\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [table]\r\n * Table to be updated.\r\n *\r\n * It is normally a required parameter. But when `columns` is passed in as a {@link helpers.ColumnSet ColumnSet} object\r\n * with `table` set in it, that will be used when this parameter isn't specified. When neither is available, the method\r\n * will throw {@link external:Error Error} = `Table name is unknown.`\r\n *\r\n * @param {object} [options]\r\n * An object with formatting options for multi-row `UPDATE` queries.\r\n *\r\n * @param {string} [options.tableAlias=t]\r\n * Name of the SQL variable that represents the destination table.\r\n *\r\n * @param {string} [options.valueAlias=v]\r\n * Name of the SQL variable that represents the values.\r\n *\r\n * @param {*} [options.emptyUpdate]\r\n * This is a convenience option, to avoid throwing an error when generating a conditional update results in no columns.\r\n *\r\n * When present, regardless of the value, this option overrides the method's behaviour when applying `skip` logic results in no columns,\r\n * i.e. when every column is being skipped.\r\n *\r\n * By default, in that situation the method throws {@link external:Error Error} = `Cannot generate an UPDATE without any columns.`\r\n * But when this option is present, the method will instead return whatever value the option was passed.\r\n *\r\n * @returns {*}\r\n * An `UPDATE` query string that needs a `WHERE` condition appended.\r\n *\r\n * If it results in an empty update, and option `emptyUpdate` was passed in, then the method returns the value\r\n * to which the option was set.\r\n *\r\n * @see\r\n *  {@link helpers.Column Column},\r\n *  {@link helpers.ColumnSet ColumnSet},\r\n *  {@link helpers.TableName TableName}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')({\r\n *    capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * const dataSingle = {id: 1, val: 123, msg: 'hello'};\r\n * const dataMulti = [{id: 1, val: 123, msg: 'hello'}, {id: 2, val: 456, msg: 'world!'}];\r\n *\r\n * // Although column details can be taken from the data object, it is not\r\n * // a likely scenario for an update, unless updating the whole table:\r\n *\r\n * pgp.helpers.update(dataSingle, null, 'my-table');\r\n * //=> UPDATE \"my-table\" SET \"id\"=1,\"val\"=123,\"msg\"='hello'\r\n *\r\n * @example\r\n *\r\n * // A typical single-object update:\r\n *\r\n * // Dynamic conditions must be escaped/formatted properly:\r\n * const condition = pgp.as.format(' WHERE id = ${id}', dataSingle);\r\n *\r\n * pgp.helpers.update(dataSingle, ['val', 'msg'], 'my-table') + condition;\r\n * //=> UPDATE \"my-table\" SET \"val\"=123,\"msg\"='hello' WHERE id = 1\r\n *\r\n * @example\r\n *\r\n * // Column details are required for a multi-row `UPDATE`;\r\n * // Adding '?' in front of a column name means it is only for a WHERE condition:\r\n *\r\n * pgp.helpers.update(dataMulti, ['?id', 'val', 'msg'], 'my-table') + ' WHERE v.id = t.id';\r\n * //=> UPDATE \"my-table\" AS t SET \"val\"=v.\"val\",\"msg\"=v.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS v(\"id\",\"val\",\"msg\") WHERE v.id = t.id\r\n *\r\n * @example\r\n *\r\n * // Column details from a reusable ColumnSet (recommended for performance):\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', 'val', 'msg'], {table: 'my-table'});\r\n *\r\n * pgp.helpers.update(dataMulti, cs) + ' WHERE v.id = t.id';\r\n * //=> UPDATE \"my-table\" AS t SET \"val\"=v.\"val\",\"msg\"=v.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS v(\"id\",\"val\",\"msg\") WHERE v.id = t.id\r\n *\r\n * @example\r\n *\r\n * // Using parameter `options` to change the default alias names:\r\n *\r\n * pgp.helpers.update(dataMulti, cs, null, {tableAlias: 'X', valueAlias: 'Y'}) + ' WHERE Y.id = X.id';\r\n * //=> UPDATE \"my-table\" AS X SET \"val\"=Y.\"val\",\"msg\"=Y.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS Y(\"id\",\"val\",\"msg\") WHERE Y.id = X.id\r\n *\r\n * @example\r\n *\r\n * // Handling an empty update\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', '?name'], {table: 'tt'}); // no actual update-able columns\r\n * const result = pgp.helpers.update(dataMulti, cs, null, {emptyUpdate: 123});\r\n * if(result === 123) {\r\n *    // We know the update is empty, i.e. no columns that can be updated;\r\n *    // And it didn't throw because we specified `emptyUpdate` option.\r\n * }\r\n */\r\nfunction update(data, columns, table, options, capSQL) {\r\n\r\n    if (!data || typeof data !== `object`) {\r\n        throw new TypeError(`Invalid parameter 'data' specified.`);\r\n    }\r\n\r\n    const isArray = Array.isArray(data);\r\n\r\n    if (isArray && !data.length) {\r\n        throw new TypeError(`Cannot generate an UPDATE from an empty array.`);\r\n    }\r\n\r\n    if (columns instanceof ColumnSet) {\r\n        if (npm.utils.isNull(table)) {\r\n            table = columns.table;\r\n        }\r\n    } else {\r\n        if (isArray && npm.utils.isNull(columns)) {\r\n            throw new TypeError(`Parameter 'columns' is required when updating multiple records.`);\r\n        }\r\n        columns = new ColumnSet(columns || data);\r\n    }\r\n\r\n    options = assertOptions(options, [`tableAlias`, `valueAlias`, `emptyUpdate`]);\r\n\r\n    const format = npm.formatting.as.format,\r\n        useEmptyUpdate = `emptyUpdate` in options,\r\n        fmOptions = {capSQL};\r\n\r\n    if (isArray) {\r\n        const tableAlias = npm.formatting.as.alias(npm.utils.isNull(options.tableAlias) ? `t` : options.tableAlias);\r\n        const valueAlias = npm.formatting.as.alias(npm.utils.isNull(options.valueAlias) ? `v` : options.valueAlias);\r\n\r\n        const q = capSQL ? sql.multi.capCase : sql.multi.lowCase;\r\n\r\n        const actualColumns = columns.columns.filter(c => !c.cnd);\r\n\r\n        if (checkColumns(actualColumns)) {\r\n            return options.emptyUpdate;\r\n        }\r\n\r\n        checkTable();\r\n\r\n        const targetCols = actualColumns.map(c => c.escapedName + `=` + valueAlias + `.` + c.escapedName).join();\r\n\r\n        const values = data.map((d, index) => {\r\n            if (!d || typeof d !== `object`) {\r\n                throw new Error(`Invalid update object at index ${index}.`);\r\n            }\r\n            return `(` + format(columns.variables, columns.prepare(d), fmOptions) + `)`;\r\n        }).join();\r\n\r\n        return format(q, [table.name, tableAlias, targetCols, values, valueAlias, columns.names], fmOptions);\r\n    }\r\n\r\n    const updates = columns.assign({source: data});\r\n\r\n    if (checkColumns(updates)) {\r\n        return options.emptyUpdate;\r\n    }\r\n\r\n    checkTable();\r\n\r\n    const query = capSQL ? sql.single.capCase : sql.single.lowCase;\r\n\r\n    return format(query, table.name) + format(updates, columns.prepare(data), fmOptions);\r\n\r\n    function checkTable() {\r\n        if (table && !(table instanceof TableName)) {\r\n            table = new TableName(table);\r\n        }\r\n        if (!table) {\r\n            throw new Error(`Table name is unknown.`);\r\n        }\r\n    }\r\n\r\n    function checkColumns(cols) {\r\n        if (!cols.length) {\r\n            if (useEmptyUpdate) {\r\n                return true;\r\n            }\r\n            throw new Error(`Cannot generate an UPDATE without any columns.`);\r\n        }\r\n    }\r\n}\r\n\r\nconst sql = {\r\n    single: {\r\n        lowCase: `update $1^ set `,\r\n        capCase: `UPDATE $1^ SET `\r\n    },\r\n    multi: {\r\n        lowCase: `update $1^ as $2^ set $3^ from (values$4^) as $5^($6^)`,\r\n        capCase: `UPDATE $1^ AS $2^ SET $3^ FROM (VALUES$4^) AS $5^($6^)`\r\n    }\r\n};\r\n\r\nmodule.exports = {update};\r\n"]},"metadata":{},"sourceType":"script"}