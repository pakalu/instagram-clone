{"ast":null,"code":"const {\n  PageError\n} = require('../errors/page');\n/**\r\n * @method page\r\n * @description\r\n * Resolves a dynamic sequence of pages/arrays with [mixed values]{@tutorial mixed}.\r\n *\r\n * The method acquires pages (arrays of [mixed values]{@tutorial mixed}) from the `source` function, one by one,\r\n * and resolves each page as a {@link batch}, till no more pages left or an error/reject occurs.\r\n *\r\n * @param {Function|generator} source\r\n * Expected to return a [mixed value]{@tutorial mixed} that resolves with the next page of data (array of [mixed values]{@tutorial mixed}).\r\n * Returning or resolving with `undefined` ends the sequence, and the method resolves.\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * Parameters:\r\n *  - `index` = index of the page being requested\r\n *  - `data` = previously returned page, resolved as a {@link batch} (`undefined` when `index=0`)\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * If the function throws an error or returns a rejected promise, the method rejects with\r\n * {@link errors.PageError PageError}, which will have property `source` set.\r\n *\r\n * And if the function returns or resolves with anything other than an array or `undefined`,\r\n * the method rejects with the same {@link errors.PageError PageError}, but with `error` set to\r\n * `Unexpected data returned from the source.`\r\n *\r\n * Passing in anything other than a function will reject with {@link external:TypeError TypeError} = `Parameter 'source' must be a function.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.dest]\r\n * Optional destination function (or generator), to receive a resolved {@link batch} of data\r\n * for each page, process it and respond as required.\r\n *\r\n * Parameters:\r\n *  - `index` = page index in the sequence\r\n *  - `data` = page data resolved as a {@link batch}\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise object, if notifications are handled asynchronously.\r\n * And if a promise is returned, the method will not request another page from the `source`\r\n * function until the promise has been resolved.\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.PageError PageError}, which will have property `dest` set.\r\n *\r\n * @param {Number} [options.limit=0]\r\n * Limits the maximum number of pages to be requested from the `source`. If the value is greater\r\n * than 0, the method will successfully resolve once the specified limit has been reached.\r\n *\r\n * When `limit` isn't specified (default), the sequence is unlimited, and it will continue\r\n * till one of the following occurs:\r\n *  - `source` returns or resolves with `undefined` or an invalid value (non-array)\r\n *  - either `source` or `dest` functions throw an error or return a rejected promise\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When successful, the method resolves with object `{pages, total, duration}`:\r\n *  - `pages` = number of pages resolved\r\n *  - `total` = the sum of all page sizes (total number of values resolved)\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When the method fails, it rejects with {@link errors.PageError PageError}.\r\n *\r\n */\n\n\nfunction page(source, options, config) {\n  const $p = config.promise,\n        spex = config.spex,\n        utils = config.utils;\n\n  if (typeof source !== 'function') {\n    return $p.reject(new TypeError('Parameter \\'source\\' must be a function.'));\n  }\n\n  options = options || {};\n  source = utils.wrap(source);\n  const limit = options.limit > 0 ? parseInt(options.limit) : 0,\n        dest = utils.wrap(options.dest),\n        self = this,\n        start = Date.now();\n  let request,\n      srcTime,\n      destTime,\n      total = 0;\n  return $p((resolve, reject) => {\n    function loop(idx) {\n      const srcNow = Date.now(),\n            srcDelay = idx ? srcNow - srcTime : undefined;\n      srcTime = srcNow;\n      utils.resolve.call(self, source, [idx, request, srcDelay], value => {\n        if (value === undefined) {\n          success();\n        } else {\n          if (value instanceof Array) {\n            spex.batch(value).then(data => {\n              request = data;\n              total += data.length;\n\n              if (dest) {\n                const destNow = Date.now(),\n                      destDelay = idx ? destNow - destTime : undefined;\n                let destResult;\n                destTime = destNow;\n\n                try {\n                  destResult = dest.call(self, idx, data, destDelay);\n                } catch (err) {\n                  fail({\n                    error: err,\n                    dest: data\n                  }, 4, dest.name);\n                  return;\n                }\n\n                if (utils.isPromise(destResult)) {\n                  destResult.then(next).catch(error => {\n                    fail({\n                      error: error,\n                      dest: data\n                    }, 3, dest.name);\n                  });\n                } else {\n                  next();\n                }\n              } else {\n                next();\n              }\n\n              return null; // this dummy return is just to prevent Bluebird warnings;\n            }).catch(error => {\n              fail({\n                error: error\n              }, 0);\n            });\n          } else {\n            fail({\n              error: new Error('Unexpected data returned from the source.'),\n              source: request\n            }, 5, source.name);\n          }\n        }\n      }, (reason, isRej) => {\n        fail({\n          error: reason,\n          source: request\n        }, isRej ? 1 : 2, source.name);\n      });\n\n      function next() {\n        if (limit === ++idx) {\n          success();\n        } else {\n          loop(idx);\n        }\n\n        return null; // this dummy return is just to prevent Bluebird warnings;\n      }\n\n      function success() {\n        resolve({\n          pages: idx,\n          total: total,\n          duration: Date.now() - start\n        });\n      }\n\n      function fail(reason, code, cbName) {\n        reason.index = idx;\n        reject(new PageError(reason, code, cbName, Date.now() - start));\n      }\n    }\n\n    loop(0);\n  });\n}\n\nmodule.exports = function (config) {\n  return function (source, options) {\n    return page.call(this, source, options, config);\n  };\n};","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/spex/lib/ext/page.js"],"names":["PageError","require","page","source","options","config","$p","promise","spex","utils","reject","TypeError","wrap","limit","parseInt","dest","self","start","Date","now","request","srcTime","destTime","total","resolve","loop","idx","srcNow","srcDelay","undefined","call","value","success","Array","batch","then","data","length","destNow","destDelay","destResult","err","fail","error","name","isPromise","next","catch","Error","reason","isRej","pages","duration","code","cbName","index","module","exports"],"mappings":"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","sourcesContent":["const {PageError} = require('../errors/page');\r\n\r\n/**\r\n * @method page\r\n * @description\r\n * Resolves a dynamic sequence of pages/arrays with [mixed values]{@tutorial mixed}.\r\n *\r\n * The method acquires pages (arrays of [mixed values]{@tutorial mixed}) from the `source` function, one by one,\r\n * and resolves each page as a {@link batch}, till no more pages left or an error/reject occurs.\r\n *\r\n * @param {Function|generator} source\r\n * Expected to return a [mixed value]{@tutorial mixed} that resolves with the next page of data (array of [mixed values]{@tutorial mixed}).\r\n * Returning or resolving with `undefined` ends the sequence, and the method resolves.\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * Parameters:\r\n *  - `index` = index of the page being requested\r\n *  - `data` = previously returned page, resolved as a {@link batch} (`undefined` when `index=0`)\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * If the function throws an error or returns a rejected promise, the method rejects with\r\n * {@link errors.PageError PageError}, which will have property `source` set.\r\n *\r\n * And if the function returns or resolves with anything other than an array or `undefined`,\r\n * the method rejects with the same {@link errors.PageError PageError}, but with `error` set to\r\n * `Unexpected data returned from the source.`\r\n *\r\n * Passing in anything other than a function will reject with {@link external:TypeError TypeError} = `Parameter 'source' must be a function.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.dest]\r\n * Optional destination function (or generator), to receive a resolved {@link batch} of data\r\n * for each page, process it and respond as required.\r\n *\r\n * Parameters:\r\n *  - `index` = page index in the sequence\r\n *  - `data` = page data resolved as a {@link batch}\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise object, if notifications are handled asynchronously.\r\n * And if a promise is returned, the method will not request another page from the `source`\r\n * function until the promise has been resolved.\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.PageError PageError}, which will have property `dest` set.\r\n *\r\n * @param {Number} [options.limit=0]\r\n * Limits the maximum number of pages to be requested from the `source`. If the value is greater\r\n * than 0, the method will successfully resolve once the specified limit has been reached.\r\n *\r\n * When `limit` isn't specified (default), the sequence is unlimited, and it will continue\r\n * till one of the following occurs:\r\n *  - `source` returns or resolves with `undefined` or an invalid value (non-array)\r\n *  - either `source` or `dest` functions throw an error or return a rejected promise\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When successful, the method resolves with object `{pages, total, duration}`:\r\n *  - `pages` = number of pages resolved\r\n *  - `total` = the sum of all page sizes (total number of values resolved)\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When the method fails, it rejects with {@link errors.PageError PageError}.\r\n *\r\n */\r\nfunction page(source, options, config) {\r\n\r\n    const $p = config.promise, spex = config.spex, utils = config.utils;\r\n\r\n    if (typeof source !== 'function') {\r\n        return $p.reject(new TypeError('Parameter \\'source\\' must be a function.'));\r\n    }\r\n\r\n    options = options || {};\r\n    source = utils.wrap(source);\r\n\r\n    const limit = (options.limit > 0) ? parseInt(options.limit) : 0,\r\n        dest = utils.wrap(options.dest), self = this, start = Date.now();\r\n    let request, srcTime, destTime, total = 0;\r\n\r\n    return $p((resolve, reject) => {\r\n\r\n        function loop(idx) {\r\n            const srcNow = Date.now(),\r\n                srcDelay = idx ? (srcNow - srcTime) : undefined;\r\n            srcTime = srcNow;\r\n            utils.resolve.call(self, source, [idx, request, srcDelay], value => {\r\n                if (value === undefined) {\r\n                    success();\r\n                } else {\r\n                    if (value instanceof Array) {\r\n                        spex.batch(value)\r\n                            .then(data => {\r\n                                request = data;\r\n                                total += data.length;\r\n                                if (dest) {\r\n                                    const destNow = Date.now(),\r\n                                        destDelay = idx ? (destNow - destTime) : undefined;\r\n                                    let destResult;\r\n                                    destTime = destNow;\r\n                                    try {\r\n                                        destResult = dest.call(self, idx, data, destDelay);\r\n                                    } catch (err) {\r\n                                        fail({\r\n                                            error: err,\r\n                                            dest: data\r\n                                        }, 4, dest.name);\r\n                                        return;\r\n                                    }\r\n                                    if (utils.isPromise(destResult)) {\r\n                                        destResult\r\n                                            .then(next)\r\n                                            .catch(error => {\r\n                                                fail({\r\n                                                    error: error,\r\n                                                    dest: data\r\n                                                }, 3, dest.name);\r\n                                            });\r\n                                    } else {\r\n                                        next();\r\n                                    }\r\n                                } else {\r\n                                    next();\r\n                                }\r\n                                return null; // this dummy return is just to prevent Bluebird warnings;\r\n                            })\r\n                            .catch(error => {\r\n                                fail({\r\n                                    error: error\r\n                                }, 0);\r\n                            });\r\n                    } else {\r\n                        fail({\r\n                            error: new Error('Unexpected data returned from the source.'),\r\n                            source: request\r\n                        }, 5, source.name);\r\n                    }\r\n                }\r\n            }, (reason, isRej) => {\r\n                fail({\r\n                    error: reason,\r\n                    source: request\r\n                }, isRej ? 1 : 2, source.name);\r\n            });\r\n\r\n            function next() {\r\n                if (limit === ++idx) {\r\n                    success();\r\n                } else {\r\n                    loop(idx);\r\n                }\r\n                return null; // this dummy return is just to prevent Bluebird warnings;\r\n            }\r\n\r\n            function success() {\r\n                resolve({\r\n                    pages: idx,\r\n                    total: total,\r\n                    duration: Date.now() - start\r\n                });\r\n            }\r\n\r\n            function fail(reason, code, cbName) {\r\n                reason.index = idx;\r\n                reject(new PageError(reason, code, cbName, Date.now() - start));\r\n            }\r\n        }\r\n\r\n        loop(0);\r\n    });\r\n}\r\n\r\nmodule.exports = function (config) {\r\n    return function (source, options) {\r\n        return page.call(this, source, options, config);\r\n    };\r\n};\r\n"]},"metadata":{},"sourceType":"script"}