{"ast":null,"code":"/**\r\n * @method stream.read\r\n * @description\r\n * Consumes and processes data from a $[Readable] stream.\r\n *\r\n * It reads the entire stream, using either **paused mode** (default), or in chunks (see `options.readChunks`)\r\n * with support for both synchronous and asynchronous data processing.\r\n *\r\n * **NOTE:** Once the method has finished, the onus is on the caller to release the stream\r\n * according to its protocol.\r\n *\r\n * @param {Object} stream\r\n * $[Readable] stream object.\r\n *\r\n * Passing in anything else will throw `Readable stream is required.`\r\n *\r\n * @param {Function|generator} receiver\r\n * Data processing callback (or generator).\r\n *\r\n * Passing in anything else will throw `Invalid stream receiver.`\r\n *\r\n * Parameters:\r\n *  - `index` = index of the call made to the function\r\n *  - `data` = array of all data reads from the stream's buffer\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function is called with the same `this` context as the calling method.\r\n *\r\n * It can optionally return a promise object, if data processing is asynchronous.\r\n * And if a promise is returned, the method will not read data from the stream again,\r\n * until the promise has been resolved.\r\n *\r\n * If the function throws an error or returns a rejected promise, the method rejects\r\n * with the same error / rejection reason.\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Boolean} [options.closable=false]\r\n * Instructs the method to resolve on event `close` supported by the stream, as opposed to event\r\n * `end` that's used by default.\r\n *\r\n * @param {Boolean} [options.readChunks=false]\r\n * By default, the method handles event `readable` of the stream to consume data in a simplified form,\r\n * item by item. If you enable this option, the method will instead handle event `data` of the stream,\r\n * to consume chunks of data.\r\n *\r\n * @param {Number} [options.readSize]\r\n * When the value is greater than 0, it sets the read size from the stream's buffer\r\n * when the next data is available. By default, the method uses as few reads as possible\r\n * to get all the data currently available in the buffer.\r\n *\r\n * NOTE: This option is ignored when option `readChunks` is enabled.\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When finished successfully, resolves with object `{calls, reads, length, duration}`:\r\n *  - `calls` = number of calls made into the `receiver`\r\n *  - `reads` = number of successful reads from the stream\r\n *  - `length` = total length for all the data reads from the stream\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When it fails, the method rejects with the error/reject specified,\r\n * which can happen as a result of:\r\n *  - event `error` emitted by the stream\r\n *  - receiver throws an error or returns a rejected promise\r\n */\nfunction read(stream, receiver, options, config) {\n  const $p = config.promise,\n        utils = config.utils;\n\n  if (!utils.isReadableStream(stream)) {\n    return $p.reject(new TypeError('Readable stream is required.'));\n  }\n\n  if (typeof receiver !== 'function') {\n    return $p.reject(new TypeError('Invalid stream receiver.'));\n  }\n\n  receiver = utils.wrap(receiver);\n  options = options || {};\n  const readSize = options.readSize > 0 ? parseInt(options.readSize) : null,\n        self = this,\n        start = Date.now(),\n        receiveEvent = options.readChunks ? 'data' : 'readable';\n  let cbTime,\n      ready,\n      waiting,\n      stop,\n      reads = 0,\n      length = 0,\n      index = 0;\n  return $p((resolve, reject) => {\n    function onReceive(data) {\n      ready = true;\n      process(data);\n    }\n\n    function onEnd() {\n      if (!options.closable) {\n        success();\n      }\n    }\n\n    function onClose() {\n      success();\n    }\n\n    function onError(error) {\n      fail(error);\n    }\n\n    stream.on(receiveEvent, onReceive);\n    stream.on('end', onEnd);\n    stream.on('close', onClose);\n    stream.on('error', onError);\n\n    function process(data) {\n      if (!ready || stop || waiting) {\n        return;\n      }\n\n      ready = false;\n      let cache;\n\n      if (options.readChunks) {\n        cache = data; // istanbul ignore else;\n        // we cannot test the else condition, as it requires a special broken stream interface.\n\n        if (!Array.isArray(cache)) {\n          cache = [cache];\n        }\n\n        length += cache.length;\n        reads++;\n      } else {\n        cache = [];\n        waiting = true;\n        let page;\n\n        do {\n          page = stream.read(readSize);\n\n          if (page) {\n            cache.push(page); // istanbul ignore next: requires a unique stream that\n            // creates objects without property `length` defined.\n\n            length += page.length || 0;\n            reads++;\n          }\n        } while (page);\n\n        if (!cache.length) {\n          waiting = false;\n          return;\n        }\n      }\n\n      const cbNow = Date.now(),\n            cbDelay = index ? cbNow - cbTime : undefined;\n      let result;\n      cbTime = cbNow;\n\n      try {\n        result = receiver.call(self, index++, cache, cbDelay);\n      } catch (e) {\n        fail(e);\n        return;\n      }\n\n      if (utils.isPromise(result)) {\n        result.then(() => {\n          waiting = false;\n          process();\n          return null; // this dummy return is just to prevent Bluebird warnings;\n        }).catch(error => {\n          fail(error);\n        });\n      } else {\n        waiting = false;\n        process();\n      }\n    }\n\n    function success() {\n      cleanup();\n      resolve({\n        calls: index,\n        reads: reads,\n        length: length,\n        duration: Date.now() - start\n      });\n    }\n\n    function fail(error) {\n      stop = true;\n      cleanup();\n      reject(error);\n    }\n\n    function cleanup() {\n      stream.removeListener(receiveEvent, onReceive);\n      stream.removeListener('close', onClose);\n      stream.removeListener('error', onError);\n      stream.removeListener('end', onEnd);\n    }\n  });\n}\n\nmodule.exports = function (config) {\n  return function (stream, receiver, options) {\n    return read.call(this, stream, receiver, options, config);\n  };\n};","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/spex/lib/ext/stream/read.js"],"names":["read","stream","receiver","options","config","$p","promise","utils","isReadableStream","reject","TypeError","wrap","readSize","parseInt","self","start","Date","now","receiveEvent","readChunks","cbTime","ready","waiting","stop","reads","length","index","resolve","onReceive","data","process","onEnd","closable","success","onClose","onError","error","fail","on","cache","Array","isArray","page","push","cbNow","cbDelay","undefined","result","call","e","isPromise","then","catch","cleanup","calls","duration","removeListener","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @method stream.read\r\n * @description\r\n * Consumes and processes data from a $[Readable] stream.\r\n *\r\n * It reads the entire stream, using either **paused mode** (default), or in chunks (see `options.readChunks`)\r\n * with support for both synchronous and asynchronous data processing.\r\n *\r\n * **NOTE:** Once the method has finished, the onus is on the caller to release the stream\r\n * according to its protocol.\r\n *\r\n * @param {Object} stream\r\n * $[Readable] stream object.\r\n *\r\n * Passing in anything else will throw `Readable stream is required.`\r\n *\r\n * @param {Function|generator} receiver\r\n * Data processing callback (or generator).\r\n *\r\n * Passing in anything else will throw `Invalid stream receiver.`\r\n *\r\n * Parameters:\r\n *  - `index` = index of the call made to the function\r\n *  - `data` = array of all data reads from the stream's buffer\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function is called with the same `this` context as the calling method.\r\n *\r\n * It can optionally return a promise object, if data processing is asynchronous.\r\n * And if a promise is returned, the method will not read data from the stream again,\r\n * until the promise has been resolved.\r\n *\r\n * If the function throws an error or returns a rejected promise, the method rejects\r\n * with the same error / rejection reason.\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Boolean} [options.closable=false]\r\n * Instructs the method to resolve on event `close` supported by the stream, as opposed to event\r\n * `end` that's used by default.\r\n *\r\n * @param {Boolean} [options.readChunks=false]\r\n * By default, the method handles event `readable` of the stream to consume data in a simplified form,\r\n * item by item. If you enable this option, the method will instead handle event `data` of the stream,\r\n * to consume chunks of data.\r\n *\r\n * @param {Number} [options.readSize]\r\n * When the value is greater than 0, it sets the read size from the stream's buffer\r\n * when the next data is available. By default, the method uses as few reads as possible\r\n * to get all the data currently available in the buffer.\r\n *\r\n * NOTE: This option is ignored when option `readChunks` is enabled.\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When finished successfully, resolves with object `{calls, reads, length, duration}`:\r\n *  - `calls` = number of calls made into the `receiver`\r\n *  - `reads` = number of successful reads from the stream\r\n *  - `length` = total length for all the data reads from the stream\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When it fails, the method rejects with the error/reject specified,\r\n * which can happen as a result of:\r\n *  - event `error` emitted by the stream\r\n *  - receiver throws an error or returns a rejected promise\r\n */\r\nfunction read(stream, receiver, options, config) {\r\n\r\n    const $p = config.promise, utils = config.utils;\r\n\r\n    if (!utils.isReadableStream(stream)) {\r\n        return $p.reject(new TypeError('Readable stream is required.'));\r\n    }\r\n\r\n    if (typeof receiver !== 'function') {\r\n        return $p.reject(new TypeError('Invalid stream receiver.'));\r\n    }\r\n\r\n    receiver = utils.wrap(receiver);\r\n\r\n    options = options || {};\r\n\r\n    const readSize = (options.readSize > 0) ? parseInt(options.readSize) : null,\r\n        self = this, start = Date.now(), receiveEvent = options.readChunks ? 'data' : 'readable';\r\n    let cbTime, ready, waiting, stop, reads = 0, length = 0, index = 0;\r\n\r\n    return $p((resolve, reject) => {\r\n\r\n        function onReceive(data) {\r\n            ready = true;\r\n            process(data);\r\n        }\r\n\r\n        function onEnd() {\r\n            if (!options.closable) {\r\n                success();\r\n            }\r\n        }\r\n\r\n        function onClose() {\r\n            success();\r\n        }\r\n\r\n        function onError(error) {\r\n            fail(error);\r\n        }\r\n\r\n        stream.on(receiveEvent, onReceive);\r\n        stream.on('end', onEnd);\r\n        stream.on('close', onClose);\r\n        stream.on('error', onError);\r\n\r\n        function process(data) {\r\n            if (!ready || stop || waiting) {\r\n                return;\r\n            }\r\n            ready = false;\r\n            let cache;\r\n            if (options.readChunks) {\r\n                cache = data;\r\n                // istanbul ignore else;\r\n                // we cannot test the else condition, as it requires a special broken stream interface.\r\n                if (!Array.isArray(cache)) {\r\n                    cache = [cache];\r\n                }\r\n                length += cache.length;\r\n                reads++;\r\n            } else {\r\n                cache = [];\r\n                waiting = true;\r\n                let page;\r\n                do {\r\n                    page = stream.read(readSize);\r\n                    if (page) {\r\n                        cache.push(page);\r\n                        // istanbul ignore next: requires a unique stream that\r\n                        // creates objects without property `length` defined.\r\n                        length += page.length || 0;\r\n                        reads++;\r\n                    }\r\n                } while (page);\r\n\r\n                if (!cache.length) {\r\n                    waiting = false;\r\n                    return;\r\n                }\r\n            }\r\n\r\n            const cbNow = Date.now(),\r\n                cbDelay = index ? (cbNow - cbTime) : undefined;\r\n            let result;\r\n            cbTime = cbNow;\r\n            try {\r\n                result = receiver.call(self, index++, cache, cbDelay);\r\n            } catch (e) {\r\n                fail(e);\r\n                return;\r\n            }\r\n\r\n            if (utils.isPromise(result)) {\r\n                result\r\n                    .then(() => {\r\n                        waiting = false;\r\n                        process();\r\n                        return null; // this dummy return is just to prevent Bluebird warnings;\r\n                    })\r\n                    .catch(error => {\r\n                        fail(error);\r\n                    });\r\n            } else {\r\n                waiting = false;\r\n                process();\r\n            }\r\n        }\r\n\r\n        function success() {\r\n            cleanup();\r\n            resolve({\r\n                calls: index,\r\n                reads: reads,\r\n                length: length,\r\n                duration: Date.now() - start\r\n            });\r\n        }\r\n\r\n        function fail(error) {\r\n            stop = true;\r\n            cleanup();\r\n            reject(error);\r\n        }\r\n\r\n        function cleanup() {\r\n            stream.removeListener(receiveEvent, onReceive);\r\n            stream.removeListener('close', onClose);\r\n            stream.removeListener('error', onError);\r\n            stream.removeListener('end', onEnd);\r\n        }\r\n    });\r\n}\r\n\r\nmodule.exports = function (config) {\r\n    return function (stream, receiver, options) {\r\n        return read.call(this, stream, receiver, options, config);\r\n    };\r\n};\r\n"]},"metadata":{},"sourceType":"script"}