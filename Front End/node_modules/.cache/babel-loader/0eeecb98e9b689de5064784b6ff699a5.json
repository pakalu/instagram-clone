{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\nconst {\n  ColorConsole\n} = require(`./utils/color`);\n\nconst npm = {\n  main: require(`./`),\n  utils: require(`./utils`)\n}; /////////////////////////////////\n// Client notification helpers;\n\nclass Events {\n  /**\r\n   * @event connect\r\n   * @description\r\n   * Global notification of acquiring a new database connection from the connection pool, i.e. a virtual connection.\r\n   *\r\n   * However, for direct calls to method {@link Database#connect Database.connect} with parameter `{direct: true}`,\r\n   * this event represents a physical connection.\r\n   *\r\n   * The library will suppress any error thrown by the handler and write it into the console.\r\n   *\r\n   * @param {external:Client} client\r\n   * $[pg.Client] object that represents the connection.\r\n   *\r\n   * @param {*} dc\r\n   * Database Context that was used when creating the database object (see {@link Database}).\r\n   *\r\n   * @param {number} useCount\r\n   * Number of times the connection has been previously used, starting with 0 for a freshly\r\n   * allocated physical connection.\r\n   *\r\n   * This parameter is always 0 for direct connections (created by calling {@link Database#connect Database.connect}\r\n   * with parameter `{direct: true}`).\r\n   *\r\n   * @example\r\n   *\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     connect(client, dc, useCount) {\r\n   *         const cp = client.connectionParameters;\r\n   *         console.log('Connected to database:', cp.database);\r\n   *     }\r\n   *\r\n   * };\r\n   */\n  static connect(ctx, client, useCount) {\n    if (typeof ctx.options.connect === `function`) {\n      try {\n        ctx.options.connect(client, ctx.dc, useCount);\n      } catch (e) {\n        // have to silence errors here;\n        // cannot allow unhandled errors while connecting to the database,\n        // as it will break the connection logic;\n        Events.unexpected(`connect`, e);\n      }\n    }\n  }\n  /**\r\n   * @event disconnect\r\n   * @description\r\n   * Global notification of releasing a database connection back to the connection pool, i.e. releasing the virtual connection.\r\n   *\r\n   * However, when releasing a direct connection (created by calling {@link Database#connect Database.connect} with parameter\r\n   * `{direct: true}`), this event represents a physical disconnection.\r\n   *\r\n   * The library will suppress any error thrown by the handler and write it into the console.\r\n   *\r\n   * @param {external:Client} client - $[pg.Client] object that represents connection with the database.\r\n   *\r\n   * @param {*} dc - Database Context that was used when creating the database object (see {@link Database}).\r\n   *\r\n   * @example\r\n   *\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     disconnect(client, dc) {\r\n   *        const cp = client.connectionParameters;\r\n   *        console.log('Disconnecting from database:', cp.database);\r\n   *     }\r\n   *\r\n   * };\r\n   */\n\n\n  static disconnect(ctx, client) {\n    if (typeof ctx.options.disconnect === `function`) {\n      try {\n        ctx.options.disconnect(client, ctx.dc);\n      } catch (e) {\n        // have to silence errors here;\n        // cannot allow unhandled errors while disconnecting from the database,\n        // as it will break the disconnection logic;\n        Events.unexpected(`disconnect`, e);\n      }\n    }\n  }\n  /**\r\n   * @event query\r\n   * @description\r\n   *\r\n   * Global notification of a query that's about to execute.\r\n   *\r\n   * Notification happens just before the query execution. And if the handler throws an error, the query execution\r\n   * will be rejected with that error.\r\n   *\r\n   * @param {EventContext} e\r\n   * Event Context Object.\r\n   *\r\n   * @example\r\n   *\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     query(e) {\r\n   *         console.log('QUERY:', e.query);\r\n   *     }\r\n   * };\r\n   */\n\n\n  static query(options, context) {\n    if (typeof options.query === `function`) {\n      try {\n        options.query(context);\n      } catch (e) {\n        // throwing an error during event 'query'\n        // will result in a reject for the request.\n        return e instanceof Error ? e : new npm.utils.InternalError(e);\n      }\n    }\n  }\n  /**\r\n   * @event receive\r\n   * @description\r\n   * Global notification of any data received from the database, coming from a regular query or from a stream.\r\n   *\r\n   * The event is fired before the data reaches the client, and it serves two purposes:\r\n   *  - Providing selective data logging for debugging;\r\n   *  - Pre-processing data before it reaches the client.\r\n   *\r\n   * **NOTES:**\r\n   * - If you alter the size of `data` directly or through the `result` object, it may affect `QueryResultMask`\r\n   *   validation for regular queries, which is executed right after.\r\n   * - Any data pre-processing needs to be fast here, to avoid performance penalties.\r\n   * - If the event handler throws an error, the original request will be rejected with that error.\r\n   *\r\n   * For methods {@link Database#multi Database.multi} and {@link Database#multiResult Database.multiResult},\r\n   * this event is called for every result that's returned. And for method {@link Database#stream Database.stream},\r\n   * the event occurs for every record.\r\n   *\r\n   * @param {Array<Object>} data\r\n   * Array of received objects/rows.\r\n   *\r\n   * If any of those objects are modified during notification, the client will receive the modified data.\r\n   *\r\n   * @param {external:Result} result\r\n   * - Original $[Result] object, if the data is from a non-stream query, in which case `data = result.rows`.\r\n   *   For single-query requests, $[Result] object is extended with property `duration` - number of milliseconds\r\n   *   it took to send the query, execute it and get the result back.\r\n   * - It is `undefined` when the data comes from a stream (method {@link Database#stream Database.stream}).\r\n   *\r\n   * @param {EventContext} e\r\n   * Event Context Object.\r\n   *\r\n   * @example\r\n   *\r\n   * // Example below shows the fastest way to camelize all column names.\r\n   * // NOTE: The example does not do processing for nested JSON objects.\r\n   *\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     receive(data, result, e) {\r\n   *         camelizeColumns(data);\r\n   *     }\r\n   * };\r\n   *\r\n   * function camelizeColumns(data) {\r\n   *     const tmp = data[0];\r\n   *     for (const prop in tmp) {\r\n   *         const camel = pgp.utils.camelize(prop);\r\n   *         if (!(camel in tmp)) {\r\n   *             for (let i = 0; i < data.length; i++) {\r\n   *                 const d = data[i];\r\n   *                 d[camel] = d[prop];\r\n   *                 delete d[prop];\r\n   *             }\r\n   *         }\r\n   *     }\r\n   * }\r\n   */\n\n\n  static receive(options, data, result, context) {\n    if (typeof options.receive === `function`) {\n      try {\n        options.receive(data, result, context);\n      } catch (e) {\n        // throwing an error during event 'receive'\n        // will result in a reject for the request.\n        return e instanceof Error ? e : new npm.utils.InternalError(e);\n      }\n    }\n  }\n  /**\r\n   * @event task\r\n   * @description\r\n   * Global notification of a task start / finish events, as executed via\r\n   * {@link Database#task Database.task} or {@link Database#taskIf Database.taskIf}.\r\n   *\r\n   * The library will suppress any error thrown by the handler and write it into the console.\r\n   *\r\n   * @param {EventContext} e\r\n   * Event Context Object.\r\n   *\r\n   * @example\r\n   *\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     task(e) {\r\n   *         if (e.ctx.finish) {\r\n   *             // this is a task->finish event;\r\n   *             console.log('Duration:', e.ctx.duration);\r\n   *             if (e.ctx.success) {\r\n   *                 // e.ctx.result = resolved data;\r\n   *             } else {\r\n   *                 // e.ctx.result = error/rejection reason;\r\n   *             }\r\n   *         } else {\r\n   *             // this is a task->start event;\r\n   *             console.log('Start Time:', e.ctx.start);\r\n   *         }\r\n   *     }\r\n   * };\r\n   *\r\n   */\n\n\n  static task(options, context) {\n    if (typeof options.task === `function`) {\n      try {\n        options.task(context);\n      } catch (e) {\n        // silencing the error, to avoid breaking the task;\n        Events.unexpected(`task`, e);\n      }\n    }\n  }\n  /**\r\n   * @event transact\r\n   * @description\r\n   * Global notification of a transaction start / finish events, as executed via {@link Database#tx Database.tx}\r\n   * or {@link Database#txIf Database.txIf}.\r\n   *\r\n   * The library will suppress any error thrown by the handler and write it into the console.\r\n   *\r\n   * @param {EventContext} e\r\n   * Event Context Object.\r\n   *\r\n   * @example\r\n   *\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     transact(e) {\r\n   *         if (e.ctx.finish) {\r\n   *             // this is a transaction->finish event;\r\n   *             console.log('Duration:', e.ctx.duration);\r\n   *             if (e.ctx.success) {\r\n   *                 // e.ctx.result = resolved data;\r\n   *             } else {\r\n   *                 // e.ctx.result = error/rejection reason;\r\n   *             }\r\n   *         } else {\r\n   *             // this is a transaction->start event;\r\n   *             console.log('Start Time:', e.ctx.start);\r\n   *         }\r\n   *     }\r\n   * };\r\n   *\r\n   */\n\n\n  static transact(options, context) {\n    if (typeof options.transact === `function`) {\n      try {\n        options.transact(context);\n      } catch (e) {\n        // silencing the error, to avoid breaking the transaction;\n        Events.unexpected(`transact`, e);\n      }\n    }\n  }\n  /**\r\n   * @event error\r\n   * @description\r\n   * Global notification of every error encountered by this library.\r\n   *\r\n   * The library will suppress any error thrown by the handler and write it into the console.\r\n   *\r\n   * @param {*} err\r\n   * The error encountered, of the same value and type as it was reported.\r\n   *\r\n   * @param {EventContext} e\r\n   * Event Context Object.\r\n   *\r\n   * @example\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     error(err, e) {\r\n   *\r\n   *         if (e.cn) {\r\n   *             // this is a connection-related error\r\n   *             // cn = safe connection details passed into the library:\r\n   *             //      if password is present, it is masked by #\r\n   *         }\r\n   *\r\n   *         if (e.query) {\r\n   *             // query string is available\r\n   *             if (e.params) {\r\n   *                 // query parameters are available\r\n   *             }\r\n   *         }\r\n   *\r\n   *         if (e.ctx) {\r\n   *             // occurred inside a task or transaction\r\n   *         }\r\n   *       }\r\n   * };\r\n   *\r\n   */\n\n\n  static error(options, err, context) {\n    if (typeof options.error === `function`) {\n      try {\n        options.error(err, context);\n      } catch (e) {\n        // have to silence errors here;\n        // throwing unhandled errors while handling an error\n        // notification is simply not acceptable.\n        Events.unexpected(`error`, e);\n      }\n    }\n  }\n  /**\r\n   * @event extend\r\n   * @description\r\n   * Extends {@link Database} protocol with custom methods and properties.\r\n   *\r\n   * Override this event to extend the existing access layer with your own functions and\r\n   * properties best suited for your application.\r\n   *\r\n   * The extension thus becomes available across all access layers:\r\n   *\r\n   * - Within the root/default database protocol;\r\n   * - Inside transactions, including nested ones;\r\n   * - Inside tasks, including nested ones.\r\n   *\r\n   * All pre-defined methods and properties are read-only, so you will get an error,\r\n   * if you try overriding them.\r\n   *\r\n   * The library will suppress any error thrown by the handler and write it into the console.\r\n   *\r\n   * @param {object} obj - Protocol object to be extended.\r\n   *\r\n   * @param {*} dc - Database Context that was used when creating the {@link Database} object.\r\n   *\r\n   * @see $[pg-promise-demo]\r\n   *\r\n   * @example\r\n   *\r\n   * // In the example below we extend the protocol with function `addImage`\r\n   * // that will insert one binary image and resolve with the new record id.\r\n   *\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     extend(obj, dc) {\r\n   *         // dc = database context;\r\n   *         obj.addImage = data => {\r\n   *             // adds a new image and resolves with its record id:\r\n   *             return obj.one('INSERT INTO images(data) VALUES($1) RETURNING id', data, a => a.id);\r\n   *         }\r\n   *     }\r\n   * };\r\n   *\r\n   * @example\r\n   *\r\n   * // It is best to extend the protocol by adding whole entity repositories to it as shown in the following example.\r\n   * // For a comprehensive example see https://github.com/vitaly-t/pg-promise-demo\r\n   *\r\n   * class UsersRepository {\r\n   *     constructor(rep, pgp) {\r\n   *         this.rep = rep;\r\n   *         this.pgp = pgp;\r\n   *     }\r\n   *\r\n   *     add(name) {\r\n   *         return this.rep.one('INSERT INTO users(name) VALUES($1) RETURNING id', name, a => a.id);\r\n   *     }\r\n   *\r\n   *     remove(id) {\r\n   *         return this.rep.none('DELETE FROM users WHERE id = $1', id);\r\n   *     }\r\n   * }\r\n   *\r\n   * // Overriding 'extend' event;\r\n   * const initOptions = {\r\n   *\r\n   *     // pg-promise initialization options...\r\n   *\r\n   *     extend(obj, dc) {\r\n   *         // dc = database context;\r\n   *         obj.users = new UsersRepository(obj, pgp);\r\n   *         // You can set different repositories based on `dc`\r\n   *     }\r\n   * };\r\n   *\r\n   * // Usage example:\r\n   * db.users.add('John', true)\r\n   *     .then(id => {\r\n   *         // user added successfully, id = new user's id\r\n   *     })\r\n   *     .catch(error => {\r\n   *         // failed to add the user;\r\n   *     });\r\n   *\r\n   */\n\n\n  static extend(options, obj, dc) {\n    if (typeof options.extend === `function`) {\n      try {\n        options.extend.call(obj, obj, dc);\n      } catch (e) {\n        // have to silence errors here;\n        // the result of throwing unhandled errors while\n        // extending the protocol would be unpredictable.\n        Events.unexpected(`extend`, e);\n      }\n    }\n  }\n  /**\r\n   * @event unexpected\r\n   * @param {string} event - unhandled event name.\r\n   * @param {string|Error} e - unhandled error.\r\n   * @private\r\n   */\n\n\n  static unexpected(event, e) {\n    // If you should ever get here, your app is definitely broken, and you need to fix\n    // your event handler to prevent unhandled errors during event notifications.\n    //\n    // Console output is suppressed when running tests, to avoid polluting test output\n    // with error messages that are intentional and of no value to the test.\n\n    /* istanbul ignore if */\n    if (!npm.main.suppressErrors) {\n      const stack = e instanceof Error ? e.stack : new Error().stack;\n      ColorConsole.error(`Unexpected error in '${event}' event handler.\\n${stack}\\n`);\n    }\n  }\n\n}\n\nmodule.exports = {\n  Events\n};\n/**\r\n * @typedef EventContext\r\n * @description\r\n * This common type is used for the following events: {@link event:query query}, {@link event:receive receive},\r\n * {@link event:error error}, {@link event:task task} and {@link event:transact transact}.\r\n *\r\n * @property {string|object} cn\r\n *\r\n * Set only for event {@link event:error error}, and only when the error is connection-related.\r\n *\r\n * It is a safe copy of the connection string/object that was used when initializing `db` - the database instance.\r\n *\r\n * If the original connection contains a password, the safe copy contains it masked with symbol `#`, so the connection\r\n * can be logged safely, without exposing the password.\r\n *\r\n * @property {*} dc\r\n * Database Context that was used when creating the database object (see {@link Database}). It is set for all events.\r\n *\r\n * @property {string|object} query\r\n *\r\n * Query string/object that was passed into the query method. This property is only set during events {@link event:query query},\r\n * {@link event:receive receive} and {@link event:error error} (only when the error is query-related).\r\n *\r\n * @property {external:Client} client\r\n *\r\n * $[pg.Client] object that represents the connection. It is set for all events, except for event {@link event:error error}\r\n * when it is connection-related. Note that sometimes the value may be unset when the connection is lost.\r\n *\r\n * @property {*} params - Formatting parameters for the query.\r\n *\r\n * It is set only for events {@link event:query query}, {@link event:receive receive} and {@link event:error error}, and only\r\n * when it is needed for logging. This library takes an extra step in figuring out when formatting parameters are of any value\r\n * to the event logging:\r\n * - when an error occurs related to the query formatting, event {@link event:error error} is sent with the property set.\r\n * - when initialization parameter `pgFormat` is used, and all query formatting is done within the $[PG] library, events\r\n * {@link event:query query} and {@link event:receive receive} will have this property set also, since this library no longer\r\n * handles the query formatting.\r\n *\r\n * When this parameter is not set, it means one of the two things:\r\n * - there were no parameters passed into the query method;\r\n * - property `query` of this object already contains all the formatting values in it, so logging only the query is sufficient.\r\n *\r\n * @property {TaskContext} ctx\r\n * _Task/Transaction Context_ object.\r\n *\r\n * This property is always set for events {@link event:task task} and {@link event:transact transact}, while for events\r\n * {@link event:query query}, {@link event:receive receive} and {@link event:error error} it is only set when they occur\r\n * inside a task or transaction.\r\n *\r\n */","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg-promise/lib/events.js"],"names":["ColorConsole","require","npm","main","utils","Events","connect","ctx","client","useCount","options","dc","e","unexpected","disconnect","query","context","Error","InternalError","receive","data","result","task","transact","error","err","extend","obj","call","event","suppressErrors","stack","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {ColorConsole} = require(`./utils/color`);\r\n\r\nconst npm = {\r\n    main: require(`./`),\r\n    utils: require(`./utils`)\r\n};\r\n\r\n/////////////////////////////////\r\n// Client notification helpers;\r\nclass Events {\r\n\r\n    /**\r\n     * @event connect\r\n     * @description\r\n     * Global notification of acquiring a new database connection from the connection pool, i.e. a virtual connection.\r\n     *\r\n     * However, for direct calls to method {@link Database#connect Database.connect} with parameter `{direct: true}`,\r\n     * this event represents a physical connection.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {external:Client} client\r\n     * $[pg.Client] object that represents the connection.\r\n     *\r\n     * @param {*} dc\r\n     * Database Context that was used when creating the database object (see {@link Database}).\r\n     *\r\n     * @param {number} useCount\r\n     * Number of times the connection has been previously used, starting with 0 for a freshly\r\n     * allocated physical connection.\r\n     *\r\n     * This parameter is always 0 for direct connections (created by calling {@link Database#connect Database.connect}\r\n     * with parameter `{direct: true}`).\r\n     *\r\n     * @example\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     connect(client, dc, useCount) {\r\n     *         const cp = client.connectionParameters;\r\n     *         console.log('Connected to database:', cp.database);\r\n     *     }\r\n     *\r\n     * };\r\n     */\r\n    static connect(ctx, client, useCount) {\r\n        if (typeof ctx.options.connect === `function`) {\r\n            try {\r\n                ctx.options.connect(client, ctx.dc, useCount);\r\n            } catch (e) {\r\n                // have to silence errors here;\r\n                // cannot allow unhandled errors while connecting to the database,\r\n                // as it will break the connection logic;\r\n                Events.unexpected(`connect`, e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event disconnect\r\n     * @description\r\n     * Global notification of releasing a database connection back to the connection pool, i.e. releasing the virtual connection.\r\n     *\r\n     * However, when releasing a direct connection (created by calling {@link Database#connect Database.connect} with parameter\r\n     * `{direct: true}`), this event represents a physical disconnection.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {external:Client} client - $[pg.Client] object that represents connection with the database.\r\n     *\r\n     * @param {*} dc - Database Context that was used when creating the database object (see {@link Database}).\r\n     *\r\n     * @example\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     disconnect(client, dc) {\r\n     *        const cp = client.connectionParameters;\r\n     *        console.log('Disconnecting from database:', cp.database);\r\n     *     }\r\n     *\r\n     * };\r\n     */\r\n    static disconnect(ctx, client) {\r\n        if (typeof ctx.options.disconnect === `function`) {\r\n            try {\r\n                ctx.options.disconnect(client, ctx.dc);\r\n            } catch (e) {\r\n                // have to silence errors here;\r\n                // cannot allow unhandled errors while disconnecting from the database,\r\n                // as it will break the disconnection logic;\r\n                Events.unexpected(`disconnect`, e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event query\r\n     * @description\r\n     *\r\n     * Global notification of a query that's about to execute.\r\n     *\r\n     * Notification happens just before the query execution. And if the handler throws an error, the query execution\r\n     * will be rejected with that error.\r\n     *\r\n     * @param {EventContext} e\r\n     * Event Context Object.\r\n     *\r\n     * @example\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     query(e) {\r\n     *         console.log('QUERY:', e.query);\r\n     *     }\r\n     * };\r\n     */\r\n    static query(options, context) {\r\n        if (typeof options.query === `function`) {\r\n            try {\r\n                options.query(context);\r\n            } catch (e) {\r\n                // throwing an error during event 'query'\r\n                // will result in a reject for the request.\r\n                return e instanceof Error ? e : new npm.utils.InternalError(e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event receive\r\n     * @description\r\n     * Global notification of any data received from the database, coming from a regular query or from a stream.\r\n     *\r\n     * The event is fired before the data reaches the client, and it serves two purposes:\r\n     *  - Providing selective data logging for debugging;\r\n     *  - Pre-processing data before it reaches the client.\r\n     *\r\n     * **NOTES:**\r\n     * - If you alter the size of `data` directly or through the `result` object, it may affect `QueryResultMask`\r\n     *   validation for regular queries, which is executed right after.\r\n     * - Any data pre-processing needs to be fast here, to avoid performance penalties.\r\n     * - If the event handler throws an error, the original request will be rejected with that error.\r\n     *\r\n     * For methods {@link Database#multi Database.multi} and {@link Database#multiResult Database.multiResult},\r\n     * this event is called for every result that's returned. And for method {@link Database#stream Database.stream},\r\n     * the event occurs for every record.\r\n     *\r\n     * @param {Array<Object>} data\r\n     * Array of received objects/rows.\r\n     *\r\n     * If any of those objects are modified during notification, the client will receive the modified data.\r\n     *\r\n     * @param {external:Result} result\r\n     * - Original $[Result] object, if the data is from a non-stream query, in which case `data = result.rows`.\r\n     *   For single-query requests, $[Result] object is extended with property `duration` - number of milliseconds\r\n     *   it took to send the query, execute it and get the result back.\r\n     * - It is `undefined` when the data comes from a stream (method {@link Database#stream Database.stream}).\r\n     *\r\n     * @param {EventContext} e\r\n     * Event Context Object.\r\n     *\r\n     * @example\r\n     *\r\n     * // Example below shows the fastest way to camelize all column names.\r\n     * // NOTE: The example does not do processing for nested JSON objects.\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     receive(data, result, e) {\r\n     *         camelizeColumns(data);\r\n     *     }\r\n     * };\r\n     *\r\n     * function camelizeColumns(data) {\r\n     *     const tmp = data[0];\r\n     *     for (const prop in tmp) {\r\n     *         const camel = pgp.utils.camelize(prop);\r\n     *         if (!(camel in tmp)) {\r\n     *             for (let i = 0; i < data.length; i++) {\r\n     *                 const d = data[i];\r\n     *                 d[camel] = d[prop];\r\n     *                 delete d[prop];\r\n     *             }\r\n     *         }\r\n     *     }\r\n     * }\r\n     */\r\n    static receive(options, data, result, context) {\r\n        if (typeof options.receive === `function`) {\r\n            try {\r\n                options.receive(data, result, context);\r\n            } catch (e) {\r\n                // throwing an error during event 'receive'\r\n                // will result in a reject for the request.\r\n                return e instanceof Error ? e : new npm.utils.InternalError(e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event task\r\n     * @description\r\n     * Global notification of a task start / finish events, as executed via\r\n     * {@link Database#task Database.task} or {@link Database#taskIf Database.taskIf}.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {EventContext} e\r\n     * Event Context Object.\r\n     *\r\n     * @example\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     task(e) {\r\n     *         if (e.ctx.finish) {\r\n     *             // this is a task->finish event;\r\n     *             console.log('Duration:', e.ctx.duration);\r\n     *             if (e.ctx.success) {\r\n     *                 // e.ctx.result = resolved data;\r\n     *             } else {\r\n     *                 // e.ctx.result = error/rejection reason;\r\n     *             }\r\n     *         } else {\r\n     *             // this is a task->start event;\r\n     *             console.log('Start Time:', e.ctx.start);\r\n     *         }\r\n     *     }\r\n     * };\r\n     *\r\n     */\r\n    static task(options, context) {\r\n        if (typeof options.task === `function`) {\r\n            try {\r\n                options.task(context);\r\n            } catch (e) {\r\n                // silencing the error, to avoid breaking the task;\r\n                Events.unexpected(`task`, e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event transact\r\n     * @description\r\n     * Global notification of a transaction start / finish events, as executed via {@link Database#tx Database.tx}\r\n     * or {@link Database#txIf Database.txIf}.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {EventContext} e\r\n     * Event Context Object.\r\n     *\r\n     * @example\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     transact(e) {\r\n     *         if (e.ctx.finish) {\r\n     *             // this is a transaction->finish event;\r\n     *             console.log('Duration:', e.ctx.duration);\r\n     *             if (e.ctx.success) {\r\n     *                 // e.ctx.result = resolved data;\r\n     *             } else {\r\n     *                 // e.ctx.result = error/rejection reason;\r\n     *             }\r\n     *         } else {\r\n     *             // this is a transaction->start event;\r\n     *             console.log('Start Time:', e.ctx.start);\r\n     *         }\r\n     *     }\r\n     * };\r\n     *\r\n     */\r\n    static transact(options, context) {\r\n        if (typeof options.transact === `function`) {\r\n            try {\r\n                options.transact(context);\r\n            } catch (e) {\r\n                // silencing the error, to avoid breaking the transaction;\r\n                Events.unexpected(`transact`, e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event error\r\n     * @description\r\n     * Global notification of every error encountered by this library.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {*} err\r\n     * The error encountered, of the same value and type as it was reported.\r\n     *\r\n     * @param {EventContext} e\r\n     * Event Context Object.\r\n     *\r\n     * @example\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     error(err, e) {\r\n     *\r\n     *         if (e.cn) {\r\n     *             // this is a connection-related error\r\n     *             // cn = safe connection details passed into the library:\r\n     *             //      if password is present, it is masked by #\r\n     *         }\r\n     *\r\n     *         if (e.query) {\r\n     *             // query string is available\r\n     *             if (e.params) {\r\n     *                 // query parameters are available\r\n     *             }\r\n     *         }\r\n     *\r\n     *         if (e.ctx) {\r\n     *             // occurred inside a task or transaction\r\n     *         }\r\n     *       }\r\n     * };\r\n     *\r\n     */\r\n    static error(options, err, context) {\r\n        if (typeof options.error === `function`) {\r\n            try {\r\n                options.error(err, context);\r\n            } catch (e) {\r\n                // have to silence errors here;\r\n                // throwing unhandled errors while handling an error\r\n                // notification is simply not acceptable.\r\n                Events.unexpected(`error`, e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event extend\r\n     * @description\r\n     * Extends {@link Database} protocol with custom methods and properties.\r\n     *\r\n     * Override this event to extend the existing access layer with your own functions and\r\n     * properties best suited for your application.\r\n     *\r\n     * The extension thus becomes available across all access layers:\r\n     *\r\n     * - Within the root/default database protocol;\r\n     * - Inside transactions, including nested ones;\r\n     * - Inside tasks, including nested ones.\r\n     *\r\n     * All pre-defined methods and properties are read-only, so you will get an error,\r\n     * if you try overriding them.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {object} obj - Protocol object to be extended.\r\n     *\r\n     * @param {*} dc - Database Context that was used when creating the {@link Database} object.\r\n     *\r\n     * @see $[pg-promise-demo]\r\n     *\r\n     * @example\r\n     *\r\n     * // In the example below we extend the protocol with function `addImage`\r\n     * // that will insert one binary image and resolve with the new record id.\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     extend(obj, dc) {\r\n     *         // dc = database context;\r\n     *         obj.addImage = data => {\r\n     *             // adds a new image and resolves with its record id:\r\n     *             return obj.one('INSERT INTO images(data) VALUES($1) RETURNING id', data, a => a.id);\r\n     *         }\r\n     *     }\r\n     * };\r\n     *\r\n     * @example\r\n     *\r\n     * // It is best to extend the protocol by adding whole entity repositories to it as shown in the following example.\r\n     * // For a comprehensive example see https://github.com/vitaly-t/pg-promise-demo\r\n     *\r\n     * class UsersRepository {\r\n     *     constructor(rep, pgp) {\r\n     *         this.rep = rep;\r\n     *         this.pgp = pgp;\r\n     *     }\r\n     *\r\n     *     add(name) {\r\n     *         return this.rep.one('INSERT INTO users(name) VALUES($1) RETURNING id', name, a => a.id);\r\n     *     }\r\n     *\r\n     *     remove(id) {\r\n     *         return this.rep.none('DELETE FROM users WHERE id = $1', id);\r\n     *     }\r\n     * }\r\n     *\r\n     * // Overriding 'extend' event;\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     extend(obj, dc) {\r\n     *         // dc = database context;\r\n     *         obj.users = new UsersRepository(obj, pgp);\r\n     *         // You can set different repositories based on `dc`\r\n     *     }\r\n     * };\r\n     *\r\n     * // Usage example:\r\n     * db.users.add('John', true)\r\n     *     .then(id => {\r\n     *         // user added successfully, id = new user's id\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // failed to add the user;\r\n     *     });\r\n     *\r\n     */\r\n    static extend(options, obj, dc) {\r\n        if (typeof options.extend === `function`) {\r\n            try {\r\n                options.extend.call(obj, obj, dc);\r\n            } catch (e) {\r\n                // have to silence errors here;\r\n                // the result of throwing unhandled errors while\r\n                // extending the protocol would be unpredictable.\r\n                Events.unexpected(`extend`, e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @event unexpected\r\n     * @param {string} event - unhandled event name.\r\n     * @param {string|Error} e - unhandled error.\r\n     * @private\r\n     */\r\n    static unexpected(event, e) {\r\n        // If you should ever get here, your app is definitely broken, and you need to fix\r\n        // your event handler to prevent unhandled errors during event notifications.\r\n        //\r\n        // Console output is suppressed when running tests, to avoid polluting test output\r\n        // with error messages that are intentional and of no value to the test.\r\n\r\n        /* istanbul ignore if */\r\n        if (!npm.main.suppressErrors) {\r\n            const stack = e instanceof Error ? e.stack : new Error().stack;\r\n            ColorConsole.error(`Unexpected error in '${event}' event handler.\\n${stack}\\n`);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = {Events};\r\n\r\n/**\r\n * @typedef EventContext\r\n * @description\r\n * This common type is used for the following events: {@link event:query query}, {@link event:receive receive},\r\n * {@link event:error error}, {@link event:task task} and {@link event:transact transact}.\r\n *\r\n * @property {string|object} cn\r\n *\r\n * Set only for event {@link event:error error}, and only when the error is connection-related.\r\n *\r\n * It is a safe copy of the connection string/object that was used when initializing `db` - the database instance.\r\n *\r\n * If the original connection contains a password, the safe copy contains it masked with symbol `#`, so the connection\r\n * can be logged safely, without exposing the password.\r\n *\r\n * @property {*} dc\r\n * Database Context that was used when creating the database object (see {@link Database}). It is set for all events.\r\n *\r\n * @property {string|object} query\r\n *\r\n * Query string/object that was passed into the query method. This property is only set during events {@link event:query query},\r\n * {@link event:receive receive} and {@link event:error error} (only when the error is query-related).\r\n *\r\n * @property {external:Client} client\r\n *\r\n * $[pg.Client] object that represents the connection. It is set for all events, except for event {@link event:error error}\r\n * when it is connection-related. Note that sometimes the value may be unset when the connection is lost.\r\n *\r\n * @property {*} params - Formatting parameters for the query.\r\n *\r\n * It is set only for events {@link event:query query}, {@link event:receive receive} and {@link event:error error}, and only\r\n * when it is needed for logging. This library takes an extra step in figuring out when formatting parameters are of any value\r\n * to the event logging:\r\n * - when an error occurs related to the query formatting, event {@link event:error error} is sent with the property set.\r\n * - when initialization parameter `pgFormat` is used, and all query formatting is done within the $[PG] library, events\r\n * {@link event:query query} and {@link event:receive receive} will have this property set also, since this library no longer\r\n * handles the query formatting.\r\n *\r\n * When this parameter is not set, it means one of the two things:\r\n * - there were no parameters passed into the query method;\r\n * - property `query` of this object already contains all the formatting values in it, so logging only the query is sufficient.\r\n *\r\n * @property {TaskContext} ctx\r\n * _Task/Transaction Context_ object.\r\n *\r\n * This property is always set for events {@link event:task task} and {@link event:transact transact}, while for events\r\n * {@link event:query query}, {@link event:receive receive} and {@link event:error error} it is only set when they occur\r\n * inside a task or transaction.\r\n *\r\n */\r\n"]},"metadata":{},"sourceType":"script"}