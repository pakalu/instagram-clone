{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\nconst {\n  Events\n} = require(`./events`);\n\nconst npm = {\n  spex: require(`spex`),\n  utils: require(`./utils`),\n  mode: require(`./tx-mode`),\n  query: require(`./query`),\n  text: require(`./text`)\n};\n/**\r\n * @interface Task\r\n * @description\r\n * Extends {@link Database} for an automatic connection session, with methods for executing multiple database queries.\r\n *\r\n * The type isn't available directly, it can only be created via methods {@link Database#task Database.task}, {@link Database#tx Database.tx},\r\n * or their derivations.\r\n *\r\n * When executing more than one request at a time, one should allocate and release the connection only once,\r\n * while executing all the required queries within the same connection session. More importantly, a transaction\r\n * can only work within a single connection.\r\n *\r\n * This is an interface for tasks/transactions to implement a connection session, during which you can\r\n * execute multiple queries against the same connection that's released automatically when the task/transaction is finished.\r\n *\r\n * Each task/transaction manages the connection automatically. When executed on the root {@link Database} object, the connection\r\n * is allocated from the pool, and once the method's callback has finished, the connection is released back to the pool.\r\n * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n *\r\n * @see\r\n * {@link Task#ctx ctx},\r\n * {@link Task#batch batch},\r\n * {@link Task#sequence sequence},\r\n * {@link Task#page page}\r\n *\r\n * @example\r\n * db.task(t => {\r\n *       // t = task protocol context;\r\n *       // t.ctx = Task Context;\r\n *       return t.one('select * from users where id=$1', 123)\r\n *           .then(user => {\r\n *               return t.any('select * from events where login=$1', user.name);\r\n *           });\r\n *   })\r\n * .then(events => {\r\n *       // success;\r\n *   })\r\n * .catch(error => {\r\n *       // error;\r\n *   });\r\n *\r\n */\n\nfunction Task(ctx, tag, isTX, config) {\n  const $p = config.promise;\n  /**\r\n   * @member {TaskContext} Task#ctx\r\n   * @readonly\r\n   * @description\r\n   * Task/Transaction Context object - contains individual properties for each task/transaction.\r\n   *\r\n   * @see event {@link event:query query}\r\n   *\r\n   * @example\r\n   *\r\n   * db.task(t => {\r\n   *     return t.ctx; // task context object\r\n   * })\r\n   *     .then(ctx => {\r\n   *         console.log('Task Duration:', ctx.duration);\r\n   *     });\r\n   *\r\n   * @example\r\n   *\r\n   * db.tx(t => {\r\n   *     return t.ctx; // transaction context object\r\n   * })\r\n   *     .then(ctx => {\r\n   *         console.log('Transaction Duration:', ctx.duration);\r\n   *     });\r\n   */\n\n  this.ctx = ctx.ctx = {}; // task context object;\n\n  npm.utils.addReadProp(this.ctx, `isTX`, isTX);\n\n  if (`context` in ctx) {\n    npm.utils.addReadProp(this.ctx, `context`, ctx.context);\n  }\n\n  npm.utils.addReadProp(this.ctx, `connected`, !ctx.db);\n  npm.utils.addReadProp(this.ctx, `tag`, tag);\n  npm.utils.addReadProp(this.ctx, `dc`, ctx.dc);\n  npm.utils.addReadProp(this.ctx, `level`, ctx.level);\n  npm.utils.addReadProp(this.ctx, `inTransaction`, ctx.inTransaction);\n\n  if (isTX) {\n    npm.utils.addReadProp(this.ctx, `txLevel`, ctx.txLevel);\n  }\n\n  npm.utils.addReadProp(this.ctx, `parent`, ctx.parentCtx); // generic query method;\n\n  this.query = function (query, values, qrm) {\n    if (!ctx.db) {\n      return $p.reject(new Error(npm.text.looseQuery));\n    }\n\n    return config.$npm.query.call(this, ctx, query, values, qrm);\n  };\n  /**\r\n   * @method Task#batch\r\n   * @description\r\n   * Settles a predefined array of mixed values by redirecting to method $[spex.batch].\r\n   *\r\n   * For complete method documentation see $[spex.batch].\r\n   *\r\n   * @param {array} values\r\n   * @param {Object} [options]\r\n   * Optional Parameters.\r\n   * @param {function} [options.cb]\r\n   *\r\n   * @returns {external:Promise}\r\n   */\n\n\n  this.batch = function (values, options) {\n    return config.$npm.spex.batch.call(this, values, options);\n  };\n  /**\r\n   * @method Task#page\r\n   * @description\r\n   * Resolves a dynamic sequence of arrays/pages with mixed values, by redirecting to method $[spex.page].\r\n   *\r\n   * For complete method documentation see $[spex.page].\r\n   *\r\n   * @param {function} source\r\n   * @param {Object} [options]\r\n   * Optional Parameters.\r\n   * @param {function} [options.dest]\r\n   * @param {number} [options.limit=0]\r\n   *\r\n   * @returns {external:Promise}\r\n   */\n\n\n  this.page = function (source, options) {\n    return config.$npm.spex.page.call(this, source, options);\n  };\n  /**\r\n   * @method Task#sequence\r\n   * @description\r\n   * Resolves a dynamic sequence of mixed values by redirecting to method $[spex.sequence].\r\n   *\r\n   * For complete method documentation see $[spex.sequence].\r\n   *\r\n   * @param {function} source\r\n   * @param {Object} [options]\r\n   * Optional Parameters.\r\n   * @param {function} [options.dest]\r\n   * @param {number} [options.limit=0]\r\n   * @param {boolean} [options.track=false]\r\n   *\r\n   * @returns {external:Promise}\r\n   */\n\n\n  this.sequence = function (source, options) {\n    return config.$npm.spex.sequence.call(this, source, options);\n  };\n}\n/**\r\n * @private\r\n * @method Task.callback\r\n * Callback invocation helper.\r\n *\r\n * @param ctx\r\n * @param obj\r\n * @param cb\r\n * @param config\r\n * @returns {Promise.<TResult>}\r\n */\n\n\nconst callback = (ctx, obj, cb, config) => {\n  const $p = config.promise;\n  let result;\n\n  try {\n    if (cb.constructor.name === `GeneratorFunction`) {\n      // v9.0 dropped all support for ES6 generator functions;\n      // Clients should use the new ES7 async/await syntax.\n      throw new TypeError(`ES6 generator functions are no longer supported!`);\n    }\n\n    result = cb.call(obj, obj); // invoking the callback function;\n  } catch (err) {\n    Events.error(ctx.options, err, {\n      client: ctx.db && ctx.db.client,\n      // the error can be due to loss of connectivity\n      dc: ctx.dc,\n      ctx: ctx.ctx\n    });\n    return $p.reject(err); // reject with the error;\n  }\n\n  if (result && typeof result.then === `function`) {\n    return result; // result is a valid promise object;\n  }\n\n  return $p.resolve(result);\n};\n/**\r\n * @private\r\n * @method Task.execute\r\n * Executes a task.\r\n *\r\n * @param ctx\r\n * @param obj\r\n * @param isTX\r\n * @param config\r\n * @returns {Promise.<TResult>}\r\n */\n\n\nconst execute = (ctx, obj, isTX, config) => {\n  const $p = config.promise; // updates the task context and notifies the client;\n\n  function update(start, success, result) {\n    const c = ctx.ctx;\n\n    if (start) {\n      npm.utils.addReadProp(c, `start`, new Date());\n    } else {\n      c.finish = new Date();\n      c.success = success;\n      c.result = result;\n      c.duration = c.finish - c.start;\n      npm.utils.lock(c, true);\n    }\n\n    (isTX ? Events.transact : Events.task)(ctx.options, {\n      client: ctx.db && ctx.db.client,\n      // loss of connectivity is possible at this point\n      dc: ctx.dc,\n      ctx: c\n    });\n  }\n\n  let cbData, cbReason, success, spName; // Save-Point Name;\n\n  const capSQL = ctx.options.capSQL; // capitalize sql;\n\n  update(true);\n\n  if (isTX) {\n    // executing a transaction;\n    spName = `level_` + ctx.txLevel;\n    return begin().then(() => callback(ctx, obj, ctx.cb, config).then(data => {\n      cbData = data; // save callback data;\n\n      success = true;\n      return commit();\n    }, err => {\n      cbReason = err; // save callback failure reason;\n\n      return rollback();\n    }).then(() => {\n      if (success) {\n        update(false, true, cbData);\n        return cbData;\n      }\n\n      update(false, false, cbReason);\n      return $p.reject(cbReason);\n    }, err => {\n      // either COMMIT or ROLLBACK has failed, which is impossible\n      // to replicate in a test environment, so skipping from the test;\n      // istanbul ignore next:\n      update(false, false, err); // istanbul ignore next:\n\n      return $p.reject(err);\n    }), err => {\n      // BEGIN has failed, which is impossible to replicate in a test\n      // environment, so skipping the whole block from the test;\n      // istanbul ignore next:\n      update(false, false, err); // istanbul ignore next:\n\n      return $p.reject(err);\n    });\n  }\n\n  function begin() {\n    if (!ctx.txLevel && ctx.mode instanceof npm.mode.TransactionMode) {\n      return exec(ctx.mode.begin(capSQL), `savepoint`);\n    }\n\n    return exec(`begin`, `savepoint`);\n  }\n\n  function commit() {\n    return exec(`commit`, `release savepoint`);\n  }\n\n  function rollback() {\n    return exec(`rollback`, `rollback to savepoint`);\n  }\n\n  function exec(top, nested) {\n    if (ctx.txLevel) {\n      return obj.none((capSQL ? nested.toUpperCase() : nested) + ` ` + spName);\n    }\n\n    return obj.none(capSQL ? top.toUpperCase() : top);\n  } // executing a task;\n\n\n  return callback(ctx, obj, ctx.cb, config).then(data => {\n    update(false, true, data);\n    return data;\n  }).catch(error => {\n    update(false, false, error);\n    return $p.reject(error);\n  });\n};\n\nmodule.exports = config => {\n  const npmLocal = config.$npm; // istanbul ignore next:\n  // we keep 'npm.query' initialization here, even though it is always\n  // pre-initialized by the 'database' module, for integrity purpose.\n\n  npmLocal.query = npmLocal.query || npm.query(config);\n  npmLocal.spex = npmLocal.spex || npm.spex(config.promiseLib);\n  return {\n    Task,\n    execute,\n    callback\n  };\n};\n/**\r\n * @typedef TaskContext\r\n * @description\r\n * Task/Transaction Context used via property {@link Task#ctx ctx} inside tasks (methods {@link Database#task Database.task} and {@link Database#taskIf Database.taskIf})\r\n * and transactions (methods {@link Database#tx Database.tx} and {@link Database#txIf Database.txIf}).\r\n *\r\n * Properties `context`, `connected`, `parent`, `level`, `dc`, `isTX`, `tag`, `start`, `useCount` and `serverVersion` are set just before the operation has started,\r\n * while properties `finish`, `duration`, `success` and `result` are set immediately after the operation has finished.\r\n *\r\n * @property {*} context\r\n * If the operation was invoked with a calling context - `task.call(context,...)` or `tx.call(context,...)`,\r\n * this property is set with the context that was passed in. Otherwise, the property doesn't exist.\r\n *\r\n * @property {*} dc\r\n * _Database Context_ that was passed into the {@link Database} object during construction.\r\n *\r\n * @property {boolean} isTX\r\n * Indicates whether this operation is a transaction (as opposed to a regular task).\r\n *\r\n * @property {number} duration\r\n * Number of milliseconds consumed by the operation.\r\n *\r\n * Set after the operation has finished, it is simply a shortcut for `finish - start`.\r\n *\r\n * @property {number} level\r\n * Task nesting level, starting from 0, counting both regular tasks and transactions.\r\n *\r\n * @property {number} txLevel\r\n * Transaction nesting level, starting from 0. Transactions on level 0 use `BEGIN/COMMIT/ROLLBACK`,\r\n * while transactions on nested levels use the corresponding `SAVEPOINT` commands.\r\n *\r\n * This property exists only within the context of a transaction (`isTX = true`).\r\n *\r\n * @property {boolean} inTransaction\r\n * Available in both tasks and transactions, it simplifies checking when there is a transaction\r\n * going on either on this level or above.\r\n *\r\n * For example, when you want to check for a containing transaction while inside a task, and\r\n * only start a transaction when there is none yet.\r\n *\r\n * @property {TaskContext} parent\r\n * Parent task/transaction context, or `null` when it is top-level.\r\n *\r\n * @property {boolean} connected\r\n * Indicates when the task/transaction acquired the connection on its own (`connected = true`), and will release it once\r\n * the operation has finished. When the value is `false`, the operation is reusing an existing connection.\r\n *\r\n * @property {*} tag\r\n * Tag value as it was passed into the task. See methods {@link Database#task task} and {@link Database#tx tx}.\r\n *\r\n * @property {Date} start\r\n * Date/Time of when this operation started the execution.\r\n *\r\n * @property {number} useCount\r\n * Number of times the connection has been previously used, starting with 0 for a freshly\r\n * allocated physical connection.\r\n *\r\n * @property {string} serverVersion\r\n * **(Added in v10.1.0)** - Version of the PostgreSQL server to which we are connected.\r\n * Not available with $[Native Bindings].\r\n *\r\n * @property {Date} finish\r\n * Once the operation has finished, this property is set to the Data/Time of when it happened.\r\n *\r\n * @property {boolean} success\r\n * Once the operation has finished, this property indicates whether it was successful.\r\n *\r\n * @property {*} result\r\n * Once the operation has finished, this property contains the result, depending on property `success`:\r\n * - data resolved by the operation, if `success = true`\r\n * - error / rejection reason, if `success = false`\r\n *\r\n */","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg-promise/lib/task.js"],"names":["Events","require","npm","spex","utils","mode","query","text","Task","ctx","tag","isTX","config","$p","promise","addReadProp","context","db","dc","level","inTransaction","txLevel","parentCtx","values","qrm","reject","Error","looseQuery","$npm","call","batch","options","page","source","sequence","callback","obj","cb","result","constructor","name","TypeError","err","error","client","then","resolve","execute","update","start","success","c","Date","finish","duration","lock","transact","task","cbData","cbReason","spName","capSQL","begin","data","commit","rollback","TransactionMode","exec","top","nested","none","toUpperCase","catch","module","exports","npmLocal","promiseLib"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {Events} = require(`./events`);\r\n\r\nconst npm = {\r\n    spex: require(`spex`),\r\n    utils: require(`./utils`),\r\n    mode: require(`./tx-mode`),\r\n    query: require(`./query`),\r\n    text: require(`./text`)\r\n};\r\n\r\n/**\r\n * @interface Task\r\n * @description\r\n * Extends {@link Database} for an automatic connection session, with methods for executing multiple database queries.\r\n *\r\n * The type isn't available directly, it can only be created via methods {@link Database#task Database.task}, {@link Database#tx Database.tx},\r\n * or their derivations.\r\n *\r\n * When executing more than one request at a time, one should allocate and release the connection only once,\r\n * while executing all the required queries within the same connection session. More importantly, a transaction\r\n * can only work within a single connection.\r\n *\r\n * This is an interface for tasks/transactions to implement a connection session, during which you can\r\n * execute multiple queries against the same connection that's released automatically when the task/transaction is finished.\r\n *\r\n * Each task/transaction manages the connection automatically. When executed on the root {@link Database} object, the connection\r\n * is allocated from the pool, and once the method's callback has finished, the connection is released back to the pool.\r\n * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n *\r\n * @see\r\n * {@link Task#ctx ctx},\r\n * {@link Task#batch batch},\r\n * {@link Task#sequence sequence},\r\n * {@link Task#page page}\r\n *\r\n * @example\r\n * db.task(t => {\r\n *       // t = task protocol context;\r\n *       // t.ctx = Task Context;\r\n *       return t.one('select * from users where id=$1', 123)\r\n *           .then(user => {\r\n *               return t.any('select * from events where login=$1', user.name);\r\n *           });\r\n *   })\r\n * .then(events => {\r\n *       // success;\r\n *   })\r\n * .catch(error => {\r\n *       // error;\r\n *   });\r\n *\r\n */\r\nfunction Task(ctx, tag, isTX, config) {\r\n\r\n    const $p = config.promise;\r\n\r\n    /**\r\n     * @member {TaskContext} Task#ctx\r\n     * @readonly\r\n     * @description\r\n     * Task/Transaction Context object - contains individual properties for each task/transaction.\r\n     *\r\n     * @see event {@link event:query query}\r\n     *\r\n     * @example\r\n     *\r\n     * db.task(t => {\r\n     *     return t.ctx; // task context object\r\n     * })\r\n     *     .then(ctx => {\r\n     *         console.log('Task Duration:', ctx.duration);\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * db.tx(t => {\r\n     *     return t.ctx; // transaction context object\r\n     * })\r\n     *     .then(ctx => {\r\n     *         console.log('Transaction Duration:', ctx.duration);\r\n     *     });\r\n     */\r\n    this.ctx = ctx.ctx = {}; // task context object;\r\n\r\n    npm.utils.addReadProp(this.ctx, `isTX`, isTX);\r\n\r\n    if (`context` in ctx) {\r\n        npm.utils.addReadProp(this.ctx, `context`, ctx.context);\r\n    }\r\n\r\n    npm.utils.addReadProp(this.ctx, `connected`, !ctx.db);\r\n    npm.utils.addReadProp(this.ctx, `tag`, tag);\r\n    npm.utils.addReadProp(this.ctx, `dc`, ctx.dc);\r\n    npm.utils.addReadProp(this.ctx, `level`, ctx.level);\r\n    npm.utils.addReadProp(this.ctx, `inTransaction`, ctx.inTransaction);\r\n\r\n    if (isTX) {\r\n        npm.utils.addReadProp(this.ctx, `txLevel`, ctx.txLevel);\r\n    }\r\n\r\n    npm.utils.addReadProp(this.ctx, `parent`, ctx.parentCtx);\r\n\r\n    // generic query method;\r\n    this.query = function (query, values, qrm) {\r\n        if (!ctx.db) {\r\n            return $p.reject(new Error(npm.text.looseQuery));\r\n        }\r\n        return config.$npm.query.call(this, ctx, query, values, qrm);\r\n    };\r\n\r\n    /**\r\n     * @method Task#batch\r\n     * @description\r\n     * Settles a predefined array of mixed values by redirecting to method $[spex.batch].\r\n     *\r\n     * For complete method documentation see $[spex.batch].\r\n     *\r\n     * @param {array} values\r\n     * @param {Object} [options]\r\n     * Optional Parameters.\r\n     * @param {function} [options.cb]\r\n     *\r\n     * @returns {external:Promise}\r\n     */\r\n    this.batch = function (values, options) {\r\n        return config.$npm.spex.batch.call(this, values, options);\r\n    };\r\n\r\n    /**\r\n     * @method Task#page\r\n     * @description\r\n     * Resolves a dynamic sequence of arrays/pages with mixed values, by redirecting to method $[spex.page].\r\n     *\r\n     * For complete method documentation see $[spex.page].\r\n     *\r\n     * @param {function} source\r\n     * @param {Object} [options]\r\n     * Optional Parameters.\r\n     * @param {function} [options.dest]\r\n     * @param {number} [options.limit=0]\r\n     *\r\n     * @returns {external:Promise}\r\n     */\r\n    this.page = function (source, options) {\r\n        return config.$npm.spex.page.call(this, source, options);\r\n    };\r\n\r\n    /**\r\n     * @method Task#sequence\r\n     * @description\r\n     * Resolves a dynamic sequence of mixed values by redirecting to method $[spex.sequence].\r\n     *\r\n     * For complete method documentation see $[spex.sequence].\r\n     *\r\n     * @param {function} source\r\n     * @param {Object} [options]\r\n     * Optional Parameters.\r\n     * @param {function} [options.dest]\r\n     * @param {number} [options.limit=0]\r\n     * @param {boolean} [options.track=false]\r\n     *\r\n     * @returns {external:Promise}\r\n     */\r\n    this.sequence = function (source, options) {\r\n        return config.$npm.spex.sequence.call(this, source, options);\r\n    };\r\n\r\n}\r\n\r\n/**\r\n * @private\r\n * @method Task.callback\r\n * Callback invocation helper.\r\n *\r\n * @param ctx\r\n * @param obj\r\n * @param cb\r\n * @param config\r\n * @returns {Promise.<TResult>}\r\n */\r\nconst callback = (ctx, obj, cb, config) => {\r\n\r\n    const $p = config.promise;\r\n    let result;\r\n\r\n    try {\r\n        if (cb.constructor.name === `GeneratorFunction`) {\r\n            // v9.0 dropped all support for ES6 generator functions;\r\n            // Clients should use the new ES7 async/await syntax.\r\n            throw new TypeError(`ES6 generator functions are no longer supported!`);\r\n        }\r\n        result = cb.call(obj, obj); // invoking the callback function;\r\n    } catch (err) {\r\n        Events.error(ctx.options, err, {\r\n            client: ctx.db && ctx.db.client, // the error can be due to loss of connectivity\r\n            dc: ctx.dc,\r\n            ctx: ctx.ctx\r\n        });\r\n        return $p.reject(err); // reject with the error;\r\n    }\r\n    if (result && typeof result.then === `function`) {\r\n        return result; // result is a valid promise object;\r\n    }\r\n    return $p.resolve(result);\r\n};\r\n\r\n/**\r\n * @private\r\n * @method Task.execute\r\n * Executes a task.\r\n *\r\n * @param ctx\r\n * @param obj\r\n * @param isTX\r\n * @param config\r\n * @returns {Promise.<TResult>}\r\n */\r\nconst execute = (ctx, obj, isTX, config) => {\r\n\r\n    const $p = config.promise;\r\n\r\n    // updates the task context and notifies the client;\r\n    function update(start, success, result) {\r\n        const c = ctx.ctx;\r\n        if (start) {\r\n            npm.utils.addReadProp(c, `start`, new Date());\r\n        } else {\r\n            c.finish = new Date();\r\n            c.success = success;\r\n            c.result = result;\r\n            c.duration = c.finish - c.start;\r\n            npm.utils.lock(c, true);\r\n        }\r\n        (isTX ? Events.transact : Events.task)(ctx.options, {\r\n            client: ctx.db && ctx.db.client, // loss of connectivity is possible at this point\r\n            dc: ctx.dc,\r\n            ctx: c\r\n        });\r\n    }\r\n\r\n    let cbData, cbReason, success,\r\n        spName; // Save-Point Name;\r\n\r\n    const capSQL = ctx.options.capSQL; // capitalize sql;\r\n\r\n    update(true);\r\n\r\n    if (isTX) {\r\n        // executing a transaction;\r\n        spName = `level_` + ctx.txLevel;\r\n        return begin()\r\n            .then(() => callback(ctx, obj, ctx.cb, config)\r\n                .then(data => {\r\n                    cbData = data; // save callback data;\r\n                    success = true;\r\n                    return commit();\r\n                }, err => {\r\n                    cbReason = err; // save callback failure reason;\r\n                    return rollback();\r\n                })\r\n                .then(() => {\r\n                    if (success) {\r\n                        update(false, true, cbData);\r\n                        return cbData;\r\n                    }\r\n                    update(false, false, cbReason);\r\n                    return $p.reject(cbReason);\r\n                },\r\n                err => {\r\n                    // either COMMIT or ROLLBACK has failed, which is impossible\r\n                    // to replicate in a test environment, so skipping from the test;\r\n                    // istanbul ignore next:\r\n                    update(false, false, err);\r\n                    // istanbul ignore next:\r\n                    return $p.reject(err);\r\n                }),\r\n            err => {\r\n                // BEGIN has failed, which is impossible to replicate in a test\r\n                // environment, so skipping the whole block from the test;\r\n                // istanbul ignore next:\r\n                update(false, false, err);\r\n                // istanbul ignore next:\r\n                return $p.reject(err);\r\n            });\r\n    }\r\n\r\n    function begin() {\r\n        if (!ctx.txLevel && ctx.mode instanceof npm.mode.TransactionMode) {\r\n            return exec(ctx.mode.begin(capSQL), `savepoint`);\r\n        }\r\n        return exec(`begin`, `savepoint`);\r\n    }\r\n\r\n    function commit() {\r\n        return exec(`commit`, `release savepoint`);\r\n    }\r\n\r\n    function rollback() {\r\n        return exec(`rollback`, `rollback to savepoint`);\r\n    }\r\n\r\n    function exec(top, nested) {\r\n        if (ctx.txLevel) {\r\n            return obj.none((capSQL ? nested.toUpperCase() : nested) + ` ` + spName);\r\n        }\r\n        return obj.none(capSQL ? top.toUpperCase() : top);\r\n    }\r\n\r\n    // executing a task;\r\n    return callback(ctx, obj, ctx.cb, config)\r\n        .then(data => {\r\n            update(false, true, data);\r\n            return data;\r\n        })\r\n        .catch(error => {\r\n            update(false, false, error);\r\n            return $p.reject(error);\r\n        });\r\n};\r\n\r\nmodule.exports = config => {\r\n    const npmLocal = config.$npm;\r\n\r\n    // istanbul ignore next:\r\n    // we keep 'npm.query' initialization here, even though it is always\r\n    // pre-initialized by the 'database' module, for integrity purpose.\r\n    npmLocal.query = npmLocal.query || npm.query(config);\r\n    npmLocal.spex = npmLocal.spex || npm.spex(config.promiseLib);\r\n\r\n    return {\r\n        Task, execute, callback\r\n    };\r\n};\r\n\r\n/**\r\n * @typedef TaskContext\r\n * @description\r\n * Task/Transaction Context used via property {@link Task#ctx ctx} inside tasks (methods {@link Database#task Database.task} and {@link Database#taskIf Database.taskIf})\r\n * and transactions (methods {@link Database#tx Database.tx} and {@link Database#txIf Database.txIf}).\r\n *\r\n * Properties `context`, `connected`, `parent`, `level`, `dc`, `isTX`, `tag`, `start`, `useCount` and `serverVersion` are set just before the operation has started,\r\n * while properties `finish`, `duration`, `success` and `result` are set immediately after the operation has finished.\r\n *\r\n * @property {*} context\r\n * If the operation was invoked with a calling context - `task.call(context,...)` or `tx.call(context,...)`,\r\n * this property is set with the context that was passed in. Otherwise, the property doesn't exist.\r\n *\r\n * @property {*} dc\r\n * _Database Context_ that was passed into the {@link Database} object during construction.\r\n *\r\n * @property {boolean} isTX\r\n * Indicates whether this operation is a transaction (as opposed to a regular task).\r\n *\r\n * @property {number} duration\r\n * Number of milliseconds consumed by the operation.\r\n *\r\n * Set after the operation has finished, it is simply a shortcut for `finish - start`.\r\n *\r\n * @property {number} level\r\n * Task nesting level, starting from 0, counting both regular tasks and transactions.\r\n *\r\n * @property {number} txLevel\r\n * Transaction nesting level, starting from 0. Transactions on level 0 use `BEGIN/COMMIT/ROLLBACK`,\r\n * while transactions on nested levels use the corresponding `SAVEPOINT` commands.\r\n *\r\n * This property exists only within the context of a transaction (`isTX = true`).\r\n *\r\n * @property {boolean} inTransaction\r\n * Available in both tasks and transactions, it simplifies checking when there is a transaction\r\n * going on either on this level or above.\r\n *\r\n * For example, when you want to check for a containing transaction while inside a task, and\r\n * only start a transaction when there is none yet.\r\n *\r\n * @property {TaskContext} parent\r\n * Parent task/transaction context, or `null` when it is top-level.\r\n *\r\n * @property {boolean} connected\r\n * Indicates when the task/transaction acquired the connection on its own (`connected = true`), and will release it once\r\n * the operation has finished. When the value is `false`, the operation is reusing an existing connection.\r\n *\r\n * @property {*} tag\r\n * Tag value as it was passed into the task. See methods {@link Database#task task} and {@link Database#tx tx}.\r\n *\r\n * @property {Date} start\r\n * Date/Time of when this operation started the execution.\r\n *\r\n * @property {number} useCount\r\n * Number of times the connection has been previously used, starting with 0 for a freshly\r\n * allocated physical connection.\r\n *\r\n * @property {string} serverVersion\r\n * **(Added in v10.1.0)** - Version of the PostgreSQL server to which we are connected.\r\n * Not available with $[Native Bindings].\r\n *\r\n * @property {Date} finish\r\n * Once the operation has finished, this property is set to the Data/Time of when it happened.\r\n *\r\n * @property {boolean} success\r\n * Once the operation has finished, this property indicates whether it was successful.\r\n *\r\n * @property {*} result\r\n * Once the operation has finished, this property contains the result, depending on property `success`:\r\n * - data resolved by the operation, if `success = true`\r\n * - error / rejection reason, if `success = false`\r\n *\r\n */\r\n"]},"metadata":{},"sourceType":"script"}