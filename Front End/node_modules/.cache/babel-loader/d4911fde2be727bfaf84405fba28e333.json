{"ast":null,"code":"const errorLib = require('./error');\n\nconst utils = require('./utils');\n\nconst PEC = errorLib.parsingErrorCode; // symbols that need no spaces around them:\n\nconst compressors = '.,;:()[]=<>+-*/|!?@#'; ////////////////////////////////////////////\n// Parses and minimizes a PostgreSQL script.\n\nfunction minify(sql, options) {\n  if (typeof sql !== 'string') {\n    throw new TypeError('Input SQL must be a text string.');\n  }\n\n  if (!sql.length) {\n    return '';\n  }\n\n  sql = sql.replace(/\\r\\n/g, '\\n');\n  options = options || {};\n  let idx = 0,\n      // current index\n  result = '',\n      // resulting sql\n  space = false; // add a space on the next step\n\n  const len = sql.length;\n\n  do {\n    const s = sql[idx],\n          // current symbol;\n    s1 = sql[idx + 1]; // next symbol;\n\n    if (isGap(s)) {\n      while (++idx < len && isGap(sql[idx]));\n\n      if (idx < len) {\n        space = true;\n      }\n\n      idx--;\n      continue;\n    }\n\n    if (s === '-' && s1 === '-') {\n      const lb = sql.indexOf('\\n', idx + 2);\n\n      if (lb < 0) {\n        break;\n      }\n\n      idx = lb - 1;\n      skipGaps();\n      continue;\n    }\n\n    if (s === '/' && s1 === '*') {\n      let c = idx + 1,\n          open = 0,\n          close = 0,\n          lastOpen,\n          lastClose;\n\n      while (++c < len - 1 && close <= open) {\n        if (sql[c] === '/' && sql[c + 1] === '*') {\n          lastOpen = c;\n          open++;\n          c++;\n        } else {\n          if (sql[c] === '*' && sql[c + 1] === '/') {\n            lastClose = c;\n            close++;\n            c++;\n          }\n        }\n      }\n\n      if (close <= open) {\n        idx = lastOpen;\n        throwError(PEC.unclosedMLC);\n      }\n\n      if (sql[idx + 2] === '!' && !options.removeAll) {\n        if (options.compress) {\n          space = false;\n        }\n\n        addSpace();\n        result += sql.substring(idx, lastClose + 2).replace(/\\n/g, '\\r\\n');\n      }\n\n      idx = lastClose + 1;\n      skipGaps();\n      continue;\n    }\n\n    let closeIdx, text;\n\n    if (s === '\"') {\n      closeIdx = sql.indexOf('\"', idx + 1);\n\n      if (closeIdx < 0) {\n        throwError(PEC.unclosedQI);\n      }\n\n      text = sql.substring(idx, closeIdx + 1);\n\n      if (text.indexOf('\\n') > 0) {\n        throwError(PEC.multiLineQI);\n      }\n\n      if (options.compress) {\n        space = false;\n      }\n\n      addSpace();\n      result += text;\n      idx = closeIdx;\n      skipGaps();\n      continue;\n    }\n\n    if (s === '\\'') {\n      closeIdx = idx;\n\n      do {\n        closeIdx = sql.indexOf('\\'', closeIdx + 1);\n\n        if (closeIdx > 0) {\n          let i = closeIdx;\n\n          while (sql[--i] === '\\\\');\n\n          if ((closeIdx - i) % 2) {\n            let step = closeIdx;\n\n            while (++step < len && sql[step] === '\\'');\n\n            if ((step - closeIdx) % 2) {\n              closeIdx = step - 1;\n              break;\n            }\n\n            closeIdx = step === len ? -1 : step;\n          }\n        }\n      } while (closeIdx > 0);\n\n      if (closeIdx < 0) {\n        throwError(PEC.unclosedText);\n      }\n\n      if (options.compress) {\n        space = false;\n      }\n\n      addSpace();\n      text = sql.substring(idx, closeIdx + 1);\n      const hasLB = text.indexOf('\\n') > 0;\n\n      if (hasLB) {\n        text = text.split('\\n').map(m => {\n          return m.replace(/^\\s+|\\s+$/g, '');\n        }).join('\\\\n');\n      }\n\n      const hasTabs = text.indexOf('\\t') > 0;\n\n      if (hasLB || hasTabs) {\n        const prev = idx ? sql[idx - 1] : '';\n\n        if (prev !== 'E' && prev !== 'e') {\n          const r = result ? result[result.length - 1] : '';\n\n          if (r && r !== ' ' && compressors.indexOf(r) < 0) {\n            result += ' ';\n          }\n\n          result += 'E';\n        }\n\n        if (hasTabs) {\n          text = text.replace(/\\t/g, '\\\\t');\n        }\n      }\n\n      result += text;\n      idx = closeIdx;\n      skipGaps();\n      continue;\n    }\n\n    if (options.compress && compressors.indexOf(s) >= 0) {\n      space = false;\n      skipGaps();\n    }\n\n    addSpace();\n    result += s;\n  } while (++idx < len);\n\n  return result;\n\n  function skipGaps() {\n    if (options.compress) {\n      while (idx < len - 1 && isGap(sql[idx + 1]) && idx++);\n    }\n  }\n\n  function addSpace() {\n    if (space) {\n      if (result.length) {\n        result += ' ';\n      }\n\n      space = false;\n    }\n  }\n\n  function throwError(code) {\n    const position = utils.getIndexPos(sql, idx);\n    throw new errorLib.SQLParsingError(code, position);\n  }\n} ////////////////////////////////////\n// Identifies a gap / empty symbol.\n\n\nfunction isGap(s) {\n  return s === ' ' || s === '\\t' || s === '\\r' || s === '\\n';\n}\n\nmodule.exports = minify;","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg-minify/lib/parser.js"],"names":["errorLib","require","utils","PEC","parsingErrorCode","compressors","minify","sql","options","TypeError","length","replace","idx","result","space","len","s","s1","isGap","lb","indexOf","skipGaps","c","open","close","lastOpen","lastClose","throwError","unclosedMLC","removeAll","compress","addSpace","substring","closeIdx","text","unclosedQI","multiLineQI","i","step","unclosedText","hasLB","split","map","m","join","hasTabs","prev","r","code","position","getIndexPos","SQLParsingError","module","exports"],"mappings":"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","sourcesContent":["const errorLib = require('./error');\r\nconst utils = require('./utils');\r\n\r\nconst PEC = errorLib.parsingErrorCode;\r\n\r\n// symbols that need no spaces around them:\r\nconst compressors = '.,;:()[]=<>+-*/|!?@#';\r\n\r\n////////////////////////////////////////////\r\n// Parses and minimizes a PostgreSQL script.\r\nfunction minify(sql, options) {\r\n\r\n    if (typeof sql !== 'string') {\r\n        throw new TypeError('Input SQL must be a text string.');\r\n    }\r\n\r\n    if (!sql.length) {\r\n        return '';\r\n    }\r\n\r\n    sql = sql.replace(/\\r\\n/g, '\\n');\r\n\r\n    options = options || {};\r\n\r\n    let idx = 0, // current index\r\n        result = '', // resulting sql\r\n        space = false; // add a space on the next step\r\n\r\n    const len = sql.length;\r\n\r\n    do {\r\n        const s = sql[idx], // current symbol;\r\n            s1 = sql[idx + 1]; // next symbol;\r\n\r\n        if (isGap(s)) {\r\n            while (++idx < len && isGap(sql[idx]));\r\n            if (idx < len) {\r\n                space = true;\r\n            }\r\n            idx--;\r\n            continue;\r\n        }\r\n\r\n        if (s === '-' && s1 === '-') {\r\n            const lb = sql.indexOf('\\n', idx + 2);\r\n            if (lb < 0) {\r\n                break;\r\n            }\r\n            idx = lb - 1;\r\n            skipGaps();\r\n            continue;\r\n        }\r\n\r\n        if (s === '/' && s1 === '*') {\r\n            let c = idx + 1, open = 0, close = 0, lastOpen, lastClose;\r\n            while (++c < len - 1 && close <= open) {\r\n                if (sql[c] === '/' && sql[c + 1] === '*') {\r\n                    lastOpen = c;\r\n                    open++;\r\n                    c++;\r\n                } else {\r\n                    if (sql[c] === '*' && sql[c + 1] === '/') {\r\n                        lastClose = c;\r\n                        close++;\r\n                        c++;\r\n                    }\r\n                }\r\n            }\r\n            if (close <= open) {\r\n                idx = lastOpen;\r\n                throwError(PEC.unclosedMLC);\r\n            }\r\n            if (sql[idx + 2] === '!' && !options.removeAll) {\r\n                if (options.compress) {\r\n                    space = false;\r\n                }\r\n                addSpace();\r\n                result += sql.substring(idx, lastClose + 2)\r\n                    .replace(/\\n/g, '\\r\\n');\r\n            }\r\n            idx = lastClose + 1;\r\n            skipGaps();\r\n            continue;\r\n        }\r\n\r\n        let closeIdx, text;\r\n\r\n        if (s === '\"') {\r\n            closeIdx = sql.indexOf('\"', idx + 1);\r\n            if (closeIdx < 0) {\r\n                throwError(PEC.unclosedQI);\r\n            }\r\n            text = sql.substring(idx, closeIdx + 1);\r\n            if (text.indexOf('\\n') > 0) {\r\n                throwError(PEC.multiLineQI);\r\n            }\r\n            if (options.compress) {\r\n                space = false;\r\n            }\r\n            addSpace();\r\n            result += text;\r\n            idx = closeIdx;\r\n            skipGaps();\r\n            continue;\r\n        }\r\n\r\n        if (s === '\\'') {\r\n            closeIdx = idx;\r\n            do {\r\n                closeIdx = sql.indexOf('\\'', closeIdx + 1);\r\n                if (closeIdx > 0) {\r\n                    let i = closeIdx;\r\n                    while (sql[--i] === '\\\\');\r\n                    if ((closeIdx - i) % 2) {\r\n                        let step = closeIdx;\r\n                        while (++step < len && sql[step] === '\\'');\r\n                        if ((step - closeIdx) % 2) {\r\n                            closeIdx = step - 1;\r\n                            break;\r\n                        }\r\n                        closeIdx = step === len ? -1 : step;\r\n                    }\r\n                }\r\n            } while (closeIdx > 0);\r\n            if (closeIdx < 0) {\r\n                throwError(PEC.unclosedText);\r\n            }\r\n            if (options.compress) {\r\n                space = false;\r\n            }\r\n            addSpace();\r\n            text = sql.substring(idx, closeIdx + 1);\r\n            const hasLB = text.indexOf('\\n') > 0;\r\n            if (hasLB) {\r\n                text = text.split('\\n').map(m => {\r\n                    return m.replace(/^\\s+|\\s+$/g, '');\r\n                }).join('\\\\n');\r\n            }\r\n            const hasTabs = text.indexOf('\\t') > 0;\r\n            if (hasLB || hasTabs) {\r\n                const prev = idx ? sql[idx - 1] : '';\r\n                if (prev !== 'E' && prev !== 'e') {\r\n                    const r = result ? result[result.length - 1] : '';\r\n                    if (r && r !== ' ' && compressors.indexOf(r) < 0) {\r\n                        result += ' ';\r\n                    }\r\n                    result += 'E';\r\n                }\r\n                if (hasTabs) {\r\n                    text = text.replace(/\\t/g, '\\\\t');\r\n                }\r\n            }\r\n            result += text;\r\n            idx = closeIdx;\r\n            skipGaps();\r\n            continue;\r\n        }\r\n\r\n        if (options.compress && compressors.indexOf(s) >= 0) {\r\n            space = false;\r\n            skipGaps();\r\n        }\r\n\r\n        addSpace();\r\n        result += s;\r\n\r\n    } while (++idx < len);\r\n\r\n    return result;\r\n\r\n    function skipGaps() {\r\n        if (options.compress) {\r\n            while (idx < len - 1 && isGap(sql[idx + 1]) && idx++);\r\n        }\r\n    }\r\n\r\n    function addSpace() {\r\n        if (space) {\r\n            if (result.length) {\r\n                result += ' ';\r\n            }\r\n            space = false;\r\n        }\r\n    }\r\n\r\n    function throwError(code) {\r\n        const position = utils.getIndexPos(sql, idx);\r\n        throw new errorLib.SQLParsingError(code, position);\r\n    }\r\n}\r\n\r\n////////////////////////////////////\r\n// Identifies a gap / empty symbol.\r\nfunction isGap(s) {\r\n    return s === ' ' || s === '\\t' || s === '\\r' || s === '\\n';\r\n}\r\n\r\nmodule.exports = minify;\r\n"]},"metadata":{},"sourceType":"script"}