{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\nconst {\n  assertOptions\n} = require(`assert-options`);\n\nconst npm = {\n  fs: require(`fs`),\n  path: require(`path`),\n  utils: require(`./`),\n  package: require(`../../package.json`)\n};\n/**\r\n * @method utils.camelize\r\n * @description\r\n * Camelizes a text string.\r\n *\r\n * Case-changing characters include:\r\n * - _hyphen_\r\n * - _underscore_\r\n * - _period_\r\n * - _space_\r\n *\r\n * @param {string} text\r\n * Input text string.\r\n *\r\n * @returns {string}\r\n * Camelized text string.\r\n *\r\n * @see\r\n * {@link utils.camelizeVar camelizeVar}\r\n *\r\n */\n\nfunction camelize(text) {\n  text = text.replace(/[-_\\s.]+(.)?/g, (match, chr) => {\n    return chr ? chr.toUpperCase() : ``;\n  });\n  return text.substr(0, 1).toLowerCase() + text.substr(1);\n}\n/**\r\n * @method utils.camelizeVar\r\n * @description\r\n * Camelizes a text string, while making it compliant with JavaScript variable names:\r\n * - contains symbols `a-z`, `A-Z`, `0-9`, `_` and `$`\r\n * - cannot have leading digits\r\n *\r\n * First, it removes all symbols that do not meet the above criteria, except for _hyphen_, _period_ and _space_,\r\n * and then it forwards into {@link utils.camelize camelize}.\r\n *\r\n * @param {string} text\r\n * Input text string.\r\n *\r\n * If it doesn't contain any symbols to make up a valid variable name, the result will be an empty string.\r\n *\r\n * @returns {string}\r\n * Camelized text string that can be used as an open property name.\r\n *\r\n * @see\r\n * {@link utils.camelize camelize}\r\n *\r\n */\n\n\nfunction camelizeVar(text) {\n  text = text.replace(/[^a-zA-Z0-9$_\\-\\s.]/g, ``).replace(/^[0-9_\\-\\s.]+/, ``);\n  return camelize(text);\n}\n\nfunction _enumSql(dir, options, cb, namePath) {\n  const tree = {};\n  npm.fs.readdirSync(dir).forEach(file => {\n    let stat;\n    const fullPath = npm.path.join(dir, file);\n\n    try {\n      stat = npm.fs.statSync(fullPath);\n    } catch (e) {\n      // while it is very easy to test manually, it is very difficult to test for\n      // access-denied errors automatically; therefore excluding from the coverage:\n      // istanbul ignore next\n      if (options.ignoreErrors) {\n        return; // on to the next file/folder;\n      } // istanbul ignore next\n\n\n      throw e;\n    }\n\n    if (stat.isDirectory()) {\n      if (options.recursive) {\n        const dirName = camelizeVar(file);\n        const np = namePath ? namePath + `.` + dirName : dirName;\n\n        const t = _enumSql(fullPath, options, cb, np);\n\n        if (Object.keys(t).length) {\n          if (!dirName.length || dirName in tree) {\n            if (!options.ignoreErrors) {\n              throw new Error(`Empty or duplicate camelized folder name: ` + fullPath);\n            }\n          }\n\n          tree[dirName] = t;\n        }\n      }\n    } else {\n      if (npm.path.extname(file).toLowerCase() === `.sql`) {\n        const name = camelizeVar(file.replace(/\\.[^/.]+$/, ``));\n\n        if (!name.length || name in tree) {\n          if (!options.ignoreErrors) {\n            throw new Error(`Empty or duplicate camelized file name: ` + fullPath);\n          }\n        }\n\n        tree[name] = fullPath;\n\n        if (cb) {\n          const result = cb(fullPath, name, namePath ? namePath + `.` + name : name);\n\n          if (result !== undefined) {\n            tree[name] = result;\n          }\n        }\n      }\n    }\n  });\n  return tree;\n}\n/**\r\n * @method utils.enumSql\r\n * @description\r\n * Synchronously enumerates all SQL files (within a given directory) into a camelized SQL tree.\r\n *\r\n * All property names within the tree are camelized via {@link utils.camelizeVar camelizeVar},\r\n * so they can be used in the code directly, as open property names.\r\n *\r\n * @param {string} dir\r\n * Directory path where SQL files are located, either absolute or relative to the current directory.\r\n *\r\n * SQL files are identified by using `.sql` extension (case-insensitive).\r\n *\r\n * @param {object} [options]\r\n * Search options.\r\n *\r\n * @param {boolean} [options.recursive=false]\r\n * Include sub-directories into the search.\r\n *\r\n * Sub-directories without SQL files will be skipped from the result.\r\n *\r\n * @param {boolean} [options.ignoreErrors=false]\r\n * Ignore the following types of errors:\r\n * - access errors, when there is no read access to a file or folder\r\n * - empty or duplicate camelized property names\r\n *\r\n * This flag does not affect errors related to invalid input parameters, or if you pass in a\r\n * non-existing directory.\r\n *\r\n * @param {function} [cb]\r\n * A callback function that takes three arguments:\r\n * - `file` - SQL file path, relative or absolute, according to how you specified the search directory\r\n * - `name` - name of the property that represents the SQL file\r\n * - `path` - property resolution path (full property name)\r\n *\r\n * If the function returns anything other than `undefined`, it overrides the corresponding property value in the tree.\r\n *\r\n * @returns {object}\r\n * Camelized SQL tree object, with each value being an SQL file path (unless changed via the callback).\r\n *\r\n * @example\r\n *\r\n * // simple SQL tree generation for further processing:\r\n * const tree = pgp.utils.enumSql('../sql', {recursive: true});\r\n *\r\n * @example\r\n *\r\n * // generating an SQL tree for dynamic use of names:\r\n * const sql = pgp.utils.enumSql(__dirname, {recursive: true}, file => {\r\n *     return new pgp.QueryFile(file, {minify: true});\r\n * });\r\n *\r\n * @example\r\n *\r\n * const path = require('path');\r\n *\r\n * // replacing each relative path in the tree with a full one:\r\n * const tree = pgp.utils.enumSql('../sql', {recursive: true}, file => {\r\n *     return path.join(__dirname, file);\r\n * });\r\n *\r\n */\n\n\nfunction enumSql(dir, options, cb) {\n  if (!npm.utils.isText(dir)) {\n    throw new TypeError(`Parameter 'dir' must be a non-empty text string.`);\n  }\n\n  options = assertOptions(options, [`recursive`, `ignoreErrors`]);\n  cb = typeof cb === `function` ? cb : null;\n  return _enumSql(dir, options, cb, ``);\n}\n/**\r\n * @method utils.taskArgs\r\n * @description\r\n * Normalizes/prepares arguments for tasks and transactions.\r\n *\r\n * Its main purpose is to simplify adding custom methods {@link Database#task task}, {@link Database#taskIf taskIf},\r\n * {@link Database#tx tx} and {@link Database#txIf txIf} within event {@link event:extend extend}, as the those methods use fairly\r\n * complex logic for parsing inputs.\r\n *\r\n * @param args {Object}\r\n * Array-like object of `arguments` that was passed into the method. It is expected that the `arguments`\r\n * are always made of two parameters - `(options, cb)`, same as all the default task/transaction methods.\r\n *\r\n * And if your custom method needs additional parameters, they should be passed in as extra properties within `options`.\r\n *\r\n * @returns {Array}\r\n * Array of arguments that can be passed into a task or transaction.\r\n *\r\n * It is extended with properties `options` and `cb` to access the corresponding array elements `[0]` and `[1]` by name.\r\n *\r\n * @example\r\n *\r\n * // Registering a custom transaction method that assigns a default Transaction Mode:\r\n *\r\n * const initOptions = {\r\n *     extend: obj => {\r\n *         obj.myTx = function(options, cb) {\r\n *             const args = pgp.utils.taskArgs(arguments); // prepare arguments\r\n *\r\n *             if (!('mode' in args.options)) {\r\n *                 // if no 'mode' was specified, set default for transaction mode:\r\n *                 args.options.mode = myTxModeObject; // of type pgp.txMode.TransactionMode\r\n *             }\r\n *\r\n *             return obj.tx.apply(this, args);\r\n *             // or explicitly, if needed:\r\n *             // return obj.tx.call(this, args.options, args.cb);\r\n *         }\r\n *     }\r\n * };\r\n *\r\n */\n\n\nfunction taskArgs(args) {\n  if (!args || typeof args.length !== `number`) {\n    throw new TypeError(`Parameter 'args' must be an array-like object of arguments.`);\n  }\n\n  let options = args[0],\n      cb;\n\n  if (typeof options === `function`) {\n    cb = options;\n    options = {};\n\n    if (cb.name) {\n      options.tag = cb.name;\n    }\n  } else {\n    if (typeof args[1] === `function`) {\n      cb = args[1];\n    }\n\n    if (typeof options === `string` || typeof options === `number`) {\n      options = {\n        tag: options\n      };\n    } else {\n      options = typeof options === `object` && options || {};\n\n      if (!(`tag` in options) && cb && cb.name) {\n        options.tag = cb.name;\n      }\n    }\n  }\n\n  const res = [options, cb];\n  Object.defineProperty(res, `options`, {\n    get: function () {\n      return this[0];\n    },\n    set: function (newValue) {\n      this[0] = newValue;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(res, `cb`, {\n    get: function () {\n      return this[1];\n    },\n    set: function (newValue) {\n      this[1] = newValue;\n    },\n    enumerable: true\n  });\n  return res;\n}\n/**\r\n * @namespace utils\r\n *\r\n * @description\r\n * Namespace for general-purpose static functions, available as `pgp.utils`, before and after initializing the library.\r\n *\r\n * @property {function} camelize\r\n * {@link utils.camelize camelize} - camelizes a text string\r\n *\r\n * @property {function} camelizeVar\r\n * {@link utils.camelizeVar camelizeVar} - camelizes a text string as a variable\r\n *\r\n * @property {function} enumSql\r\n * {@link utils.enumSql enumSql} - enumerates SQL files in a directory\r\n *\r\n * @property {function} taskArgs\r\n * {@link utils.taskArgs taskArgs} - prepares arguments for tasks and transactions\r\n */\n\n\nmodule.exports = {\n  camelize,\n  camelizeVar,\n  enumSql,\n  taskArgs\n};","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg-promise/lib/utils/public.js"],"names":["assertOptions","require","npm","fs","path","utils","package","camelize","text","replace","match","chr","toUpperCase","substr","toLowerCase","camelizeVar","_enumSql","dir","options","cb","namePath","tree","readdirSync","forEach","file","stat","fullPath","join","statSync","e","ignoreErrors","isDirectory","recursive","dirName","np","t","Object","keys","length","Error","extname","name","result","undefined","enumSql","isText","TypeError","taskArgs","args","tag","res","defineProperty","get","set","newValue","enumerable","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {assertOptions} = require(`assert-options`);\r\n\r\nconst npm = {\r\n    fs: require(`fs`),\r\n    path: require(`path`),\r\n    utils: require(`./`),\r\n    package: require(`../../package.json`)\r\n};\r\n\r\n/**\r\n * @method utils.camelize\r\n * @description\r\n * Camelizes a text string.\r\n *\r\n * Case-changing characters include:\r\n * - _hyphen_\r\n * - _underscore_\r\n * - _period_\r\n * - _space_\r\n *\r\n * @param {string} text\r\n * Input text string.\r\n *\r\n * @returns {string}\r\n * Camelized text string.\r\n *\r\n * @see\r\n * {@link utils.camelizeVar camelizeVar}\r\n *\r\n */\r\nfunction camelize(text) {\r\n    text = text.replace(/[-_\\s.]+(.)?/g, (match, chr) => {\r\n        return chr ? chr.toUpperCase() : ``;\r\n    });\r\n    return text.substr(0, 1).toLowerCase() + text.substr(1);\r\n}\r\n\r\n/**\r\n * @method utils.camelizeVar\r\n * @description\r\n * Camelizes a text string, while making it compliant with JavaScript variable names:\r\n * - contains symbols `a-z`, `A-Z`, `0-9`, `_` and `$`\r\n * - cannot have leading digits\r\n *\r\n * First, it removes all symbols that do not meet the above criteria, except for _hyphen_, _period_ and _space_,\r\n * and then it forwards into {@link utils.camelize camelize}.\r\n *\r\n * @param {string} text\r\n * Input text string.\r\n *\r\n * If it doesn't contain any symbols to make up a valid variable name, the result will be an empty string.\r\n *\r\n * @returns {string}\r\n * Camelized text string that can be used as an open property name.\r\n *\r\n * @see\r\n * {@link utils.camelize camelize}\r\n *\r\n */\r\nfunction camelizeVar(text) {\r\n    text = text.replace(/[^a-zA-Z0-9$_\\-\\s.]/g, ``).replace(/^[0-9_\\-\\s.]+/, ``);\r\n    return camelize(text);\r\n}\r\n\r\nfunction _enumSql(dir, options, cb, namePath) {\r\n    const tree = {};\r\n    npm.fs.readdirSync(dir).forEach(file => {\r\n        let stat;\r\n        const fullPath = npm.path.join(dir, file);\r\n        try {\r\n            stat = npm.fs.statSync(fullPath);\r\n        } catch (e) {\r\n            // while it is very easy to test manually, it is very difficult to test for\r\n            // access-denied errors automatically; therefore excluding from the coverage:\r\n            // istanbul ignore next\r\n            if (options.ignoreErrors) {\r\n                return; // on to the next file/folder;\r\n            }\r\n            // istanbul ignore next\r\n            throw e;\r\n        }\r\n        if (stat.isDirectory()) {\r\n            if (options.recursive) {\r\n                const dirName = camelizeVar(file);\r\n                const np = namePath ? (namePath + `.` + dirName) : dirName;\r\n                const t = _enumSql(fullPath, options, cb, np);\r\n                if (Object.keys(t).length) {\r\n                    if (!dirName.length || dirName in tree) {\r\n                        if (!options.ignoreErrors) {\r\n                            throw new Error(`Empty or duplicate camelized folder name: ` + fullPath);\r\n                        }\r\n                    }\r\n                    tree[dirName] = t;\r\n                }\r\n            }\r\n        } else {\r\n            if (npm.path.extname(file).toLowerCase() === `.sql`) {\r\n                const name = camelizeVar(file.replace(/\\.[^/.]+$/, ``));\r\n                if (!name.length || name in tree) {\r\n                    if (!options.ignoreErrors) {\r\n                        throw new Error(`Empty or duplicate camelized file name: ` + fullPath);\r\n                    }\r\n                }\r\n                tree[name] = fullPath;\r\n                if (cb) {\r\n                    const result = cb(fullPath, name, namePath ? (namePath + `.` + name) : name);\r\n                    if (result !== undefined) {\r\n                        tree[name] = result;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return tree;\r\n}\r\n\r\n/**\r\n * @method utils.enumSql\r\n * @description\r\n * Synchronously enumerates all SQL files (within a given directory) into a camelized SQL tree.\r\n *\r\n * All property names within the tree are camelized via {@link utils.camelizeVar camelizeVar},\r\n * so they can be used in the code directly, as open property names.\r\n *\r\n * @param {string} dir\r\n * Directory path where SQL files are located, either absolute or relative to the current directory.\r\n *\r\n * SQL files are identified by using `.sql` extension (case-insensitive).\r\n *\r\n * @param {object} [options]\r\n * Search options.\r\n *\r\n * @param {boolean} [options.recursive=false]\r\n * Include sub-directories into the search.\r\n *\r\n * Sub-directories without SQL files will be skipped from the result.\r\n *\r\n * @param {boolean} [options.ignoreErrors=false]\r\n * Ignore the following types of errors:\r\n * - access errors, when there is no read access to a file or folder\r\n * - empty or duplicate camelized property names\r\n *\r\n * This flag does not affect errors related to invalid input parameters, or if you pass in a\r\n * non-existing directory.\r\n *\r\n * @param {function} [cb]\r\n * A callback function that takes three arguments:\r\n * - `file` - SQL file path, relative or absolute, according to how you specified the search directory\r\n * - `name` - name of the property that represents the SQL file\r\n * - `path` - property resolution path (full property name)\r\n *\r\n * If the function returns anything other than `undefined`, it overrides the corresponding property value in the tree.\r\n *\r\n * @returns {object}\r\n * Camelized SQL tree object, with each value being an SQL file path (unless changed via the callback).\r\n *\r\n * @example\r\n *\r\n * // simple SQL tree generation for further processing:\r\n * const tree = pgp.utils.enumSql('../sql', {recursive: true});\r\n *\r\n * @example\r\n *\r\n * // generating an SQL tree for dynamic use of names:\r\n * const sql = pgp.utils.enumSql(__dirname, {recursive: true}, file => {\r\n *     return new pgp.QueryFile(file, {minify: true});\r\n * });\r\n *\r\n * @example\r\n *\r\n * const path = require('path');\r\n *\r\n * // replacing each relative path in the tree with a full one:\r\n * const tree = pgp.utils.enumSql('../sql', {recursive: true}, file => {\r\n *     return path.join(__dirname, file);\r\n * });\r\n *\r\n */\r\nfunction enumSql(dir, options, cb) {\r\n    if (!npm.utils.isText(dir)) {\r\n        throw new TypeError(`Parameter 'dir' must be a non-empty text string.`);\r\n    }\r\n    options = assertOptions(options, [`recursive`, `ignoreErrors`]);\r\n    cb = (typeof cb === `function`) ? cb : null;\r\n    return _enumSql(dir, options, cb, ``);\r\n}\r\n\r\n/**\r\n * @method utils.taskArgs\r\n * @description\r\n * Normalizes/prepares arguments for tasks and transactions.\r\n *\r\n * Its main purpose is to simplify adding custom methods {@link Database#task task}, {@link Database#taskIf taskIf},\r\n * {@link Database#tx tx} and {@link Database#txIf txIf} within event {@link event:extend extend}, as the those methods use fairly\r\n * complex logic for parsing inputs.\r\n *\r\n * @param args {Object}\r\n * Array-like object of `arguments` that was passed into the method. It is expected that the `arguments`\r\n * are always made of two parameters - `(options, cb)`, same as all the default task/transaction methods.\r\n *\r\n * And if your custom method needs additional parameters, they should be passed in as extra properties within `options`.\r\n *\r\n * @returns {Array}\r\n * Array of arguments that can be passed into a task or transaction.\r\n *\r\n * It is extended with properties `options` and `cb` to access the corresponding array elements `[0]` and `[1]` by name.\r\n *\r\n * @example\r\n *\r\n * // Registering a custom transaction method that assigns a default Transaction Mode:\r\n *\r\n * const initOptions = {\r\n *     extend: obj => {\r\n *         obj.myTx = function(options, cb) {\r\n *             const args = pgp.utils.taskArgs(arguments); // prepare arguments\r\n *\r\n *             if (!('mode' in args.options)) {\r\n *                 // if no 'mode' was specified, set default for transaction mode:\r\n *                 args.options.mode = myTxModeObject; // of type pgp.txMode.TransactionMode\r\n *             }\r\n *\r\n *             return obj.tx.apply(this, args);\r\n *             // or explicitly, if needed:\r\n *             // return obj.tx.call(this, args.options, args.cb);\r\n *         }\r\n *     }\r\n * };\r\n *\r\n */\r\nfunction taskArgs(args) {\r\n\r\n    if (!args || typeof args.length !== `number`) {\r\n        throw new TypeError(`Parameter 'args' must be an array-like object of arguments.`);\r\n    }\r\n\r\n    let options = args[0], cb;\r\n    if (typeof options === `function`) {\r\n        cb = options;\r\n        options = {};\r\n        if (cb.name) {\r\n            options.tag = cb.name;\r\n        }\r\n    } else {\r\n        if (typeof args[1] === `function`) {\r\n            cb = args[1];\r\n        }\r\n        if (typeof options === `string` || typeof options === `number`) {\r\n            options = {tag: options};\r\n        } else {\r\n            options = (typeof options === `object` && options) || {};\r\n            if (!(`tag` in options) && cb && cb.name) {\r\n                options.tag = cb.name;\r\n            }\r\n        }\r\n    }\r\n\r\n    const res = [options, cb];\r\n\r\n    Object.defineProperty(res, `options`, {\r\n        get: function () {\r\n            return this[0];\r\n        },\r\n        set: function (newValue) {\r\n            this[0] = newValue;\r\n        },\r\n        enumerable: true\r\n    });\r\n\r\n    Object.defineProperty(res, `cb`, {\r\n        get: function () {\r\n            return this[1];\r\n        },\r\n        set: function (newValue) {\r\n            this[1] = newValue;\r\n        },\r\n        enumerable: true\r\n    });\r\n\r\n    return res;\r\n}\r\n\r\n/**\r\n * @namespace utils\r\n *\r\n * @description\r\n * Namespace for general-purpose static functions, available as `pgp.utils`, before and after initializing the library.\r\n *\r\n * @property {function} camelize\r\n * {@link utils.camelize camelize} - camelizes a text string\r\n *\r\n * @property {function} camelizeVar\r\n * {@link utils.camelizeVar camelizeVar} - camelizes a text string as a variable\r\n *\r\n * @property {function} enumSql\r\n * {@link utils.enumSql enumSql} - enumerates SQL files in a directory\r\n *\r\n * @property {function} taskArgs\r\n * {@link utils.taskArgs taskArgs} - prepares arguments for tasks and transactions\r\n */\r\nmodule.exports = {\r\n    camelize,\r\n    camelizeVar,\r\n    enumSql,\r\n    taskArgs\r\n};\r\n"]},"metadata":{},"sourceType":"script"}