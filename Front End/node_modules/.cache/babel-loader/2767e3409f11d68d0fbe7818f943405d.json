{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\nconst {\n  assertOptions\n} = require(`assert-options`);\n\nconst npm = {\n  utils: require(`../utils`),\n  format: require(`../formatting`).as // formatting namespace\n\n};\n/**\r\n * @class helpers.TableName\r\n * @description\r\n * Represents a full table name that can be injected into queries directly.\r\n *\r\n * This is a read-only type that can be used wherever parameter `table` is supported.\r\n *\r\n * It supports $[Custom Type Formatting], which means you can use the type directly as a formatting\r\n * parameter, without specifying any escaping.\r\n *\r\n * @param {string|object} table\r\n * Table name details, depending on the type:\r\n *\r\n * - table name, if `table` is a string\r\n * - object `{table, [schema]}`\r\n *\r\n * @property {string} name\r\n * Formatted/escaped full table name, combining `schema` + `table`.\r\n *\r\n * @property {string} table\r\n * Table name.\r\n *\r\n * @property {string} schema\r\n * Database schema name.\r\n *\r\n * It is `undefined` when no valid schema was specified.\r\n *\r\n * @returns {helpers.TableName}\r\n *\r\n * @see\r\n * {@link helpers.TableName#toPostgres toPostgres}\r\n *\r\n * @example\r\n *\r\n * const table = new pgp.helpers.TableName({table: 'my-table', schema: 'my-schema'});\r\n * console.log(table);\r\n * //=> \"my-schema\".\"my-table\"\r\n *\r\n * // Formatting the type directly:\r\n * pgp.as.format('SELECT * FROM $1', table);\r\n * //=> SELECT * FROM \"my-schema\".\"my-table\"\r\n *\r\n */\n\nclass TableName {\n  constructor(table) {\n    if (typeof table === `string`) {\n      this.table = table;\n    } else {\n      const config = assertOptions(table, [`table`, `schema`]);\n      this.table = config.table;\n\n      if (npm.utils.isText(config.schema)) {\n        this.schema = config.schema;\n      }\n    }\n\n    if (!npm.utils.isText(this.table)) {\n      throw new TypeError(`Table name must be a non-empty text string.`);\n    }\n\n    this.name = npm.format.name(this.table);\n\n    if (this.schema) {\n      this.name = npm.format.name(this.schema) + `.` + this.name;\n    }\n\n    Object.freeze(this);\n  }\n\n}\n/**\r\n * @method helpers.TableName#toPostgres\r\n * @description\r\n * $[Custom Type Formatting], based on $[Symbolic CTF], i.e. the actual method is available only via {@link external:Symbol Symbol}:\r\n *\r\n * ```js\r\n * const ctf = pgp.as.ctf; // Custom Type Formatting symbols namespace\r\n * const fullName = tn[ctf.toPostgres]; // tn = an object of type TableName\r\n * ```\r\n *\r\n * This is a raw formatting type (`rawType = true`), i.e. when used as a query-formatting parameter, type `TableName`\r\n * injects full table name as raw text.\r\n *\r\n * @param {helpers.TableName} [self]\r\n * Optional self-reference, for ES6 arrow functions.\r\n *\r\n * @returns {string}\r\n * Escaped full table name that includes optional schema name, if specified.\r\n */\n\n\nTableName.prototype[npm.format.ctf.toPostgres] = function (self) {\n  self = this instanceof TableName && this || self;\n  return self.name;\n};\n\nTableName.prototype[npm.format.ctf.rawType] = true; // use as pre-formatted\n\n/**\r\n * @method helpers.TableName#toString\r\n * @description\r\n * Creates a well-formatted string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @returns {string}\r\n */\n\nTableName.prototype.toString = function () {\n  return this.name;\n};\n\nnpm.utils.addInspection(TableName, function () {\n  return this.toString();\n});\nmodule.exports = {\n  TableName\n};","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg-promise/lib/helpers/table-name.js"],"names":["assertOptions","require","npm","utils","format","as","TableName","constructor","table","config","isText","schema","TypeError","name","Object","freeze","prototype","ctf","toPostgres","self","rawType","toString","addInspection","module","exports"],"mappings":"AAAA;;;;;;;;AASA,MAAM;AAACA,EAAAA;AAAD,IAAkBC,OAAO,CAAE,gBAAF,CAA/B;;AAEA,MAAMC,GAAG,GAAG;AACRC,EAAAA,KAAK,EAAEF,OAAO,CAAE,UAAF,CADN;AAERG,EAAAA,MAAM,EAAEH,OAAO,CAAE,eAAF,CAAP,CAAyBI,EAFzB,CAE4B;;AAF5B,CAAZ;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA,MAAMC,SAAN,CAAgB;AAEZC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,QAAI,OAAOA,KAAP,KAAkB,QAAtB,EAA+B;AAC3B,WAAKA,KAAL,GAAaA,KAAb;AACH,KAFD,MAEO;AACH,YAAMC,MAAM,GAAGT,aAAa,CAACQ,KAAD,EAAQ,CAAE,OAAF,EAAW,QAAX,CAAR,CAA5B;AACA,WAAKA,KAAL,GAAaC,MAAM,CAACD,KAApB;;AACA,UAAIN,GAAG,CAACC,KAAJ,CAAUO,MAAV,CAAiBD,MAAM,CAACE,MAAxB,CAAJ,EAAqC;AACjC,aAAKA,MAAL,GAAcF,MAAM,CAACE,MAArB;AACH;AACJ;;AACD,QAAI,CAACT,GAAG,CAACC,KAAJ,CAAUO,MAAV,CAAiB,KAAKF,KAAtB,CAAL,EAAmC;AAC/B,YAAM,IAAII,SAAJ,CAAe,6CAAf,CAAN;AACH;;AACD,SAAKC,IAAL,GAAYX,GAAG,CAACE,MAAJ,CAAWS,IAAX,CAAgB,KAAKL,KAArB,CAAZ;;AACA,QAAI,KAAKG,MAAT,EAAiB;AACb,WAAKE,IAAL,GAAYX,GAAG,CAACE,MAAJ,CAAWS,IAAX,CAAgB,KAAKF,MAArB,IAAgC,GAAhC,GAAqC,KAAKE,IAAtD;AACH;;AACDC,IAAAA,MAAM,CAACC,MAAP,CAAc,IAAd;AACH;;AApBW;AAuBhB;;;;;;;;;;;;;;;;;;;;;AAmBAT,SAAS,CAACU,SAAV,CAAoBd,GAAG,CAACE,MAAJ,CAAWa,GAAX,CAAeC,UAAnC,IAAiD,UAAUC,IAAV,EAAgB;AAC7DA,EAAAA,IAAI,GAAG,gBAAgBb,SAAhB,IAA6B,IAA7B,IAAqCa,IAA5C;AACA,SAAOA,IAAI,CAACN,IAAZ;AACH,CAHD;;AAKAP,SAAS,CAACU,SAAV,CAAoBd,GAAG,CAACE,MAAJ,CAAWa,GAAX,CAAeG,OAAnC,IAA8C,IAA9C,C,CAAoD;;AAEpD;;;;;;;;;;AASAd,SAAS,CAACU,SAAV,CAAoBK,QAApB,GAA+B,YAAY;AACvC,SAAO,KAAKR,IAAZ;AACH,CAFD;;AAIAX,GAAG,CAACC,KAAJ,CAAUmB,aAAV,CAAwBhB,SAAxB,EAAmC,YAAY;AAC3C,SAAO,KAAKe,QAAL,EAAP;AACH,CAFD;AAIAE,MAAM,CAACC,OAAP,GAAiB;AAAClB,EAAAA;AAAD,CAAjB","sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {assertOptions} = require(`assert-options`);\r\n\r\nconst npm = {\r\n    utils: require(`../utils`),\r\n    format: require(`../formatting`).as // formatting namespace\r\n};\r\n\r\n/**\r\n * @class helpers.TableName\r\n * @description\r\n * Represents a full table name that can be injected into queries directly.\r\n *\r\n * This is a read-only type that can be used wherever parameter `table` is supported.\r\n *\r\n * It supports $[Custom Type Formatting], which means you can use the type directly as a formatting\r\n * parameter, without specifying any escaping.\r\n *\r\n * @param {string|object} table\r\n * Table name details, depending on the type:\r\n *\r\n * - table name, if `table` is a string\r\n * - object `{table, [schema]}`\r\n *\r\n * @property {string} name\r\n * Formatted/escaped full table name, combining `schema` + `table`.\r\n *\r\n * @property {string} table\r\n * Table name.\r\n *\r\n * @property {string} schema\r\n * Database schema name.\r\n *\r\n * It is `undefined` when no valid schema was specified.\r\n *\r\n * @returns {helpers.TableName}\r\n *\r\n * @see\r\n * {@link helpers.TableName#toPostgres toPostgres}\r\n *\r\n * @example\r\n *\r\n * const table = new pgp.helpers.TableName({table: 'my-table', schema: 'my-schema'});\r\n * console.log(table);\r\n * //=> \"my-schema\".\"my-table\"\r\n *\r\n * // Formatting the type directly:\r\n * pgp.as.format('SELECT * FROM $1', table);\r\n * //=> SELECT * FROM \"my-schema\".\"my-table\"\r\n *\r\n */\r\nclass TableName {\r\n\r\n    constructor(table) {\r\n        if (typeof table === `string`) {\r\n            this.table = table;\r\n        } else {\r\n            const config = assertOptions(table, [`table`, `schema`]);\r\n            this.table = config.table;\r\n            if (npm.utils.isText(config.schema)) {\r\n                this.schema = config.schema;\r\n            }\r\n        }\r\n        if (!npm.utils.isText(this.table)) {\r\n            throw new TypeError(`Table name must be a non-empty text string.`);\r\n        }\r\n        this.name = npm.format.name(this.table);\r\n        if (this.schema) {\r\n            this.name = npm.format.name(this.schema) + `.` + this.name;\r\n        }\r\n        Object.freeze(this);\r\n    }\r\n}\r\n\r\n/**\r\n * @method helpers.TableName#toPostgres\r\n * @description\r\n * $[Custom Type Formatting], based on $[Symbolic CTF], i.e. the actual method is available only via {@link external:Symbol Symbol}:\r\n *\r\n * ```js\r\n * const ctf = pgp.as.ctf; // Custom Type Formatting symbols namespace\r\n * const fullName = tn[ctf.toPostgres]; // tn = an object of type TableName\r\n * ```\r\n *\r\n * This is a raw formatting type (`rawType = true`), i.e. when used as a query-formatting parameter, type `TableName`\r\n * injects full table name as raw text.\r\n *\r\n * @param {helpers.TableName} [self]\r\n * Optional self-reference, for ES6 arrow functions.\r\n *\r\n * @returns {string}\r\n * Escaped full table name that includes optional schema name, if specified.\r\n */\r\nTableName.prototype[npm.format.ctf.toPostgres] = function (self) {\r\n    self = this instanceof TableName && this || self;\r\n    return self.name;\r\n};\r\n\r\nTableName.prototype[npm.format.ctf.rawType] = true; // use as pre-formatted\r\n\r\n/**\r\n * @method helpers.TableName#toString\r\n * @description\r\n * Creates a well-formatted string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @returns {string}\r\n */\r\nTableName.prototype.toString = function () {\r\n    return this.name;\r\n};\r\n\r\nnpm.utils.addInspection(TableName, function () {\r\n    return this.toString();\r\n});\r\n\r\nmodule.exports = {TableName};\r\n"]},"metadata":{},"sourceType":"script"}