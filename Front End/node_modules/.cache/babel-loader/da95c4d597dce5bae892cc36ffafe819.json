{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\nconst {\n  ServerFormatting\n} = require(`./server-formatting`);\n\nconst {\n  PreparedStatementError\n} = require(`../errors`);\n\nconst {\n  QueryFile\n} = require(`../query-file`);\n\nconst {\n  assertOptions\n} = require(`assert-options`);\n\nconst npm = {\n  EOL: require(`os`).EOL,\n  utils: require(`../utils`)\n};\n/**\r\n * @class PreparedStatement\r\n * @description\r\n * Constructs a new $[Prepared Statement] object. All properties can also be set after the object's construction.\r\n *\r\n * This type extends the basic `{name, text, values}` object, i.e. when the basic object is used\r\n * with a query method, a new {@link PreparedStatement} object is created in its place.\r\n *\r\n * The type can be used in place of the `query` parameter, with any query method directly.\r\n *\r\n * The type is available from the library's root: `pgp.PreparedStatement`.\r\n *\r\n * @param {Object} [options]\r\n * Object configuration options / properties.\r\n *\r\n * @param {string} [options.name] - See property {@link PreparedStatement#name name}.\r\n * @param {string|QueryFile} [options.text] - See property {@link PreparedStatement#text text}.\r\n * @param {array} [options.values] - See property {@link PreparedStatement#values values}.\r\n * @param {boolean} [options.binary] - See property {@link PreparedStatement#binary binary}.\r\n * @param {string} [options.rowMode] - See property {@link PreparedStatement#rowMode rowMode}.\r\n * @param {number} [options.rows] - See property {@link PreparedStatement#rows rows}.\r\n *\r\n * @returns {PreparedStatement}\r\n *\r\n * @see\r\n * {@link errors.PreparedStatementError PreparedStatementError},\r\n * {@link http://www.postgresql.org/docs/9.6/static/sql-prepare.html PostgreSQL Prepared Statements}\r\n *\r\n * @example\r\n *\r\n * const PS = require('pg-promise').PreparedStatement;\r\n *\r\n * // Creating a complete Prepared Statement with parameters:\r\n * const findUser = new PS({name: 'find-user', text: 'SELECT * FROM Users WHERE id = $1', values: [123]});\r\n *\r\n * db.one(findUser)\r\n *     .then(user => {\r\n *         // user found;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * @example\r\n *\r\n * const PS = require('pg-promise').PreparedStatement;\r\n *\r\n * // Creating a reusable Prepared Statement without values:\r\n * const addUser = new PS({name: 'add-user', text: 'INSERT INTO Users(name, age) VALUES($1, $2)'});\r\n *\r\n * // setting values explicitly:\r\n * addUser.values = ['John', 30];\r\n *\r\n * db.none(addUser)\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * // setting values implicitly, by passing them into the query method:\r\n * db.none(addUser, ['Mike', 25])\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n */\n\nclass PreparedStatement extends ServerFormatting {\n  constructor(options) {\n    options = assertOptions(options, [`name`, `text`, `values`, `binary`, `rowMode`, `rows`]);\n    super(options);\n  }\n  /**\r\n   * @name PreparedStatement#name\r\n   * @type {string}\r\n   * @description\r\n   * An arbitrary name given to this particular prepared statement. It must be unique within a single session and is\r\n   * subsequently used to execute or deallocate a previously prepared statement.\r\n   */\n\n\n  get name() {\n    return this._inner.options.name;\n  }\n\n  set name(value) {\n    const _i = this._inner;\n\n    if (value !== _i.options.name) {\n      _i.options.name = value;\n      _i.changed = true;\n    }\n  }\n  /**\r\n   * @name PreparedStatement#rows\r\n   * @type {number}\r\n   * @description\r\n   * Number of rows to return at a time from a Prepared Statement's portal.\r\n   * The default is 0, which means that all rows must be returned at once.\r\n   */\n\n\n  get rows() {\n    return this._inner.options.rows;\n  }\n\n  set rows(value) {\n    const _i = this._inner;\n\n    if (value !== _i.options.rows) {\n      _i.options.rows = value;\n      _i.changed = true;\n    }\n  }\n\n}\n/**\r\n * @method PreparedStatement#parse\r\n * @description\r\n * Parses the current object and returns a simple `{name, text, values}`, if successful,\r\n * or else it returns a {@link errors.PreparedStatementError PreparedStatementError} object.\r\n *\r\n * This method is primarily for internal use by the library.\r\n *\r\n * @returns {{name, text, values}|errors.PreparedStatementError}\r\n */\n\n\nPreparedStatement.prototype.parse = function () {\n  const _i = this._inner,\n        options = _i.options;\n  const qf = options.text instanceof QueryFile ? options.text : null;\n\n  if (!_i.changed && !qf) {\n    return _i.target;\n  }\n\n  const errors = [],\n        values = _i.target.values;\n  _i.target = {\n    name: options.name,\n    text: options.text\n  };\n  _i.changed = true;\n  _i.currentError = undefined;\n\n  if (!npm.utils.isText(_i.target.name)) {\n    errors.push(`Property 'name' must be a non-empty text string.`);\n  }\n\n  if (qf) {\n    qf.prepare();\n\n    if (qf.error) {\n      errors.push(qf.error);\n    } else {\n      _i.target.text = qf[QueryFile.$query];\n    }\n  }\n\n  if (!npm.utils.isText(_i.target.text)) {\n    errors.push(`Property 'text' must be a non-empty text string.`);\n  }\n\n  if (!npm.utils.isNull(values)) {\n    _i.target.values = values;\n  }\n\n  if (options.binary !== undefined) {\n    _i.target.binary = !!options.binary;\n  }\n\n  if (options.rowMode !== undefined) {\n    _i.target.rowMode = options.rowMode;\n  }\n\n  if (options.rows !== undefined) {\n    _i.target.rows = options.rows;\n  }\n\n  if (errors.length) {\n    return _i.currentError = new PreparedStatementError(errors[0], _i.target);\n  }\n\n  _i.changed = false;\n  return _i.target;\n};\n/**\r\n * @method PreparedStatement#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object's current state.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\n\n\nPreparedStatement.prototype.toString = function (level) {\n  level = level > 0 ? parseInt(level) : 0;\n  const gap = npm.utils.messageGap(level + 1);\n  const ps = this.parse();\n  const lines = [`PreparedStatement {`, gap + `name: ` + npm.utils.toJson(this.name)];\n\n  if (npm.utils.isText(ps.text)) {\n    lines.push(gap + `text: \"` + ps.text + `\"`);\n  }\n\n  if (this.values !== undefined) {\n    lines.push(gap + `values: ` + npm.utils.toJson(this.values));\n  }\n\n  if (this.binary !== undefined) {\n    lines.push(gap + `binary: ` + npm.utils.toJson(this.binary));\n  }\n\n  if (this.rowMode !== undefined) {\n    lines.push(gap + `rowMode: ` + npm.utils.toJson(this.rowMode));\n  }\n\n  if (this.rows !== undefined) {\n    lines.push(gap + `rows: ` + npm.utils.toJson(this.rows));\n  }\n\n  if (this.error) {\n    lines.push(gap + `error: ` + this.error.toString(level + 1));\n  }\n\n  lines.push(npm.utils.messageGap(level) + `}`);\n  return lines.join(npm.EOL);\n};\n\nmodule.exports = {\n  PreparedStatement\n};\n/**\r\n * @name PreparedStatement#text\r\n * @type {string|QueryFile}\r\n * @description\r\n * A non-empty query string or a {@link QueryFile} object.\r\n *\r\n * Only the basic variables (`$1`, `$2`, etc) can be used in the query, because $[Prepared Statements]\r\n * are formatted on the server side.\r\n *\r\n * Changing this property for the same {@link PreparedStatement#name name} will have no effect, because queries\r\n * for Prepared Statements are cached by the server, with {@link PreparedStatement#name name} being the cache key.\r\n */\n\n/**\r\n * @name PreparedStatement#values\r\n * @type {array}\r\n * @description\r\n * Query formatting parameters, depending on the type:\r\n *\r\n * - `null` / `undefined` means the query has no formatting parameters\r\n * - `Array` - it is an array of formatting parameters\r\n * - None of the above, means it is a single formatting value, which\r\n *   is then automatically wrapped into an array\r\n */\n\n/**\r\n * @name PreparedStatement#binary\r\n * @type {boolean}\r\n * @default undefined\r\n * @description\r\n * Activates binary result mode. The default is the text mode.\r\n *\r\n * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}\r\n */\n\n/**\r\n * @name PreparedStatement#rowMode\r\n * @type {string}\r\n * @default undefined\r\n * @description\r\n * Changes the way data arrives to the client, with only one value supported by $[pg]:\r\n *  - `array` will make all data rows arrive as arrays of values. By default, rows arrive as objects.\r\n */\n\n/**\r\n * @name PreparedStatement#error\r\n * @type {errors.PreparedStatementError}\r\n * @default undefined\r\n * @description\r\n * When in an error state, it is set to a {@link errors.PreparedStatementError PreparedStatementError} object. Otherwise, it is `undefined`.\r\n *\r\n * This property is primarily for internal use by the library.\r\n */","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg-promise/lib/types/prepared-statement.js"],"names":["ServerFormatting","require","PreparedStatementError","QueryFile","assertOptions","npm","EOL","utils","PreparedStatement","constructor","options","name","_inner","value","_i","changed","rows","prototype","parse","qf","text","target","errors","values","currentError","undefined","isText","push","prepare","error","$query","isNull","binary","rowMode","length","toString","level","parseInt","gap","messageGap","ps","lines","toJson","join","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {ServerFormatting} = require(`./server-formatting`);\r\nconst {PreparedStatementError} = require(`../errors`);\r\nconst {QueryFile} = require(`../query-file`);\r\nconst {assertOptions} = require(`assert-options`);\r\n\r\nconst npm = {\r\n    EOL: require(`os`).EOL,\r\n    utils: require(`../utils`)\r\n};\r\n\r\n/**\r\n * @class PreparedStatement\r\n * @description\r\n * Constructs a new $[Prepared Statement] object. All properties can also be set after the object's construction.\r\n *\r\n * This type extends the basic `{name, text, values}` object, i.e. when the basic object is used\r\n * with a query method, a new {@link PreparedStatement} object is created in its place.\r\n *\r\n * The type can be used in place of the `query` parameter, with any query method directly.\r\n *\r\n * The type is available from the library's root: `pgp.PreparedStatement`.\r\n *\r\n * @param {Object} [options]\r\n * Object configuration options / properties.\r\n *\r\n * @param {string} [options.name] - See property {@link PreparedStatement#name name}.\r\n * @param {string|QueryFile} [options.text] - See property {@link PreparedStatement#text text}.\r\n * @param {array} [options.values] - See property {@link PreparedStatement#values values}.\r\n * @param {boolean} [options.binary] - See property {@link PreparedStatement#binary binary}.\r\n * @param {string} [options.rowMode] - See property {@link PreparedStatement#rowMode rowMode}.\r\n * @param {number} [options.rows] - See property {@link PreparedStatement#rows rows}.\r\n *\r\n * @returns {PreparedStatement}\r\n *\r\n * @see\r\n * {@link errors.PreparedStatementError PreparedStatementError},\r\n * {@link http://www.postgresql.org/docs/9.6/static/sql-prepare.html PostgreSQL Prepared Statements}\r\n *\r\n * @example\r\n *\r\n * const PS = require('pg-promise').PreparedStatement;\r\n *\r\n * // Creating a complete Prepared Statement with parameters:\r\n * const findUser = new PS({name: 'find-user', text: 'SELECT * FROM Users WHERE id = $1', values: [123]});\r\n *\r\n * db.one(findUser)\r\n *     .then(user => {\r\n *         // user found;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * @example\r\n *\r\n * const PS = require('pg-promise').PreparedStatement;\r\n *\r\n * // Creating a reusable Prepared Statement without values:\r\n * const addUser = new PS({name: 'add-user', text: 'INSERT INTO Users(name, age) VALUES($1, $2)'});\r\n *\r\n * // setting values explicitly:\r\n * addUser.values = ['John', 30];\r\n *\r\n * db.none(addUser)\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * // setting values implicitly, by passing them into the query method:\r\n * db.none(addUser, ['Mike', 25])\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n */\r\nclass PreparedStatement extends ServerFormatting {\r\n    constructor(options) {\r\n        options = assertOptions(options, [`name`, `text`, `values`, `binary`, `rowMode`, `rows`]);\r\n        super(options);\r\n    }\r\n\r\n    /**\r\n     * @name PreparedStatement#name\r\n     * @type {string}\r\n     * @description\r\n     * An arbitrary name given to this particular prepared statement. It must be unique within a single session and is\r\n     * subsequently used to execute or deallocate a previously prepared statement.\r\n     */\r\n    get name() {\r\n        return this._inner.options.name;\r\n    }\r\n\r\n    set name(value) {\r\n        const _i = this._inner;\r\n        if (value !== _i.options.name) {\r\n            _i.options.name = value;\r\n            _i.changed = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @name PreparedStatement#rows\r\n     * @type {number}\r\n     * @description\r\n     * Number of rows to return at a time from a Prepared Statement's portal.\r\n     * The default is 0, which means that all rows must be returned at once.\r\n     */\r\n    get rows() {\r\n        return this._inner.options.rows;\r\n    }\r\n\r\n    set rows(value) {\r\n        const _i = this._inner;\r\n        if (value !== _i.options.rows) {\r\n            _i.options.rows = value;\r\n            _i.changed = true;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @method PreparedStatement#parse\r\n * @description\r\n * Parses the current object and returns a simple `{name, text, values}`, if successful,\r\n * or else it returns a {@link errors.PreparedStatementError PreparedStatementError} object.\r\n *\r\n * This method is primarily for internal use by the library.\r\n *\r\n * @returns {{name, text, values}|errors.PreparedStatementError}\r\n */\r\nPreparedStatement.prototype.parse = function () {\r\n\r\n    const _i = this._inner, options = _i.options;\r\n\r\n    const qf = options.text instanceof QueryFile ? options.text : null;\r\n\r\n    if (!_i.changed && !qf) {\r\n        return _i.target;\r\n    }\r\n\r\n    const errors = [], values = _i.target.values;\r\n    _i.target = {\r\n        name: options.name,\r\n        text: options.text\r\n    };\r\n    _i.changed = true;\r\n    _i.currentError = undefined;\r\n\r\n    if (!npm.utils.isText(_i.target.name)) {\r\n        errors.push(`Property 'name' must be a non-empty text string.`);\r\n    }\r\n\r\n    if (qf) {\r\n        qf.prepare();\r\n        if (qf.error) {\r\n            errors.push(qf.error);\r\n        } else {\r\n            _i.target.text = qf[QueryFile.$query];\r\n        }\r\n    }\r\n    if (!npm.utils.isText(_i.target.text)) {\r\n        errors.push(`Property 'text' must be a non-empty text string.`);\r\n    }\r\n\r\n    if (!npm.utils.isNull(values)) {\r\n        _i.target.values = values;\r\n    }\r\n\r\n    if (options.binary !== undefined) {\r\n        _i.target.binary = !!options.binary;\r\n    }\r\n\r\n    if (options.rowMode !== undefined) {\r\n        _i.target.rowMode = options.rowMode;\r\n    }\r\n\r\n    if (options.rows !== undefined) {\r\n        _i.target.rows = options.rows;\r\n    }\r\n\r\n    if (errors.length) {\r\n        return _i.currentError = new PreparedStatementError(errors[0], _i.target);\r\n    }\r\n\r\n    _i.changed = false;\r\n\r\n    return _i.target;\r\n};\r\n\r\n/**\r\n * @method PreparedStatement#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object's current state.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nPreparedStatement.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    const gap = npm.utils.messageGap(level + 1);\r\n    const ps = this.parse();\r\n    const lines = [\r\n        `PreparedStatement {`,\r\n        gap + `name: ` + npm.utils.toJson(this.name)\r\n    ];\r\n    if (npm.utils.isText(ps.text)) {\r\n        lines.push(gap + `text: \"` + ps.text + `\"`);\r\n    }\r\n    if (this.values !== undefined) {\r\n        lines.push(gap + `values: ` + npm.utils.toJson(this.values));\r\n    }\r\n    if (this.binary !== undefined) {\r\n        lines.push(gap + `binary: ` + npm.utils.toJson(this.binary));\r\n    }\r\n    if (this.rowMode !== undefined) {\r\n        lines.push(gap + `rowMode: ` + npm.utils.toJson(this.rowMode));\r\n    }\r\n    if (this.rows !== undefined) {\r\n        lines.push(gap + `rows: ` + npm.utils.toJson(this.rows));\r\n    }\r\n    if (this.error) {\r\n        lines.push(gap + `error: ` + this.error.toString(level + 1));\r\n    }\r\n    lines.push(npm.utils.messageGap(level) + `}`);\r\n    return lines.join(npm.EOL);\r\n};\r\n\r\nmodule.exports = {PreparedStatement};\r\n\r\n/**\r\n * @name PreparedStatement#text\r\n * @type {string|QueryFile}\r\n * @description\r\n * A non-empty query string or a {@link QueryFile} object.\r\n *\r\n * Only the basic variables (`$1`, `$2`, etc) can be used in the query, because $[Prepared Statements]\r\n * are formatted on the server side.\r\n *\r\n * Changing this property for the same {@link PreparedStatement#name name} will have no effect, because queries\r\n * for Prepared Statements are cached by the server, with {@link PreparedStatement#name name} being the cache key.\r\n */\r\n\r\n/**\r\n * @name PreparedStatement#values\r\n * @type {array}\r\n * @description\r\n * Query formatting parameters, depending on the type:\r\n *\r\n * - `null` / `undefined` means the query has no formatting parameters\r\n * - `Array` - it is an array of formatting parameters\r\n * - None of the above, means it is a single formatting value, which\r\n *   is then automatically wrapped into an array\r\n */\r\n\r\n/**\r\n * @name PreparedStatement#binary\r\n * @type {boolean}\r\n * @default undefined\r\n * @description\r\n * Activates binary result mode. The default is the text mode.\r\n *\r\n * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}\r\n */\r\n\r\n/**\r\n * @name PreparedStatement#rowMode\r\n * @type {string}\r\n * @default undefined\r\n * @description\r\n * Changes the way data arrives to the client, with only one value supported by $[pg]:\r\n *  - `array` will make all data rows arrive as arrays of values. By default, rows arrive as objects.\r\n */\r\n\r\n/**\r\n * @name PreparedStatement#error\r\n * @type {errors.PreparedStatementError}\r\n * @default undefined\r\n * @description\r\n * When in an error state, it is set to a {@link errors.PreparedStatementError PreparedStatementError} object. Otherwise, it is `undefined`.\r\n *\r\n * This property is primarily for internal use by the library.\r\n */\r\n"]},"metadata":{},"sourceType":"script"}