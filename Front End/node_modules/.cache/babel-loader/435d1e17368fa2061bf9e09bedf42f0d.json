{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\nconst {\n  Events\n} = require(`./events`);\n\nconst {\n  ColorConsole\n} = require(`./utils/color`);\n\nconst npm = {\n  utils: require(`./utils`),\n  text: require(`./text`),\n  formatting: require(`./formatting`)\n};\n\nfunction poolConnect(ctx, db, config) {\n  return config.promise((resolve, reject) => {\n    const p = db.$pool;\n\n    if (p.ending) {\n      db.$destroy();\n      const err = new Error(npm.text.poolDestroyed);\n      Events.error(ctx.options, err, {\n        dc: ctx.dc\n      });\n      reject(err);\n      return;\n    }\n\n    p.connect((err, client) => {\n      if (err) {\n        Events.error(ctx.options, err, {\n          cn: npm.utils.getSafeConnection(ctx.cn),\n          dc: ctx.dc\n        });\n        reject(err);\n      } else {\n        if (`$useCount` in client) {\n          client.$useCount++;\n        } else {\n          Object.defineProperty(client, `$useCount`, {\n            value: 0,\n            configurable: false,\n            enumerable: false,\n            writable: true\n          });\n          setSchema(client, ctx);\n        }\n\n        setCtx(client, ctx);\n        const end = lockClientEnd(client);\n        client.on(`error`, onError);\n        resolve({\n          client,\n          useCount: client.$useCount,\n\n          release(kill) {\n            client.end = end;\n            client.release(kill || client.$connectionError);\n            Events.disconnect(ctx, client);\n            client.removeListener(`error`, onError);\n          }\n\n        });\n        Events.connect(ctx, client, client.$useCount);\n      }\n    });\n  });\n}\n\nfunction directConnect(ctx, config) {\n  return config.promise((resolve, reject) => {\n    const client = new config.pgp.pg.Client(ctx.cn);\n    client.connect(err => {\n      if (err) {\n        Events.error(ctx.options, err, {\n          cn: npm.utils.getSafeConnection(ctx.cn),\n          dc: ctx.dc\n        });\n        reject(err);\n      } else {\n        setSchema(client, ctx);\n        setCtx(client, ctx);\n        const end = lockClientEnd(client);\n        client.on(`error`, onError);\n        resolve({\n          client,\n          useCount: 0,\n\n          release() {\n            client.end = end;\n            client.end();\n            Events.disconnect(ctx, client);\n            client.removeListener(`error`, onError);\n          }\n\n        });\n        Events.connect(ctx, client, 0);\n      }\n    });\n  });\n} // this event only happens when the connection is lost physically,\n// which cannot be tested automatically; removing from coverage:\n// istanbul ignore next\n\n\nfunction onError(err) {\n  const ctx = this.$ctx;\n  const cn = npm.utils.getSafeConnection(ctx.cn);\n  Events.error(ctx.options, err, {\n    cn,\n    dc: ctx.dc\n  });\n\n  if (ctx.cnOptions && typeof ctx.cnOptions.onLost === `function` && !ctx.notified) {\n    try {\n      ctx.cnOptions.onLost.call(this, err, {\n        cn,\n        dc: ctx.dc,\n        start: ctx.start,\n        client: this\n      });\n    } catch (e) {\n      ColorConsole.error(e && e.stack || e);\n    }\n\n    ctx.notified = true;\n  }\n}\n\nfunction lockClientEnd(client) {\n  const end = client.end;\n\n  client.end = doNotCall => {\n    // This call can happen only in the following two cases:\n    // 1. the client made the call directly, against the library's documentation (invalid code)\n    // 2. connection with the server broke, and the pool is terminating all clients forcefully.\n    ColorConsole.error(`${npm.text.clientEnd}\\n${npm.utils.getLocalStack(1, 3)}\\n`);\n\n    if (!doNotCall) {\n      end.call(client);\n    }\n  };\n\n  return end;\n}\n\nfunction setCtx(client, ctx) {\n  Object.defineProperty(client, `$ctx`, {\n    value: ctx,\n    writable: true\n  });\n}\n\nfunction setSchema(client, ctx) {\n  let s = ctx.options.schema;\n\n  if (!s) {\n    return;\n  }\n\n  if (typeof s === `function`) {\n    s = s.call(ctx.dc, ctx.dc);\n  }\n\n  if (Array.isArray(s)) {\n    s = s.filter(a => a && typeof a === `string`);\n  }\n\n  if (typeof s === `string` || Array.isArray(s) && s.length) {\n    client.query(npm.formatting.as.format(`SET search_path TO $1:name`, [s]), err => {\n      // istanbul ignore if;\n      if (err) {\n        // This is unlikely to ever happen, unless the connection is created faulty,\n        // and fails on the very first query, which is impossible to test automatically.\n        throw err;\n      }\n    });\n  }\n}\n\nmodule.exports = config => ({\n  pool: (ctx, db) => poolConnect(ctx, db, config),\n  direct: ctx => directConnect(ctx, config)\n});","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg-promise/lib/connect.js"],"names":["Events","require","ColorConsole","npm","utils","text","formatting","poolConnect","ctx","db","config","promise","resolve","reject","p","$pool","ending","$destroy","err","Error","poolDestroyed","error","options","dc","connect","client","cn","getSafeConnection","$useCount","Object","defineProperty","value","configurable","enumerable","writable","setSchema","setCtx","end","lockClientEnd","on","onError","useCount","release","kill","$connectionError","disconnect","removeListener","directConnect","pgp","pg","Client","$ctx","cnOptions","onLost","notified","call","start","e","stack","doNotCall","clientEnd","getLocalStack","s","schema","Array","isArray","filter","a","length","query","as","format","module","exports","pool","direct"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {Events} = require(`./events`);\r\nconst {ColorConsole} = require(`./utils/color`);\r\n\r\nconst npm = {\r\n    utils: require(`./utils`),\r\n    text: require(`./text`),\r\n    formatting: require(`./formatting`)\r\n};\r\n\r\nfunction poolConnect(ctx, db, config) {\r\n    return config.promise((resolve, reject) => {\r\n        const p = db.$pool;\r\n        if (p.ending) {\r\n            db.$destroy();\r\n            const err = new Error(npm.text.poolDestroyed);\r\n            Events.error(ctx.options, err, {\r\n                dc: ctx.dc\r\n            });\r\n            reject(err);\r\n            return;\r\n        }\r\n        p.connect((err, client) => {\r\n            if (err) {\r\n                Events.error(ctx.options, err, {\r\n                    cn: npm.utils.getSafeConnection(ctx.cn),\r\n                    dc: ctx.dc\r\n                });\r\n                reject(err);\r\n            } else {\r\n                if (`$useCount` in client) {\r\n                    client.$useCount++;\r\n                } else {\r\n                    Object.defineProperty(client, `$useCount`, {\r\n                        value: 0,\r\n                        configurable: false,\r\n                        enumerable: false,\r\n                        writable: true\r\n                    });\r\n                    setSchema(client, ctx);\r\n                }\r\n                setCtx(client, ctx);\r\n                const end = lockClientEnd(client);\r\n                client.on(`error`, onError);\r\n                resolve({\r\n                    client,\r\n                    useCount: client.$useCount,\r\n                    release(kill) {\r\n                        client.end = end;\r\n                        client.release(kill || client.$connectionError);\r\n                        Events.disconnect(ctx, client);\r\n                        client.removeListener(`error`, onError);\r\n                    }\r\n                });\r\n                Events.connect(ctx, client, client.$useCount);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nfunction directConnect(ctx, config) {\r\n    return config.promise((resolve, reject) => {\r\n        const client = new config.pgp.pg.Client(ctx.cn);\r\n        client.connect(err => {\r\n            if (err) {\r\n                Events.error(ctx.options, err, {\r\n                    cn: npm.utils.getSafeConnection(ctx.cn),\r\n                    dc: ctx.dc\r\n                });\r\n                reject(err);\r\n            } else {\r\n                setSchema(client, ctx);\r\n                setCtx(client, ctx);\r\n                const end = lockClientEnd(client);\r\n                client.on(`error`, onError);\r\n                resolve({\r\n                    client,\r\n                    useCount: 0,\r\n                    release() {\r\n                        client.end = end;\r\n                        client.end();\r\n                        Events.disconnect(ctx, client);\r\n                        client.removeListener(`error`, onError);\r\n                    }\r\n                });\r\n                Events.connect(ctx, client, 0);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n// this event only happens when the connection is lost physically,\r\n// which cannot be tested automatically; removing from coverage:\r\n// istanbul ignore next\r\nfunction onError(err) {\r\n    const ctx = this.$ctx;\r\n    const cn = npm.utils.getSafeConnection(ctx.cn);\r\n    Events.error(ctx.options, err, {cn, dc: ctx.dc});\r\n    if (ctx.cnOptions && typeof ctx.cnOptions.onLost === `function` && !ctx.notified) {\r\n        try {\r\n            ctx.cnOptions.onLost.call(this, err, {\r\n                cn,\r\n                dc: ctx.dc,\r\n                start: ctx.start,\r\n                client: this\r\n            });\r\n        } catch (e) {\r\n            ColorConsole.error(e && e.stack || e);\r\n        }\r\n        ctx.notified = true;\r\n    }\r\n}\r\n\r\nfunction lockClientEnd(client) {\r\n    const end = client.end;\r\n    client.end = doNotCall => {\r\n        // This call can happen only in the following two cases:\r\n        // 1. the client made the call directly, against the library's documentation (invalid code)\r\n        // 2. connection with the server broke, and the pool is terminating all clients forcefully.\r\n        ColorConsole.error(`${npm.text.clientEnd}\\n${npm.utils.getLocalStack(1, 3)}\\n`);\r\n        if (!doNotCall) {\r\n            end.call(client);\r\n        }\r\n    };\r\n    return end;\r\n}\r\n\r\nfunction setCtx(client, ctx) {\r\n    Object.defineProperty(client, `$ctx`, {\r\n        value: ctx,\r\n        writable: true\r\n    });\r\n}\r\n\r\nfunction setSchema(client, ctx) {\r\n    let s = ctx.options.schema;\r\n    if (!s) {\r\n        return;\r\n    }\r\n    if (typeof s === `function`) {\r\n        s = s.call(ctx.dc, ctx.dc);\r\n    }\r\n    if (Array.isArray(s)) {\r\n        s = s.filter(a => a && typeof a === `string`);\r\n    }\r\n    if (typeof s === `string` || (Array.isArray(s) && s.length)) {\r\n        client.query(npm.formatting.as.format(`SET search_path TO $1:name`, [s]), err => {\r\n            // istanbul ignore if;\r\n            if (err) {\r\n                // This is unlikely to ever happen, unless the connection is created faulty,\r\n                // and fails on the very first query, which is impossible to test automatically.\r\n                throw err;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nmodule.exports = config => ({\r\n    pool: (ctx, db) => poolConnect(ctx, db, config),\r\n    direct: ctx => directConnect(ctx, config)\r\n});\r\n"]},"metadata":{},"sourceType":"script"}