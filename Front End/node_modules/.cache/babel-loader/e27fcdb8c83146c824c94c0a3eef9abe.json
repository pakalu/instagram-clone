{"ast":null,"code":"const {\n  SequenceError\n} = require('../errors/sequence');\n/**\r\n * @method sequence\r\n * @description\r\n * Resolves a dynamic sequence of [mixed values]{@tutorial mixed}.\r\n *\r\n * The method acquires [mixed values]{@tutorial mixed} from the `source` function, one at a time, and resolves them,\r\n * till either no more values left in the sequence or an error/reject occurs.\r\n *\r\n * It supports both [linked and detached sequencing]{@tutorial sequencing}.\r\n *\r\n * @param {Function|generator} source\r\n * Expected to return the next [mixed value]{@tutorial mixed} to be resolved. Returning or resolving\r\n * with `undefined` ends the sequence, and the method resolves.\r\n *\r\n * Parameters:\r\n *  - `index` = current request index in the sequence\r\n *  - `data` = resolved data from the previous call (`undefined` when `index=0`)\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.SequenceError SequenceError}, which will have property `source` set.\r\n *\r\n * Passing in anything other than a function will reject with {@link external:TypeError TypeError} = `Parameter 'source' must be a function.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.dest=null]\r\n * Optional destination function (or generator), to receive resolved data for each index,\r\n * process it and respond as required.\r\n *\r\n * Parameters:\r\n *  - `index` = index of the resolved data in the sequence\r\n *  - `data` = the data resolved\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise object, if data processing is done asynchronously.\r\n * If a promise is returned, the method will not request another value from the `source` function,\r\n * until the promise has been resolved (the resolved value is ignored).\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.SequenceError SequenceError}, which will have property `dest` set.\r\n *\r\n * @param {Number} [options.limit=0]\r\n * Limits the maximum size of the sequence. If the value is greater than 0, the method will\r\n * successfully resolve once the specified limit has been reached.\r\n *\r\n * When `limit` isn't specified (default), the sequence is unlimited, and it will continue\r\n * till one of the following occurs:\r\n *  - `source` either returns or resolves with `undefined`\r\n *  - either `source` or `dest` functions throw an error or return a rejected promise\r\n *\r\n * @param {Boolean} [options.track=false]\r\n * Changes the type of data to be resolved by this method. By default, it is `false`\r\n * (see the return result). When set to be `true`, the method tracks/collects all resolved data\r\n * into an array internally, and resolves with that array once the method has finished successfully.\r\n *\r\n * It must be used with caution, as to the size of the sequence, because accumulating data for\r\n * a very large sequence can result in consuming too much memory.\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When successful, the resolved data depends on parameter `track`. When `track` is `false`\r\n * (default), the method resolves with object `{total, duration}`:\r\n *  - `total` = number of values resolved by the sequence\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When `track` is `true`, the method resolves with an array of all the data that has been resolved,\r\n * the same way that the standard $[promise.all] resolves. In addition, the array comes extended with\r\n * a hidden read-only property `duration` - number of milliseconds consumed by the method.\r\n *\r\n * When the method fails, it rejects with {@link errors.SequenceError SequenceError}.\r\n */\n\n\nfunction sequence(source, options, config) {\n  const $p = config.promise,\n        utils = config.utils;\n\n  if (typeof source !== 'function') {\n    return $p.reject(new TypeError('Parameter \\'source\\' must be a function.'));\n  }\n\n  source = utils.wrap(source);\n  options = options || {};\n  const limit = options.limit > 0 ? parseInt(options.limit) : 0,\n        dest = utils.wrap(options.dest),\n        self = this,\n        start = Date.now();\n  let data,\n      srcTime,\n      destTime,\n      result = [];\n  return $p((resolve, reject) => {\n    function loop(idx) {\n      const srcNow = Date.now(),\n            srcDelay = idx ? srcNow - srcTime : undefined;\n      srcTime = srcNow;\n      utils.resolve.call(self, source, [idx, data, srcDelay], (value, delayed) => {\n        data = value;\n\n        if (data === undefined) {\n          success();\n        } else {\n          if (options.track) {\n            result.push(data);\n          }\n\n          if (dest) {\n            const destNow = Date.now(),\n                  destDelay = idx ? destNow - destTime : undefined;\n            let destResult;\n            destTime = destNow;\n\n            try {\n              destResult = dest.call(self, idx, data, destDelay);\n            } catch (e) {\n              fail({\n                error: e,\n                dest: data\n              }, 3, dest.name);\n              return;\n            }\n\n            if (utils.isPromise(destResult)) {\n              destResult.then(() => {\n                next(true);\n                return null; // this dummy return is just to prevent Bluebird warnings;\n              }).catch(error => {\n                fail({\n                  error: error,\n                  dest: data\n                }, 2, dest.name);\n              });\n            } else {\n              next(delayed);\n            }\n          } else {\n            next(delayed);\n          }\n        }\n      }, (reason, isRej) => {\n        fail({\n          error: reason,\n          source: data\n        }, isRej ? 0 : 1, source.name);\n      });\n\n      function next(delayed) {\n        if (limit === ++idx) {\n          success();\n        } else {\n          if (delayed) {\n            loop(idx);\n          } else {\n            $p.resolve().then(() => {\n              loop(idx);\n              return null; // this dummy return is just to prevent Bluebird warnings;\n            });\n          }\n        }\n      }\n\n      function success() {\n        const length = Date.now() - start;\n\n        if (options.track) {\n          utils.extend(result, 'duration', length);\n        } else {\n          result = {\n            total: idx,\n            duration: length\n          };\n        }\n\n        resolve(result);\n      }\n\n      function fail(reason, code, cbName) {\n        reason.index = idx;\n        reject(new SequenceError(reason, code, cbName, Date.now() - start));\n      }\n    }\n\n    loop(0);\n  });\n}\n\nmodule.exports = function (config) {\n  return function (source, options) {\n    return sequence.call(this, source, options, config);\n  };\n};","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/spex/lib/ext/sequence.js"],"names":["SequenceError","require","sequence","source","options","config","$p","promise","utils","reject","TypeError","wrap","limit","parseInt","dest","self","start","Date","now","data","srcTime","destTime","result","resolve","loop","idx","srcNow","srcDelay","undefined","call","value","delayed","success","track","push","destNow","destDelay","destResult","e","fail","error","name","isPromise","then","next","catch","reason","isRej","length","extend","total","duration","code","cbName","index","module","exports"],"mappings":"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","sourcesContent":["const {SequenceError} = require('../errors/sequence');\r\n\r\n/**\r\n * @method sequence\r\n * @description\r\n * Resolves a dynamic sequence of [mixed values]{@tutorial mixed}.\r\n *\r\n * The method acquires [mixed values]{@tutorial mixed} from the `source` function, one at a time, and resolves them,\r\n * till either no more values left in the sequence or an error/reject occurs.\r\n *\r\n * It supports both [linked and detached sequencing]{@tutorial sequencing}.\r\n *\r\n * @param {Function|generator} source\r\n * Expected to return the next [mixed value]{@tutorial mixed} to be resolved. Returning or resolving\r\n * with `undefined` ends the sequence, and the method resolves.\r\n *\r\n * Parameters:\r\n *  - `index` = current request index in the sequence\r\n *  - `data` = resolved data from the previous call (`undefined` when `index=0`)\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.SequenceError SequenceError}, which will have property `source` set.\r\n *\r\n * Passing in anything other than a function will reject with {@link external:TypeError TypeError} = `Parameter 'source' must be a function.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.dest=null]\r\n * Optional destination function (or generator), to receive resolved data for each index,\r\n * process it and respond as required.\r\n *\r\n * Parameters:\r\n *  - `index` = index of the resolved data in the sequence\r\n *  - `data` = the data resolved\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise object, if data processing is done asynchronously.\r\n * If a promise is returned, the method will not request another value from the `source` function,\r\n * until the promise has been resolved (the resolved value is ignored).\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.SequenceError SequenceError}, which will have property `dest` set.\r\n *\r\n * @param {Number} [options.limit=0]\r\n * Limits the maximum size of the sequence. If the value is greater than 0, the method will\r\n * successfully resolve once the specified limit has been reached.\r\n *\r\n * When `limit` isn't specified (default), the sequence is unlimited, and it will continue\r\n * till one of the following occurs:\r\n *  - `source` either returns or resolves with `undefined`\r\n *  - either `source` or `dest` functions throw an error or return a rejected promise\r\n *\r\n * @param {Boolean} [options.track=false]\r\n * Changes the type of data to be resolved by this method. By default, it is `false`\r\n * (see the return result). When set to be `true`, the method tracks/collects all resolved data\r\n * into an array internally, and resolves with that array once the method has finished successfully.\r\n *\r\n * It must be used with caution, as to the size of the sequence, because accumulating data for\r\n * a very large sequence can result in consuming too much memory.\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When successful, the resolved data depends on parameter `track`. When `track` is `false`\r\n * (default), the method resolves with object `{total, duration}`:\r\n *  - `total` = number of values resolved by the sequence\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When `track` is `true`, the method resolves with an array of all the data that has been resolved,\r\n * the same way that the standard $[promise.all] resolves. In addition, the array comes extended with\r\n * a hidden read-only property `duration` - number of milliseconds consumed by the method.\r\n *\r\n * When the method fails, it rejects with {@link errors.SequenceError SequenceError}.\r\n */\r\nfunction sequence(source, options, config) {\r\n\r\n    const $p = config.promise, utils = config.utils;\r\n\r\n    if (typeof source !== 'function') {\r\n        return $p.reject(new TypeError('Parameter \\'source\\' must be a function.'));\r\n    }\r\n\r\n    source = utils.wrap(source);\r\n\r\n    options = options || {};\r\n\r\n    const limit = (options.limit > 0) ? parseInt(options.limit) : 0,\r\n        dest = utils.wrap(options.dest),\r\n        self = this, start = Date.now();\r\n    let data, srcTime, destTime, result = [];\r\n\r\n    return $p((resolve, reject) => {\r\n\r\n        function loop(idx) {\r\n            const srcNow = Date.now(),\r\n                srcDelay = idx ? (srcNow - srcTime) : undefined;\r\n            srcTime = srcNow;\r\n            utils.resolve.call(self, source, [idx, data, srcDelay], (value, delayed) => {\r\n                data = value;\r\n                if (data === undefined) {\r\n                    success();\r\n                } else {\r\n                    if (options.track) {\r\n                        result.push(data);\r\n                    }\r\n                    if (dest) {\r\n                        const destNow = Date.now(),\r\n                            destDelay = idx ? (destNow - destTime) : undefined;\r\n                        let destResult;\r\n                        destTime = destNow;\r\n                        try {\r\n                            destResult = dest.call(self, idx, data, destDelay);\r\n                        } catch (e) {\r\n                            fail({\r\n                                error: e,\r\n                                dest: data\r\n                            }, 3, dest.name);\r\n                            return;\r\n                        }\r\n                        if (utils.isPromise(destResult)) {\r\n                            destResult\r\n                                .then(() => {\r\n                                    next(true);\r\n                                    return null; // this dummy return is just to prevent Bluebird warnings;\r\n                                })\r\n                                .catch(error => {\r\n                                    fail({\r\n                                        error: error,\r\n                                        dest: data\r\n                                    }, 2, dest.name);\r\n                                });\r\n                        } else {\r\n                            next(delayed);\r\n                        }\r\n                    } else {\r\n                        next(delayed);\r\n                    }\r\n                }\r\n            }, (reason, isRej) => {\r\n                fail({\r\n                    error: reason,\r\n                    source: data\r\n                }, isRej ? 0 : 1, source.name);\r\n            });\r\n\r\n            function next(delayed) {\r\n                if (limit === ++idx) {\r\n                    success();\r\n                } else {\r\n                    if (delayed) {\r\n                        loop(idx);\r\n                    } else {\r\n                        $p.resolve()\r\n                            .then(() => {\r\n                                loop(idx);\r\n                                return null; // this dummy return is just to prevent Bluebird warnings;\r\n                            });\r\n                    }\r\n                }\r\n            }\r\n\r\n            function success() {\r\n                const length = Date.now() - start;\r\n                if (options.track) {\r\n                    utils.extend(result, 'duration', length);\r\n                } else {\r\n                    result = {\r\n                        total: idx,\r\n                        duration: length\r\n                    };\r\n                }\r\n                resolve(result);\r\n            }\r\n\r\n            function fail(reason, code, cbName) {\r\n                reason.index = idx;\r\n                reject(new SequenceError(reason, code, cbName, Date.now() - start));\r\n            }\r\n        }\r\n\r\n        loop(0);\r\n    });\r\n}\r\n\r\nmodule.exports = function (config) {\r\n    return function (source, options) {\r\n        return sequence.call(this, source, options, config);\r\n    };\r\n};\r\n"]},"metadata":{},"sourceType":"script"}