{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\nconst {\n  ServerFormatting\n} = require(`./server-formatting`);\n\nconst {\n  ParameterizedQueryError\n} = require(`../errors`);\n\nconst {\n  QueryFile\n} = require(`../query-file`);\n\nconst {\n  assertOptions\n} = require(`assert-options`);\n\nconst npm = {\n  EOL: require(`os`).EOL,\n  utils: require(`../utils`)\n};\n/**\r\n * @class ParameterizedQuery\r\n * @description\r\n * Constructs a new {@link ParameterizedQuery} object. All properties can also be set after the object's construction.\r\n *\r\n * This type extends the basic `{text, values}` object, i.e. when the basic object is used with a query method,\r\n * a new {@link ParameterizedQuery} object is created in its place.\r\n *\r\n * The type can be used in place of the `query` parameter, with any query method directly.\r\n *\r\n * The type is available from the library's root: `pgp.ParameterizedQuery`.\r\n *\r\n * @param {string|QueryFile|Object} [options]\r\n * Object configuration options / properties.\r\n *\r\n * @param {string|QueryFile} [options.text] - See property {@link ParameterizedQuery#text text}.\r\n * @param {array} [options.values] - See property {@link ParameterizedQuery#values values}.\r\n * @param {boolean} [options.binary] - See property {@link ParameterizedQuery#binary binary}.\r\n * @param {string} [options.rowMode] - See property {@link ParameterizedQuery#rowMode rowMode}.\r\n *\r\n * @returns {ParameterizedQuery}\r\n *\r\n * @see\r\n * {@link errors.ParameterizedQueryError ParameterizedQueryError}\r\n *\r\n * @example\r\n *\r\n * const PQ = require('pg-promise').ParameterizedQuery;\r\n *\r\n * // Creating a complete Parameterized Query with parameters:\r\n * const findUser = new PQ({text: 'SELECT * FROM Users WHERE id = $1', values: [123]});\r\n *\r\n * db.one(findUser)\r\n *     .then(user => {\r\n *         // user found;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * @example\r\n *\r\n * const PQ = require('pg-promise').ParameterizedQuery;\r\n *\r\n * // Creating a reusable Parameterized Query without values:\r\n * const addUser = new PQ('INSERT INTO Users(name, age) VALUES($1, $2)');\r\n *\r\n * // setting values explicitly:\r\n * addUser.values = ['John', 30];\r\n *\r\n * db.none(addUser)\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error=> {\r\n *         // error;\r\n *     });\r\n *\r\n * // setting values implicitly, by passing them into the query method:\r\n * db.none(addUser, ['Mike', 25])\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error=> {\r\n *         // error;\r\n *     });\r\n */\n\nclass ParameterizedQuery extends ServerFormatting {\n  constructor(options) {\n    if (typeof options === `string` || options instanceof QueryFile) {\n      options = {\n        text: options\n      };\n    } else {\n      options = assertOptions(options, [`text`, `values`, `binary`, `rowMode`]);\n    }\n\n    super(options);\n  }\n\n}\n/**\r\n * @method ParameterizedQuery#parse\r\n * @description\r\n * Parses the current object and returns a simple `{text, values}`, if successful,\r\n * or else it returns a {@link errors.ParameterizedQueryError ParameterizedQueryError} object.\r\n *\r\n * This method is primarily for internal use by the library.\r\n *\r\n * @returns {{text, values}|errors.ParameterizedQueryError}\r\n */\n\n\nParameterizedQuery.prototype.parse = function () {\n  const _i = this._inner,\n        options = _i.options;\n  const qf = options.text instanceof QueryFile ? options.text : null;\n\n  if (!_i.changed && !qf) {\n    return _i.target;\n  }\n\n  const errors = [],\n        values = _i.target.values;\n  _i.target = {\n    text: options.text\n  };\n  _i.changed = true;\n  _i.currentError = undefined;\n\n  if (qf) {\n    qf.prepare();\n\n    if (qf.error) {\n      errors.push(qf.error);\n    } else {\n      _i.target.text = qf[QueryFile.$query];\n    }\n  }\n\n  if (!npm.utils.isText(_i.target.text)) {\n    errors.push(`Property 'text' must be a non-empty text string.`);\n  }\n\n  if (!npm.utils.isNull(values)) {\n    _i.target.values = values;\n  }\n\n  if (options.binary !== undefined) {\n    _i.target.binary = !!options.binary;\n  }\n\n  if (options.rowMode !== undefined) {\n    _i.target.rowMode = options.rowMode;\n  }\n\n  if (errors.length) {\n    return _i.currentError = new ParameterizedQueryError(errors[0], _i.target);\n  }\n\n  _i.changed = false;\n  return _i.target;\n};\n/**\r\n * @method ParameterizedQuery#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object's current state.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\n\n\nParameterizedQuery.prototype.toString = function (level) {\n  level = level > 0 ? parseInt(level) : 0;\n  const gap = npm.utils.messageGap(level + 1);\n  const pq = this.parse();\n  const lines = [`ParameterizedQuery {`];\n\n  if (npm.utils.isText(pq.text)) {\n    lines.push(gap + `text: \"` + pq.text + `\"`);\n  }\n\n  if (this.values !== undefined) {\n    lines.push(gap + `values: ` + npm.utils.toJson(this.values));\n  }\n\n  if (this.binary !== undefined) {\n    lines.push(gap + `binary: ` + npm.utils.toJson(this.binary));\n  }\n\n  if (this.rowMode !== undefined) {\n    lines.push(gap + `rowMode: ` + npm.utils.toJson(this.rowMode));\n  }\n\n  if (this.error !== undefined) {\n    lines.push(gap + `error: ` + this.error.toString(level + 1));\n  }\n\n  lines.push(npm.utils.messageGap(level) + `}`);\n  return lines.join(npm.EOL);\n};\n\nmodule.exports = {\n  ParameterizedQuery\n};\n/**\r\n * @name ParameterizedQuery#text\r\n * @type {string|QueryFile}\r\n * @description\r\n * A non-empty query string or a {@link QueryFile} object.\r\n *\r\n * Only the basic variables (`$1`, `$2`, etc) can be used in the query, because _Parameterized Queries_\r\n * are formatted on the server side.\r\n */\n\n/**\r\n * @name ParameterizedQuery#values\r\n * @type {array}\r\n * @description\r\n * Query formatting parameters, depending on the type:\r\n *\r\n * - `null` / `undefined` means the query has no formatting parameters\r\n * - `Array` - it is an array of formatting parameters\r\n * - None of the above, means it is a single formatting value, which\r\n *   is then automatically wrapped into an array\r\n */\n\n/**\r\n * @name ParameterizedQuery#binary\r\n * @type {boolean}\r\n * @default undefined\r\n * @description\r\n * Activates binary result mode. The default is the text mode.\r\n *\r\n * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}\r\n */\n\n/**\r\n * @name ParameterizedQuery#rowMode\r\n * @type {string}\r\n * @default undefined\r\n * @description\r\n * Changes the way data arrives to the client, with only one value supported by $[pg]:\r\n *  - `array` will make all data rows arrive as arrays of values. By default, rows arrive as objects.\r\n */\n\n/**\r\n * @name ParameterizedQuery#error\r\n * @type {errors.ParameterizedQueryError}\r\n * @default undefined\r\n * @readonly\r\n * @description\r\n * When in an error state, it is set to a {@link errors.ParameterizedQueryError ParameterizedQueryError} object. Otherwise, it is `undefined`.\r\n *\r\n * This property is primarily for internal use by the library.\r\n */","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg-promise/lib/types/parameterized-query.js"],"names":["ServerFormatting","require","ParameterizedQueryError","QueryFile","assertOptions","npm","EOL","utils","ParameterizedQuery","constructor","options","text","prototype","parse","_i","_inner","qf","changed","target","errors","values","currentError","undefined","prepare","error","push","$query","isText","isNull","binary","rowMode","length","toString","level","parseInt","gap","messageGap","pq","lines","toJson","join","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {ServerFormatting} = require(`./server-formatting`);\r\nconst {ParameterizedQueryError} = require(`../errors`);\r\nconst {QueryFile} = require(`../query-file`);\r\nconst {assertOptions} = require(`assert-options`);\r\n\r\nconst npm = {\r\n    EOL: require(`os`).EOL,\r\n    utils: require(`../utils`)\r\n};\r\n\r\n/**\r\n * @class ParameterizedQuery\r\n * @description\r\n * Constructs a new {@link ParameterizedQuery} object. All properties can also be set after the object's construction.\r\n *\r\n * This type extends the basic `{text, values}` object, i.e. when the basic object is used with a query method,\r\n * a new {@link ParameterizedQuery} object is created in its place.\r\n *\r\n * The type can be used in place of the `query` parameter, with any query method directly.\r\n *\r\n * The type is available from the library's root: `pgp.ParameterizedQuery`.\r\n *\r\n * @param {string|QueryFile|Object} [options]\r\n * Object configuration options / properties.\r\n *\r\n * @param {string|QueryFile} [options.text] - See property {@link ParameterizedQuery#text text}.\r\n * @param {array} [options.values] - See property {@link ParameterizedQuery#values values}.\r\n * @param {boolean} [options.binary] - See property {@link ParameterizedQuery#binary binary}.\r\n * @param {string} [options.rowMode] - See property {@link ParameterizedQuery#rowMode rowMode}.\r\n *\r\n * @returns {ParameterizedQuery}\r\n *\r\n * @see\r\n * {@link errors.ParameterizedQueryError ParameterizedQueryError}\r\n *\r\n * @example\r\n *\r\n * const PQ = require('pg-promise').ParameterizedQuery;\r\n *\r\n * // Creating a complete Parameterized Query with parameters:\r\n * const findUser = new PQ({text: 'SELECT * FROM Users WHERE id = $1', values: [123]});\r\n *\r\n * db.one(findUser)\r\n *     .then(user => {\r\n *         // user found;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * @example\r\n *\r\n * const PQ = require('pg-promise').ParameterizedQuery;\r\n *\r\n * // Creating a reusable Parameterized Query without values:\r\n * const addUser = new PQ('INSERT INTO Users(name, age) VALUES($1, $2)');\r\n *\r\n * // setting values explicitly:\r\n * addUser.values = ['John', 30];\r\n *\r\n * db.none(addUser)\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error=> {\r\n *         // error;\r\n *     });\r\n *\r\n * // setting values implicitly, by passing them into the query method:\r\n * db.none(addUser, ['Mike', 25])\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error=> {\r\n *         // error;\r\n *     });\r\n */\r\nclass ParameterizedQuery extends ServerFormatting {\r\n    constructor(options) {\r\n        if (typeof options === `string` || options instanceof QueryFile) {\r\n            options = {\r\n                text: options\r\n            };\r\n        } else {\r\n            options = assertOptions(options, [`text`, `values`, `binary`, `rowMode`]);\r\n        }\r\n        super(options);\r\n    }\r\n}\r\n\r\n/**\r\n * @method ParameterizedQuery#parse\r\n * @description\r\n * Parses the current object and returns a simple `{text, values}`, if successful,\r\n * or else it returns a {@link errors.ParameterizedQueryError ParameterizedQueryError} object.\r\n *\r\n * This method is primarily for internal use by the library.\r\n *\r\n * @returns {{text, values}|errors.ParameterizedQueryError}\r\n */\r\nParameterizedQuery.prototype.parse = function () {\r\n\r\n    const _i = this._inner, options = _i.options;\r\n    const qf = options.text instanceof QueryFile ? options.text : null;\r\n\r\n    if (!_i.changed && !qf) {\r\n        return _i.target;\r\n    }\r\n\r\n    const errors = [], values = _i.target.values;\r\n    _i.target = {\r\n        text: options.text\r\n    };\r\n    _i.changed = true;\r\n    _i.currentError = undefined;\r\n\r\n    if (qf) {\r\n        qf.prepare();\r\n        if (qf.error) {\r\n            errors.push(qf.error);\r\n        } else {\r\n            _i.target.text = qf[QueryFile.$query];\r\n        }\r\n    }\r\n\r\n    if (!npm.utils.isText(_i.target.text)) {\r\n        errors.push(`Property 'text' must be a non-empty text string.`);\r\n    }\r\n\r\n    if (!npm.utils.isNull(values)) {\r\n        _i.target.values = values;\r\n    }\r\n\r\n    if (options.binary !== undefined) {\r\n        _i.target.binary = !!options.binary;\r\n    }\r\n\r\n    if (options.rowMode !== undefined) {\r\n        _i.target.rowMode = options.rowMode;\r\n    }\r\n\r\n    if (errors.length) {\r\n        return _i.currentError = new ParameterizedQueryError(errors[0], _i.target);\r\n    }\r\n\r\n    _i.changed = false;\r\n\r\n    return _i.target;\r\n};\r\n\r\n/**\r\n * @method ParameterizedQuery#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object's current state.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nParameterizedQuery.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    const gap = npm.utils.messageGap(level + 1);\r\n    const pq = this.parse();\r\n    const lines = [\r\n        `ParameterizedQuery {`\r\n    ];\r\n    if (npm.utils.isText(pq.text)) {\r\n        lines.push(gap + `text: \"` + pq.text + `\"`);\r\n    }\r\n    if (this.values !== undefined) {\r\n        lines.push(gap + `values: ` + npm.utils.toJson(this.values));\r\n    }\r\n    if (this.binary !== undefined) {\r\n        lines.push(gap + `binary: ` + npm.utils.toJson(this.binary));\r\n    }\r\n    if (this.rowMode !== undefined) {\r\n        lines.push(gap + `rowMode: ` + npm.utils.toJson(this.rowMode));\r\n    }\r\n    if (this.error !== undefined) {\r\n        lines.push(gap + `error: ` + this.error.toString(level + 1));\r\n    }\r\n    lines.push(npm.utils.messageGap(level) + `}`);\r\n    return lines.join(npm.EOL);\r\n};\r\n\r\nmodule.exports = {ParameterizedQuery};\r\n\r\n/**\r\n * @name ParameterizedQuery#text\r\n * @type {string|QueryFile}\r\n * @description\r\n * A non-empty query string or a {@link QueryFile} object.\r\n *\r\n * Only the basic variables (`$1`, `$2`, etc) can be used in the query, because _Parameterized Queries_\r\n * are formatted on the server side.\r\n */\r\n\r\n/**\r\n * @name ParameterizedQuery#values\r\n * @type {array}\r\n * @description\r\n * Query formatting parameters, depending on the type:\r\n *\r\n * - `null` / `undefined` means the query has no formatting parameters\r\n * - `Array` - it is an array of formatting parameters\r\n * - None of the above, means it is a single formatting value, which\r\n *   is then automatically wrapped into an array\r\n */\r\n\r\n/**\r\n * @name ParameterizedQuery#binary\r\n * @type {boolean}\r\n * @default undefined\r\n * @description\r\n * Activates binary result mode. The default is the text mode.\r\n *\r\n * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}\r\n */\r\n\r\n/**\r\n * @name ParameterizedQuery#rowMode\r\n * @type {string}\r\n * @default undefined\r\n * @description\r\n * Changes the way data arrives to the client, with only one value supported by $[pg]:\r\n *  - `array` will make all data rows arrive as arrays of values. By default, rows arrive as objects.\r\n */\r\n\r\n/**\r\n * @name ParameterizedQuery#error\r\n * @type {errors.ParameterizedQueryError}\r\n * @default undefined\r\n * @readonly\r\n * @description\r\n * When in an error state, it is set to a {@link errors.ParameterizedQueryError ParameterizedQueryError} object. Otherwise, it is `undefined`.\r\n *\r\n * This property is primarily for internal use by the library.\r\n */\r\n"]},"metadata":{},"sourceType":"script"}