{"ast":null,"code":"const {\n  BatchError\n} = require('../errors/batch');\n/**\r\n * @method batch\r\n * @description\r\n * Settles (resolves or rejects) every [mixed value]{@tutorial mixed} in the input array.\r\n *\r\n * The method resolves with an array of results, the same as the standard $[promise.all],\r\n * while providing comprehensive error details in case of a reject, in the form of\r\n * type {@link errors.BatchError BatchError}.\r\n *\r\n * @param {Array} values\r\n * Array of [mixed values]{@tutorial mixed} (it can be empty), to be resolved asynchronously, in no particular order.\r\n *\r\n * Passing in anything other than an array will reject with {@link external:TypeError TypeError} =\r\n * `Method 'batch' requires an array of values.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.cb]\r\n * Optional callback (or generator) to receive the result for each settled value.\r\n *\r\n * Callback Parameters:\r\n *  - `index` = index of the value in the source array\r\n *  - `success` - indicates whether the value was resolved (`true`), or rejected (`false`)\r\n *  - `result` = resolved data, if `success`=`true`, or else the rejection reason\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise to indicate that notifications are handled asynchronously.\r\n * And if the returned promise resolves, it signals a successful handling, while any resolved\r\n * data is ignored.\r\n *\r\n * If the function returns a rejected promise or throws an error, the entire method rejects\r\n * with {@link errors.BatchError BatchError} where the corresponding value in property `data`\r\n * is set to `{success, result, origin}`:\r\n *  - `success` = `false`\r\n *  - `result` = the rejection reason or the error thrown by the notification callback\r\n *  - `origin` = the original data passed into the callback as object `{success, result}`\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * The method resolves with an array of individual resolved results, the same as the standard $[promise.all].\r\n * In addition, the array is extended with a hidden read-only property `duration` - number of milliseconds\r\n * spent resolving all the data.\r\n *\r\n * The method rejects with {@link errors.BatchError BatchError} when any of the following occurs:\r\n *  - one or more values rejected or threw an error while being resolved as a [mixed value]{@tutorial mixed}\r\n *  - notification callback `cb` returned a rejected promise or threw an error\r\n *\r\n */\n\n\nfunction batch(values, options, config) {\n  const $p = config.promise,\n        utils = config.utils;\n\n  if (!Array.isArray(values)) {\n    return $p.reject(new TypeError('Method \\'batch\\' requires an array of values.'));\n  }\n\n  if (!values.length) {\n    const empty = [];\n    utils.extend(empty, 'duration', 0);\n    return $p.resolve(empty);\n  }\n\n  options = options || {};\n  const cb = utils.wrap(options.cb),\n        self = this,\n        start = Date.now();\n  return $p((resolve, reject) => {\n    let cbTime,\n        remaining = values.length;\n    const errors = [],\n          result = new Array(remaining);\n    values.forEach((item, i) => {\n      utils.resolve.call(self, item, null, data => {\n        result[i] = data;\n        step(i, true, data);\n      }, reason => {\n        result[i] = {\n          success: false,\n          result: reason\n        };\n        errors.push(i);\n        step(i, false, reason);\n      });\n    });\n\n    function step(idx, pass, data) {\n      if (cb) {\n        const cbNow = Date.now(),\n              cbDelay = idx ? cbNow - cbTime : undefined;\n        let cbResult;\n        cbTime = cbNow;\n\n        try {\n          cbResult = cb.call(self, idx, pass, data, cbDelay);\n        } catch (e) {\n          setError(e);\n        }\n\n        if (utils.isPromise(cbResult)) {\n          cbResult.then(check).catch(error => {\n            setError(error);\n            check();\n          });\n        } else {\n          check();\n        }\n      } else {\n        check();\n      }\n\n      function setError(e) {\n        const r = pass ? {\n          success: false\n        } : result[idx];\n\n        if (pass) {\n          result[idx] = r;\n          errors.push(idx);\n        }\n\n        r.result = e;\n        r.origin = {\n          success: pass,\n          result: data\n        };\n      }\n\n      function check() {\n        if (! --remaining) {\n          if (errors.length) {\n            errors.sort();\n\n            if (errors.length < result.length) {\n              for (let i = 0, k = 0; i < result.length; i++) {\n                if (i === errors[k]) {\n                  k++;\n                } else {\n                  result[i] = {\n                    success: true,\n                    result: result[i]\n                  };\n                }\n              }\n            }\n\n            reject(new BatchError(result, errors, Date.now() - start));\n          } else {\n            utils.extend(result, 'duration', Date.now() - start);\n            resolve(result);\n          }\n        }\n\n        return null; // this dummy return is just to prevent Bluebird warnings;\n      }\n    }\n  });\n}\n\nmodule.exports = function (config) {\n  return function (values, options) {\n    return batch.call(this, values, options, config);\n  };\n};","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/spex/lib/ext/batch.js"],"names":["BatchError","require","batch","values","options","config","$p","promise","utils","Array","isArray","reject","TypeError","length","empty","extend","resolve","cb","wrap","self","start","Date","now","cbTime","remaining","errors","result","forEach","item","i","call","data","step","reason","success","push","idx","pass","cbNow","cbDelay","undefined","cbResult","e","setError","isPromise","then","check","catch","error","r","origin","sort","k","module","exports"],"mappings":"AAAA,MAAM;AAACA,EAAAA;AAAD,IAAeC,OAAO,CAAC,iBAAD,CAA5B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmDA,SAASC,KAAT,CAAeC,MAAf,EAAuBC,OAAvB,EAAgCC,MAAhC,EAAwC;AAEpC,QAAMC,EAAE,GAAGD,MAAM,CAACE,OAAlB;AAAA,QAA2BC,KAAK,GAAGH,MAAM,CAACG,KAA1C;;AAEA,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcP,MAAd,CAAL,EAA4B;AACxB,WAAOG,EAAE,CAACK,MAAH,CAAU,IAAIC,SAAJ,CAAc,+CAAd,CAAV,CAAP;AACH;;AAED,MAAI,CAACT,MAAM,CAACU,MAAZ,EAAoB;AAChB,UAAMC,KAAK,GAAG,EAAd;AACAN,IAAAA,KAAK,CAACO,MAAN,CAAaD,KAAb,EAAoB,UAApB,EAAgC,CAAhC;AACA,WAAOR,EAAE,CAACU,OAAH,CAAWF,KAAX,CAAP;AACH;;AAEDV,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,QAAMa,EAAE,GAAGT,KAAK,CAACU,IAAN,CAAWd,OAAO,CAACa,EAAnB,CAAX;AAAA,QACIE,IAAI,GAAG,IADX;AAAA,QACiBC,KAAK,GAAGC,IAAI,CAACC,GAAL,EADzB;AAGA,SAAOhB,EAAE,CAAC,CAACU,OAAD,EAAUL,MAAV,KAAqB;AAC3B,QAAIY,MAAJ;AAAA,QAAYC,SAAS,GAAGrB,MAAM,CAACU,MAA/B;AACA,UAAMY,MAAM,GAAG,EAAf;AAAA,UAAmBC,MAAM,GAAG,IAAIjB,KAAJ,CAAUe,SAAV,CAA5B;AACArB,IAAAA,MAAM,CAACwB,OAAP,CAAe,CAACC,IAAD,EAAOC,CAAP,KAAa;AACxBrB,MAAAA,KAAK,CAACQ,OAAN,CAAcc,IAAd,CAAmBX,IAAnB,EAAyBS,IAAzB,EAA+B,IAA/B,EAAqCG,IAAI,IAAI;AACzCL,QAAAA,MAAM,CAACG,CAAD,CAAN,GAAYE,IAAZ;AACAC,QAAAA,IAAI,CAACH,CAAD,EAAI,IAAJ,EAAUE,IAAV,CAAJ;AACH,OAHD,EAGGE,MAAM,IAAI;AACTP,QAAAA,MAAM,CAACG,CAAD,CAAN,GAAY;AAACK,UAAAA,OAAO,EAAE,KAAV;AAAiBR,UAAAA,MAAM,EAAEO;AAAzB,SAAZ;AACAR,QAAAA,MAAM,CAACU,IAAP,CAAYN,CAAZ;AACAG,QAAAA,IAAI,CAACH,CAAD,EAAI,KAAJ,EAAWI,MAAX,CAAJ;AACH,OAPD;AAQH,KATD;;AAWA,aAASD,IAAT,CAAcI,GAAd,EAAmBC,IAAnB,EAAyBN,IAAzB,EAA+B;AAC3B,UAAId,EAAJ,EAAQ;AACJ,cAAMqB,KAAK,GAAGjB,IAAI,CAACC,GAAL,EAAd;AAAA,cACIiB,OAAO,GAAGH,GAAG,GAAIE,KAAK,GAAGf,MAAZ,GAAsBiB,SADvC;AAEA,YAAIC,QAAJ;AACAlB,QAAAA,MAAM,GAAGe,KAAT;;AACA,YAAI;AACAG,UAAAA,QAAQ,GAAGxB,EAAE,CAACa,IAAH,CAAQX,IAAR,EAAciB,GAAd,EAAmBC,IAAnB,EAAyBN,IAAzB,EAA+BQ,OAA/B,CAAX;AACH,SAFD,CAEE,OAAOG,CAAP,EAAU;AACRC,UAAAA,QAAQ,CAACD,CAAD,CAAR;AACH;;AACD,YAAIlC,KAAK,CAACoC,SAAN,CAAgBH,QAAhB,CAAJ,EAA+B;AAC3BA,UAAAA,QAAQ,CACHI,IADL,CACUC,KADV,EAEKC,KAFL,CAEWC,KAAK,IAAI;AACZL,YAAAA,QAAQ,CAACK,KAAD,CAAR;AACAF,YAAAA,KAAK;AACR,WALL;AAMH,SAPD,MAOO;AACHA,UAAAA,KAAK;AACR;AACJ,OApBD,MAoBO;AACHA,QAAAA,KAAK;AACR;;AAED,eAASH,QAAT,CAAkBD,CAAlB,EAAqB;AACjB,cAAMO,CAAC,GAAGZ,IAAI,GAAG;AAACH,UAAAA,OAAO,EAAE;AAAV,SAAH,GAAsBR,MAAM,CAACU,GAAD,CAA1C;;AACA,YAAIC,IAAJ,EAAU;AACNX,UAAAA,MAAM,CAACU,GAAD,CAAN,GAAca,CAAd;AACAxB,UAAAA,MAAM,CAACU,IAAP,CAAYC,GAAZ;AACH;;AACDa,QAAAA,CAAC,CAACvB,MAAF,GAAWgB,CAAX;AACAO,QAAAA,CAAC,CAACC,MAAF,GAAW;AAAChB,UAAAA,OAAO,EAAEG,IAAV;AAAgBX,UAAAA,MAAM,EAAEK;AAAxB,SAAX;AACH;;AAED,eAASe,KAAT,GAAiB;AACb,YAAI,CAAC,GAAEtB,SAAP,EAAkB;AACd,cAAIC,MAAM,CAACZ,MAAX,EAAmB;AACfY,YAAAA,MAAM,CAAC0B,IAAP;;AACA,gBAAI1B,MAAM,CAACZ,MAAP,GAAgBa,MAAM,CAACb,MAA3B,EAAmC;AAC/B,mBAAK,IAAIgB,CAAC,GAAG,CAAR,EAAWuB,CAAC,GAAG,CAApB,EAAuBvB,CAAC,GAAGH,MAAM,CAACb,MAAlC,EAA0CgB,CAAC,EAA3C,EAA+C;AAC3C,oBAAIA,CAAC,KAAKJ,MAAM,CAAC2B,CAAD,CAAhB,EAAqB;AACjBA,kBAAAA,CAAC;AACJ,iBAFD,MAEO;AACH1B,kBAAAA,MAAM,CAACG,CAAD,CAAN,GAAY;AAACK,oBAAAA,OAAO,EAAE,IAAV;AAAgBR,oBAAAA,MAAM,EAAEA,MAAM,CAACG,CAAD;AAA9B,mBAAZ;AACH;AACJ;AACJ;;AACDlB,YAAAA,MAAM,CAAC,IAAIX,UAAJ,CAAe0B,MAAf,EAAuBD,MAAvB,EAA+BJ,IAAI,CAACC,GAAL,KAAaF,KAA5C,CAAD,CAAN;AACH,WAZD,MAYO;AACHZ,YAAAA,KAAK,CAACO,MAAN,CAAaW,MAAb,EAAqB,UAArB,EAAiCL,IAAI,CAACC,GAAL,KAAaF,KAA9C;AACAJ,YAAAA,OAAO,CAACU,MAAD,CAAP;AACH;AACJ;;AACD,eAAO,IAAP,CAnBa,CAmBA;AAChB;AACJ;AACJ,GAvEQ,CAAT;AAwEH;;AAED2B,MAAM,CAACC,OAAP,GAAiB,UAAUjD,MAAV,EAAkB;AAC/B,SAAO,UAAUF,MAAV,EAAkBC,OAAlB,EAA2B;AAC9B,WAAOF,KAAK,CAAC4B,IAAN,CAAW,IAAX,EAAiB3B,MAAjB,EAAyBC,OAAzB,EAAkCC,MAAlC,CAAP;AACH,GAFD;AAGH,CAJD","sourcesContent":["const {BatchError} = require('../errors/batch');\r\n\r\n/**\r\n * @method batch\r\n * @description\r\n * Settles (resolves or rejects) every [mixed value]{@tutorial mixed} in the input array.\r\n *\r\n * The method resolves with an array of results, the same as the standard $[promise.all],\r\n * while providing comprehensive error details in case of a reject, in the form of\r\n * type {@link errors.BatchError BatchError}.\r\n *\r\n * @param {Array} values\r\n * Array of [mixed values]{@tutorial mixed} (it can be empty), to be resolved asynchronously, in no particular order.\r\n *\r\n * Passing in anything other than an array will reject with {@link external:TypeError TypeError} =\r\n * `Method 'batch' requires an array of values.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.cb]\r\n * Optional callback (or generator) to receive the result for each settled value.\r\n *\r\n * Callback Parameters:\r\n *  - `index` = index of the value in the source array\r\n *  - `success` - indicates whether the value was resolved (`true`), or rejected (`false`)\r\n *  - `result` = resolved data, if `success`=`true`, or else the rejection reason\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise to indicate that notifications are handled asynchronously.\r\n * And if the returned promise resolves, it signals a successful handling, while any resolved\r\n * data is ignored.\r\n *\r\n * If the function returns a rejected promise or throws an error, the entire method rejects\r\n * with {@link errors.BatchError BatchError} where the corresponding value in property `data`\r\n * is set to `{success, result, origin}`:\r\n *  - `success` = `false`\r\n *  - `result` = the rejection reason or the error thrown by the notification callback\r\n *  - `origin` = the original data passed into the callback as object `{success, result}`\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * The method resolves with an array of individual resolved results, the same as the standard $[promise.all].\r\n * In addition, the array is extended with a hidden read-only property `duration` - number of milliseconds\r\n * spent resolving all the data.\r\n *\r\n * The method rejects with {@link errors.BatchError BatchError} when any of the following occurs:\r\n *  - one or more values rejected or threw an error while being resolved as a [mixed value]{@tutorial mixed}\r\n *  - notification callback `cb` returned a rejected promise or threw an error\r\n *\r\n */\r\nfunction batch(values, options, config) {\r\n\r\n    const $p = config.promise, utils = config.utils;\r\n\r\n    if (!Array.isArray(values)) {\r\n        return $p.reject(new TypeError('Method \\'batch\\' requires an array of values.'));\r\n    }\r\n\r\n    if (!values.length) {\r\n        const empty = [];\r\n        utils.extend(empty, 'duration', 0);\r\n        return $p.resolve(empty);\r\n    }\r\n\r\n    options = options || {};\r\n\r\n    const cb = utils.wrap(options.cb),\r\n        self = this, start = Date.now();\r\n\r\n    return $p((resolve, reject) => {\r\n        let cbTime, remaining = values.length;\r\n        const errors = [], result = new Array(remaining);\r\n        values.forEach((item, i) => {\r\n            utils.resolve.call(self, item, null, data => {\r\n                result[i] = data;\r\n                step(i, true, data);\r\n            }, reason => {\r\n                result[i] = {success: false, result: reason};\r\n                errors.push(i);\r\n                step(i, false, reason);\r\n            });\r\n        });\r\n\r\n        function step(idx, pass, data) {\r\n            if (cb) {\r\n                const cbNow = Date.now(),\r\n                    cbDelay = idx ? (cbNow - cbTime) : undefined;\r\n                let cbResult;\r\n                cbTime = cbNow;\r\n                try {\r\n                    cbResult = cb.call(self, idx, pass, data, cbDelay);\r\n                } catch (e) {\r\n                    setError(e);\r\n                }\r\n                if (utils.isPromise(cbResult)) {\r\n                    cbResult\r\n                        .then(check)\r\n                        .catch(error => {\r\n                            setError(error);\r\n                            check();\r\n                        });\r\n                } else {\r\n                    check();\r\n                }\r\n            } else {\r\n                check();\r\n            }\r\n\r\n            function setError(e) {\r\n                const r = pass ? {success: false} : result[idx];\r\n                if (pass) {\r\n                    result[idx] = r;\r\n                    errors.push(idx);\r\n                }\r\n                r.result = e;\r\n                r.origin = {success: pass, result: data};\r\n            }\r\n\r\n            function check() {\r\n                if (!--remaining) {\r\n                    if (errors.length) {\r\n                        errors.sort();\r\n                        if (errors.length < result.length) {\r\n                            for (let i = 0, k = 0; i < result.length; i++) {\r\n                                if (i === errors[k]) {\r\n                                    k++;\r\n                                } else {\r\n                                    result[i] = {success: true, result: result[i]};\r\n                                }\r\n                            }\r\n                        }\r\n                        reject(new BatchError(result, errors, Date.now() - start));\r\n                    } else {\r\n                        utils.extend(result, 'duration', Date.now() - start);\r\n                        resolve(result);\r\n                    }\r\n                }\r\n                return null; // this dummy return is just to prevent Bluebird warnings;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nmodule.exports = function (config) {\r\n    return function (values, options) {\r\n        return batch.call(this, values, options, config);\r\n    };\r\n};\r\n"]},"metadata":{},"sourceType":"script"}