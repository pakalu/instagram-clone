{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\nconst {\n  QueryFile\n} = require(`../../query-file`);\n\nconst npm = {\n  formatting: require(`../../formatting`)\n};\n/**\r\n * @method helpers.concat\r\n * @description\r\n * Formats and concatenates multiple queries into a single query string.\r\n *\r\n * Before joining the queries, the method does the following:\r\n *  - Formats each query, if `values` are provided;\r\n *  - Removes all leading and trailing spaces, tabs and semi-colons;\r\n *  - Automatically skips all empty queries.\r\n *\r\n * @param {array<string|helpers.QueryFormat|QueryFile>} queries\r\n * Array of mixed-type elements:\r\n * - a simple query string, to be used as is\r\n * - a {@link helpers.QueryFormat QueryFormat}-like object = `{query, [values], [options]}`\r\n * - a {@link QueryFile} object\r\n *\r\n * @returns {string}\r\n * Concatenated string with all queries.\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')();\r\n *\r\n * const qf1 = new pgp.QueryFile('./query1.sql', {minify: true});\r\n * const qf2 = new pgp.QueryFile('./query2.sql', {minify: true});\r\n *\r\n * const query = pgp.helpers.concat([\r\n *     {query: 'INSERT INTO Users(name, age) VALUES($1, $2)', values: ['John', 23]}, // QueryFormat-like object\r\n *     {query: qf1, values: [1, 'Name']}, // QueryFile with formatting parameters\r\n *     'SELECT count(*) FROM Users', // a simple-string query,\r\n *     qf2 // direct QueryFile object\r\n * ]);\r\n *\r\n * // query = concatenated string with all the queries\r\n */\n\nfunction concat(queries, capSQL) {\n  if (!Array.isArray(queries)) {\n    throw new TypeError(`Parameter 'queries' must be an array.`);\n  }\n\n  const fmOptions = {\n    capSQL\n  };\n  const all = queries.map((q, index) => {\n    if (typeof q === `string`) {\n      // a simple query string without parameters:\n      return clean(q);\n    }\n\n    if (q && typeof q === `object`) {\n      if (q instanceof QueryFile) {\n        // QueryFile object:\n        return clean(q[npm.formatting.as.ctf.toPostgres]());\n      }\n\n      if (`query` in q) {\n        // object {query, values, options}:\n        let opt = q.options && typeof q.options === `object` ? q.options : {};\n        opt = opt.capSQL === undefined ? Object.assign(opt, fmOptions) : opt;\n        return clean(npm.formatting.as.format(q.query, q.values, opt));\n      }\n    }\n\n    throw new Error(`Invalid query element at index ${index}.`);\n  });\n  return all.filter(q => q).join(`;`);\n}\n\nfunction clean(q) {\n  // removes from the query all leading and trailing symbols ' ', '\\t' and ';'\n  return q.replace(/^[\\s;]*|[\\s;]*$/g, ``);\n}\n\nmodule.exports = {\n  concat\n};\n/**\r\n * @typedef helpers.QueryFormat\r\n * @description\r\n * A simple structure of parameters to be passed into method {@link formatting.format as.format} exactly as they are,\r\n * used by {@link helpers.concat}.\r\n *\r\n * @property {string|value|object} query\r\n * A query string or a value/object that implements $[Custom Type Formatting], to be formatted according to `values`.\r\n *\r\n * @property {array|object|value} [values]\r\n * Query-formatting values.\r\n *\r\n * @property {object} [options]\r\n * Query-formatting options, as supported by method {@link formatting.format as.format}.\r\n *\r\n * @see\r\n * {@link formatting.format as.format}\r\n */","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg-promise/lib/helpers/methods/concat.js"],"names":["QueryFile","require","npm","formatting","concat","queries","capSQL","Array","isArray","TypeError","fmOptions","all","map","q","index","clean","as","ctf","toPostgres","opt","options","undefined","Object","assign","format","query","values","Error","filter","join","replace","module","exports"],"mappings":"AAAA;;;;;;;;AASA,MAAM;AAACA,EAAAA;AAAD,IAAcC,OAAO,CAAE,kBAAF,CAA3B;;AAEA,MAAMC,GAAG,GAAG;AACRC,EAAAA,UAAU,EAAEF,OAAO,CAAE,kBAAF;AADX,CAAZ;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA,SAASG,MAAT,CAAgBC,OAAhB,EAAyBC,MAAzB,EAAiC;AAC7B,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcH,OAAd,CAAL,EAA6B;AACzB,UAAM,IAAII,SAAJ,CAAe,uCAAf,CAAN;AACH;;AACD,QAAMC,SAAS,GAAG;AAACJ,IAAAA;AAAD,GAAlB;AACA,QAAMK,GAAG,GAAGN,OAAO,CAACO,GAAR,CAAY,CAACC,CAAD,EAAIC,KAAJ,KAAc;AAClC,QAAI,OAAOD,CAAP,KAAc,QAAlB,EAA2B;AACvB;AACA,aAAOE,KAAK,CAACF,CAAD,CAAZ;AACH;;AACD,QAAIA,CAAC,IAAI,OAAOA,CAAP,KAAc,QAAvB,EAAgC;AAC5B,UAAIA,CAAC,YAAYb,SAAjB,EAA4B;AACxB;AACA,eAAOe,KAAK,CAACF,CAAC,CAACX,GAAG,CAACC,UAAJ,CAAea,EAAf,CAAkBC,GAAlB,CAAsBC,UAAvB,CAAD,EAAD,CAAZ;AACH;;AACD,UAAK,OAAD,IAAWL,CAAf,EAAkB;AACd;AACA,YAAIM,GAAG,GAAGN,CAAC,CAACO,OAAF,IAAa,OAAOP,CAAC,CAACO,OAAT,KAAsB,QAAnC,GAA6CP,CAAC,CAACO,OAA/C,GAAyD,EAAnE;AACAD,QAAAA,GAAG,GAAGA,GAAG,CAACb,MAAJ,KAAee,SAAf,GAA2BC,MAAM,CAACC,MAAP,CAAcJ,GAAd,EAAmBT,SAAnB,CAA3B,GAA2DS,GAAjE;AACA,eAAOJ,KAAK,CAACb,GAAG,CAACC,UAAJ,CAAea,EAAf,CAAkBQ,MAAlB,CAAyBX,CAAC,CAACY,KAA3B,EAAkCZ,CAAC,CAACa,MAApC,EAA4CP,GAA5C,CAAD,CAAZ;AACH;AACJ;;AACD,UAAM,IAAIQ,KAAJ,CAAW,kCAAiCb,KAAM,GAAlD,CAAN;AACH,GAlBW,CAAZ;AAoBA,SAAOH,GAAG,CAACiB,MAAJ,CAAWf,CAAC,IAAIA,CAAhB,EAAmBgB,IAAnB,CAAyB,GAAzB,CAAP;AACH;;AAED,SAASd,KAAT,CAAeF,CAAf,EAAkB;AACd;AACA,SAAOA,CAAC,CAACiB,OAAF,CAAU,kBAAV,EAA+B,EAA/B,CAAP;AACH;;AAEDC,MAAM,CAACC,OAAP,GAAiB;AAAC5B,EAAAA;AAAD,CAAjB;AAEA","sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {QueryFile} = require(`../../query-file`);\r\n\r\nconst npm = {\r\n    formatting: require(`../../formatting`)\r\n};\r\n\r\n/**\r\n * @method helpers.concat\r\n * @description\r\n * Formats and concatenates multiple queries into a single query string.\r\n *\r\n * Before joining the queries, the method does the following:\r\n *  - Formats each query, if `values` are provided;\r\n *  - Removes all leading and trailing spaces, tabs and semi-colons;\r\n *  - Automatically skips all empty queries.\r\n *\r\n * @param {array<string|helpers.QueryFormat|QueryFile>} queries\r\n * Array of mixed-type elements:\r\n * - a simple query string, to be used as is\r\n * - a {@link helpers.QueryFormat QueryFormat}-like object = `{query, [values], [options]}`\r\n * - a {@link QueryFile} object\r\n *\r\n * @returns {string}\r\n * Concatenated string with all queries.\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')();\r\n *\r\n * const qf1 = new pgp.QueryFile('./query1.sql', {minify: true});\r\n * const qf2 = new pgp.QueryFile('./query2.sql', {minify: true});\r\n *\r\n * const query = pgp.helpers.concat([\r\n *     {query: 'INSERT INTO Users(name, age) VALUES($1, $2)', values: ['John', 23]}, // QueryFormat-like object\r\n *     {query: qf1, values: [1, 'Name']}, // QueryFile with formatting parameters\r\n *     'SELECT count(*) FROM Users', // a simple-string query,\r\n *     qf2 // direct QueryFile object\r\n * ]);\r\n *\r\n * // query = concatenated string with all the queries\r\n */\r\nfunction concat(queries, capSQL) {\r\n    if (!Array.isArray(queries)) {\r\n        throw new TypeError(`Parameter 'queries' must be an array.`);\r\n    }\r\n    const fmOptions = {capSQL};\r\n    const all = queries.map((q, index) => {\r\n        if (typeof q === `string`) {\r\n            // a simple query string without parameters:\r\n            return clean(q);\r\n        }\r\n        if (q && typeof q === `object`) {\r\n            if (q instanceof QueryFile) {\r\n                // QueryFile object:\r\n                return clean(q[npm.formatting.as.ctf.toPostgres]());\r\n            }\r\n            if (`query` in q) {\r\n                // object {query, values, options}:\r\n                let opt = q.options && typeof q.options === `object` ? q.options : {};\r\n                opt = opt.capSQL === undefined ? Object.assign(opt, fmOptions) : opt;\r\n                return clean(npm.formatting.as.format(q.query, q.values, opt));\r\n            }\r\n        }\r\n        throw new Error(`Invalid query element at index ${index}.`);\r\n    });\r\n\r\n    return all.filter(q => q).join(`;`);\r\n}\r\n\r\nfunction clean(q) {\r\n    // removes from the query all leading and trailing symbols ' ', '\\t' and ';'\r\n    return q.replace(/^[\\s;]*|[\\s;]*$/g, ``);\r\n}\r\n\r\nmodule.exports = {concat};\r\n\r\n/**\r\n * @typedef helpers.QueryFormat\r\n * @description\r\n * A simple structure of parameters to be passed into method {@link formatting.format as.format} exactly as they are,\r\n * used by {@link helpers.concat}.\r\n *\r\n * @property {string|value|object} query\r\n * A query string or a value/object that implements $[Custom Type Formatting], to be formatted according to `values`.\r\n *\r\n * @property {array|object|value} [values]\r\n * Query-formatting values.\r\n *\r\n * @property {object} [options]\r\n * Query-formatting options, as supported by method {@link formatting.format as.format}.\r\n *\r\n * @see\r\n * {@link formatting.format as.format}\r\n */\r\n"]},"metadata":{},"sourceType":"script"}