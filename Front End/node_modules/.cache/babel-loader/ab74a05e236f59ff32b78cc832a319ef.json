{"ast":null,"code":"'use strict';\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar utils = require('./utils');\n\nvar sasl = require('./sasl');\n\nvar pgPass = require('pgpass');\n\nvar TypeOverrides = require('./type-overrides');\n\nvar ConnectionParameters = require('./connection-parameters');\n\nvar Query = require('./query');\n\nvar defaults = require('./defaults');\n\nvar Connection = require('./connection');\n\nvar Client = function (config) {\n  EventEmitter.call(this);\n  this.connectionParameters = new ConnectionParameters(config);\n  this.user = this.connectionParameters.user;\n  this.database = this.connectionParameters.database;\n  this.port = this.connectionParameters.port;\n  this.host = this.connectionParameters.host; // \"hiding\" the password so it doesn't show up in stack traces\n  // or if the client is console.logged\n\n  Object.defineProperty(this, 'password', {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: this.connectionParameters.password\n  });\n  this.replication = this.connectionParameters.replication;\n  var c = config || {};\n  this._Promise = c.Promise || global.Promise;\n  this._types = new TypeOverrides(c.types);\n  this._ending = false;\n  this._connecting = false;\n  this._connected = false;\n  this._connectionError = false;\n  this._queryable = true;\n  this.connection = c.connection || new Connection({\n    stream: c.stream,\n    ssl: this.connectionParameters.ssl,\n    keepAlive: c.keepAlive || false,\n    keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,\n    encoding: this.connectionParameters.client_encoding || 'utf8'\n  });\n  this.queryQueue = [];\n  this.binary = c.binary || defaults.binary;\n  this.processID = null;\n  this.secretKey = null;\n  this.ssl = this.connectionParameters.ssl || false;\n  this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;\n};\n\nutil.inherits(Client, EventEmitter);\n\nClient.prototype._errorAllQueries = function (err) {\n  const enqueueError = query => {\n    process.nextTick(() => {\n      query.handleError(err, this.connection);\n    });\n  };\n\n  if (this.activeQuery) {\n    enqueueError(this.activeQuery);\n    this.activeQuery = null;\n  }\n\n  this.queryQueue.forEach(enqueueError);\n  this.queryQueue.length = 0;\n};\n\nClient.prototype._connect = function (callback) {\n  var self = this;\n  var con = this.connection;\n\n  if (this._connecting || this._connected) {\n    const err = new Error('Client has already been connected. You cannot reuse a client.');\n    process.nextTick(() => {\n      callback(err);\n    });\n    return;\n  }\n\n  this._connecting = true;\n  var connectionTimeoutHandle;\n\n  if (this._connectionTimeoutMillis > 0) {\n    connectionTimeoutHandle = setTimeout(() => {\n      con._ending = true;\n      con.stream.destroy(new Error('timeout expired'));\n    }, this._connectionTimeoutMillis);\n  }\n\n  if (this.host && this.host.indexOf('/') === 0) {\n    con.connect(this.host + '/.s.PGSQL.' + this.port);\n  } else {\n    con.connect(this.port, this.host);\n  } // once connection is established send startup message\n\n\n  con.on('connect', function () {\n    if (self.ssl) {\n      con.requestSsl();\n    } else {\n      con.startup(self.getStartupConf());\n    }\n  });\n  con.on('sslconnect', function () {\n    con.startup(self.getStartupConf());\n  });\n\n  function checkPgPass(cb) {\n    return function (msg) {\n      if (typeof self.password === 'function') {\n        self._Promise.resolve().then(() => self.password()).then(pass => {\n          if (pass !== undefined) {\n            if (typeof pass !== 'string') {\n              con.emit('error', new TypeError('Password must be a string'));\n              return;\n            }\n\n            self.connectionParameters.password = self.password = pass;\n          } else {\n            self.connectionParameters.password = self.password = null;\n          }\n\n          cb(msg);\n        }).catch(err => {\n          con.emit('error', err);\n        });\n      } else if (self.password !== null) {\n        cb(msg);\n      } else {\n        pgPass(self.connectionParameters, function (pass) {\n          if (undefined !== pass) {\n            self.connectionParameters.password = self.password = pass;\n          }\n\n          cb(msg);\n        });\n      }\n    };\n  } // password request handling\n\n\n  con.on('authenticationCleartextPassword', checkPgPass(function () {\n    con.password(self.password);\n  })); // password request handling\n\n  con.on('authenticationMD5Password', checkPgPass(function (msg) {\n    con.password(utils.postgresMd5PasswordHash(self.user, self.password, msg.salt));\n  })); // password request handling (SASL)\n\n  var saslSession;\n  con.on('authenticationSASL', checkPgPass(function (msg) {\n    saslSession = sasl.startSession(msg.mechanisms);\n    con.sendSASLInitialResponseMessage(saslSession.mechanism, saslSession.response);\n  })); // password request handling (SASL)\n\n  con.on('authenticationSASLContinue', function (msg) {\n    sasl.continueSession(saslSession, self.password, msg.data);\n    con.sendSCRAMClientFinalMessage(saslSession.response);\n  }); // password request handling (SASL)\n\n  con.on('authenticationSASLFinal', function (msg) {\n    sasl.finalizeSession(saslSession, msg.data);\n    saslSession = null;\n  });\n  con.once('backendKeyData', function (msg) {\n    self.processID = msg.processID;\n    self.secretKey = msg.secretKey;\n  });\n\n  const connectingErrorHandler = err => {\n    if (this._connectionError) {\n      return;\n    }\n\n    this._connectionError = true;\n    clearTimeout(connectionTimeoutHandle);\n\n    if (callback) {\n      return callback(err);\n    }\n\n    this.emit('error', err);\n  };\n\n  const connectedErrorHandler = err => {\n    this._queryable = false;\n\n    this._errorAllQueries(err);\n\n    this.emit('error', err);\n  };\n\n  const connectedErrorMessageHandler = msg => {\n    const activeQuery = this.activeQuery;\n\n    if (!activeQuery) {\n      connectedErrorHandler(msg);\n      return;\n    }\n\n    this.activeQuery = null;\n    activeQuery.handleError(msg, con);\n  };\n\n  con.on('error', connectingErrorHandler);\n  con.on('errorMessage', connectingErrorHandler); // hook up query handling events to connection\n  // after the connection initially becomes ready for queries\n\n  con.once('readyForQuery', function () {\n    self._connecting = false;\n    self._connected = true;\n\n    self._attachListeners(con);\n\n    con.removeListener('error', connectingErrorHandler);\n    con.removeListener('errorMessage', connectingErrorHandler);\n    con.on('error', connectedErrorHandler);\n    con.on('errorMessage', connectedErrorMessageHandler);\n    clearTimeout(connectionTimeoutHandle); // process possible callback argument to Client#connect\n\n    if (callback) {\n      callback(null, self); // remove callback for proper error handling\n      // after the connect event\n\n      callback = null;\n    }\n\n    self.emit('connect');\n  });\n  con.on('readyForQuery', function () {\n    var activeQuery = self.activeQuery;\n    self.activeQuery = null;\n    self.readyForQuery = true;\n\n    if (activeQuery) {\n      activeQuery.handleReadyForQuery(con);\n    }\n\n    self._pulseQueryQueue();\n  });\n  con.once('end', () => {\n    const error = this._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly');\n    clearTimeout(connectionTimeoutHandle);\n\n    this._errorAllQueries(error);\n\n    if (!this._ending) {\n      // if the connection is ended without us calling .end()\n      // on this client then we have an unexpected disconnection\n      // treat this as an error unless we've already emitted an error\n      // during connection.\n      if (this._connecting && !this._connectionError) {\n        if (callback) {\n          callback(error);\n        } else {\n          connectedErrorHandler(error);\n        }\n      } else if (!this._connectionError) {\n        connectedErrorHandler(error);\n      }\n    }\n\n    process.nextTick(() => {\n      this.emit('end');\n    });\n  });\n  con.on('notice', function (msg) {\n    self.emit('notice', msg);\n  });\n};\n\nClient.prototype.connect = function (callback) {\n  if (callback) {\n    this._connect(callback);\n\n    return;\n  }\n\n  return new this._Promise((resolve, reject) => {\n    this._connect(error => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve();\n      }\n    });\n  });\n};\n\nClient.prototype._attachListeners = function (con) {\n  const self = this; // delegate rowDescription to active query\n\n  con.on('rowDescription', function (msg) {\n    self.activeQuery.handleRowDescription(msg);\n  }); // delegate dataRow to active query\n\n  con.on('dataRow', function (msg) {\n    self.activeQuery.handleDataRow(msg);\n  }); // delegate portalSuspended to active query\n  // eslint-disable-next-line no-unused-vars\n\n  con.on('portalSuspended', function (msg) {\n    self.activeQuery.handlePortalSuspended(con);\n  }); // delegate emptyQuery to active query\n  // eslint-disable-next-line no-unused-vars\n\n  con.on('emptyQuery', function (msg) {\n    self.activeQuery.handleEmptyQuery(con);\n  }); // delegate commandComplete to active query\n\n  con.on('commandComplete', function (msg) {\n    self.activeQuery.handleCommandComplete(msg, con);\n  }); // if a prepared statement has a name and properly parses\n  // we track that its already been executed so we don't parse\n  // it again on the same client\n  // eslint-disable-next-line no-unused-vars\n\n  con.on('parseComplete', function (msg) {\n    if (self.activeQuery.name) {\n      con.parsedStatements[self.activeQuery.name] = self.activeQuery.text;\n    }\n  }); // eslint-disable-next-line no-unused-vars\n\n  con.on('copyInResponse', function (msg) {\n    self.activeQuery.handleCopyInResponse(self.connection);\n  });\n  con.on('copyData', function (msg) {\n    self.activeQuery.handleCopyData(msg, self.connection);\n  });\n  con.on('notification', function (msg) {\n    self.emit('notification', msg);\n  });\n};\n\nClient.prototype.getStartupConf = function () {\n  var params = this.connectionParameters;\n  var data = {\n    user: params.user,\n    database: params.database\n  };\n  var appName = params.application_name || params.fallback_application_name;\n\n  if (appName) {\n    data.application_name = appName;\n  }\n\n  if (params.replication) {\n    data.replication = '' + params.replication;\n  }\n\n  if (params.statement_timeout) {\n    data.statement_timeout = String(parseInt(params.statement_timeout, 10));\n  }\n\n  if (params.idle_in_transaction_session_timeout) {\n    data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));\n  }\n\n  return data;\n};\n\nClient.prototype.cancel = function (client, query) {\n  if (client.activeQuery === query) {\n    var con = this.connection;\n\n    if (this.host && this.host.indexOf('/') === 0) {\n      con.connect(this.host + '/.s.PGSQL.' + this.port);\n    } else {\n      con.connect(this.port, this.host);\n    } // once connection is established send cancel message\n\n\n    con.on('connect', function () {\n      con.cancel(client.processID, client.secretKey);\n    });\n  } else if (client.queryQueue.indexOf(query) !== -1) {\n    client.queryQueue.splice(client.queryQueue.indexOf(query), 1);\n  }\n};\n\nClient.prototype.setTypeParser = function (oid, format, parseFn) {\n  return this._types.setTypeParser(oid, format, parseFn);\n};\n\nClient.prototype.getTypeParser = function (oid, format) {\n  return this._types.getTypeParser(oid, format);\n}; // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n\n\nClient.prototype.escapeIdentifier = function (str) {\n  return '\"' + str.replace(/\"/g, '\"\"') + '\"';\n}; // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n\n\nClient.prototype.escapeLiteral = function (str) {\n  var hasBackslash = false;\n  var escaped = \"'\";\n\n  for (var i = 0; i < str.length; i++) {\n    var c = str[i];\n\n    if (c === \"'\") {\n      escaped += c + c;\n    } else if (c === '\\\\') {\n      escaped += c + c;\n      hasBackslash = true;\n    } else {\n      escaped += c;\n    }\n  }\n\n  escaped += \"'\";\n\n  if (hasBackslash === true) {\n    escaped = ' E' + escaped;\n  }\n\n  return escaped;\n};\n\nClient.prototype._pulseQueryQueue = function () {\n  if (this.readyForQuery === true) {\n    this.activeQuery = this.queryQueue.shift();\n\n    if (this.activeQuery) {\n      this.readyForQuery = false;\n      this.hasExecuted = true;\n      const queryError = this.activeQuery.submit(this.connection);\n\n      if (queryError) {\n        process.nextTick(() => {\n          this.activeQuery.handleError(queryError, this.connection);\n          this.readyForQuery = true;\n\n          this._pulseQueryQueue();\n        });\n      }\n    } else if (this.hasExecuted) {\n      this.activeQuery = null;\n      this.emit('drain');\n    }\n  }\n};\n\nClient.prototype.query = function (config, values, callback) {\n  // can take in strings, config object or query object\n  var query;\n  var result;\n  var readTimeout;\n  var readTimeoutTimer;\n  var queryCallback;\n\n  if (config === null || config === undefined) {\n    throw new TypeError('Client was passed a null or undefined query');\n  } else if (typeof config.submit === 'function') {\n    readTimeout = config.query_timeout || this.connectionParameters.query_timeout;\n    result = query = config;\n\n    if (typeof values === 'function') {\n      query.callback = query.callback || values;\n    }\n  } else {\n    readTimeout = this.connectionParameters.query_timeout;\n    query = new Query(config, values, callback);\n\n    if (!query.callback) {\n      result = new this._Promise((resolve, reject) => {\n        query.callback = (err, res) => err ? reject(err) : resolve(res);\n      });\n    }\n  }\n\n  if (readTimeout) {\n    queryCallback = query.callback;\n    readTimeoutTimer = setTimeout(() => {\n      var error = new Error('Query read timeout');\n      process.nextTick(() => {\n        query.handleError(error, this.connection);\n      });\n      queryCallback(error); // we already returned an error,\n      // just do nothing if query completes\n\n      query.callback = () => {}; // Remove from queue\n\n\n      var index = this.queryQueue.indexOf(query);\n\n      if (index > -1) {\n        this.queryQueue.splice(index, 1);\n      }\n\n      this._pulseQueryQueue();\n    }, readTimeout);\n\n    query.callback = (err, res) => {\n      clearTimeout(readTimeoutTimer);\n      queryCallback(err, res);\n    };\n  }\n\n  if (this.binary && !query.binary) {\n    query.binary = true;\n  }\n\n  if (query._result && !query._result._types) {\n    query._result._types = this._types;\n  }\n\n  if (!this._queryable) {\n    process.nextTick(() => {\n      query.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection);\n    });\n    return result;\n  }\n\n  if (this._ending) {\n    process.nextTick(() => {\n      query.handleError(new Error('Client was closed and is not queryable'), this.connection);\n    });\n    return result;\n  }\n\n  this.queryQueue.push(query);\n\n  this._pulseQueryQueue();\n\n  return result;\n};\n\nClient.prototype.end = function (cb) {\n  this._ending = true; // if we have never connected, then end is a noop, callback immediately\n\n  if (!this.connection._connecting) {\n    if (cb) {\n      cb();\n    } else {\n      return this._Promise.resolve();\n    }\n  }\n\n  if (this.activeQuery || !this._queryable) {\n    // if we have an active query we need to force a disconnect\n    // on the socket - otherwise a hung query could block end forever\n    this.connection.stream.destroy();\n  } else {\n    this.connection.end();\n  }\n\n  if (cb) {\n    this.connection.once('end', cb);\n  } else {\n    return new this._Promise(resolve => {\n      this.connection.once('end', resolve);\n    });\n  }\n}; // expose a Query constructor\n\n\nClient.Query = Query;\nmodule.exports = Client;","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg/lib/client.js"],"names":["EventEmitter","require","util","utils","sasl","pgPass","TypeOverrides","ConnectionParameters","Query","defaults","Connection","Client","config","call","connectionParameters","user","database","port","host","Object","defineProperty","configurable","enumerable","writable","value","password","replication","c","_Promise","Promise","global","_types","types","_ending","_connecting","_connected","_connectionError","_queryable","connection","stream","ssl","keepAlive","keepAliveInitialDelayMillis","encoding","client_encoding","queryQueue","binary","processID","secretKey","_connectionTimeoutMillis","connectionTimeoutMillis","inherits","prototype","_errorAllQueries","err","enqueueError","query","process","nextTick","handleError","activeQuery","forEach","length","_connect","callback","self","con","Error","connectionTimeoutHandle","setTimeout","destroy","indexOf","connect","on","requestSsl","startup","getStartupConf","checkPgPass","cb","msg","resolve","then","pass","undefined","emit","TypeError","catch","postgresMd5PasswordHash","salt","saslSession","startSession","mechanisms","sendSASLInitialResponseMessage","mechanism","response","continueSession","data","sendSCRAMClientFinalMessage","finalizeSession","once","connectingErrorHandler","clearTimeout","connectedErrorHandler","connectedErrorMessageHandler","_attachListeners","removeListener","readyForQuery","handleReadyForQuery","_pulseQueryQueue","error","reject","handleRowDescription","handleDataRow","handlePortalSuspended","handleEmptyQuery","handleCommandComplete","name","parsedStatements","text","handleCopyInResponse","handleCopyData","params","appName","application_name","fallback_application_name","statement_timeout","String","parseInt","idle_in_transaction_session_timeout","cancel","client","splice","setTypeParser","oid","format","parseFn","getTypeParser","escapeIdentifier","str","replace","escapeLiteral","hasBackslash","escaped","i","shift","hasExecuted","queryError","submit","values","result","readTimeout","readTimeoutTimer","queryCallback","query_timeout","res","index","_result","push","end","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\nvar utils = require('./utils')\nvar sasl = require('./sasl')\nvar pgPass = require('pgpass')\nvar TypeOverrides = require('./type-overrides')\n\nvar ConnectionParameters = require('./connection-parameters')\nvar Query = require('./query')\nvar defaults = require('./defaults')\nvar Connection = require('./connection')\n\nvar Client = function (config) {\n  EventEmitter.call(this)\n\n  this.connectionParameters = new ConnectionParameters(config)\n  this.user = this.connectionParameters.user\n  this.database = this.connectionParameters.database\n  this.port = this.connectionParameters.port\n  this.host = this.connectionParameters.host\n\n  // \"hiding\" the password so it doesn't show up in stack traces\n  // or if the client is console.logged\n  Object.defineProperty(this, 'password', {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: this.connectionParameters.password,\n  })\n\n  this.replication = this.connectionParameters.replication\n\n  var c = config || {}\n\n  this._Promise = c.Promise || global.Promise\n  this._types = new TypeOverrides(c.types)\n  this._ending = false\n  this._connecting = false\n  this._connected = false\n  this._connectionError = false\n  this._queryable = true\n\n  this.connection =\n    c.connection ||\n    new Connection({\n      stream: c.stream,\n      ssl: this.connectionParameters.ssl,\n      keepAlive: c.keepAlive || false,\n      keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,\n      encoding: this.connectionParameters.client_encoding || 'utf8',\n    })\n  this.queryQueue = []\n  this.binary = c.binary || defaults.binary\n  this.processID = null\n  this.secretKey = null\n  this.ssl = this.connectionParameters.ssl || false\n  this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0\n}\n\nutil.inherits(Client, EventEmitter)\n\nClient.prototype._errorAllQueries = function (err) {\n  const enqueueError = (query) => {\n    process.nextTick(() => {\n      query.handleError(err, this.connection)\n    })\n  }\n\n  if (this.activeQuery) {\n    enqueueError(this.activeQuery)\n    this.activeQuery = null\n  }\n\n  this.queryQueue.forEach(enqueueError)\n  this.queryQueue.length = 0\n}\n\nClient.prototype._connect = function (callback) {\n  var self = this\n  var con = this.connection\n  if (this._connecting || this._connected) {\n    const err = new Error('Client has already been connected. You cannot reuse a client.')\n    process.nextTick(() => {\n      callback(err)\n    })\n    return\n  }\n  this._connecting = true\n\n  var connectionTimeoutHandle\n  if (this._connectionTimeoutMillis > 0) {\n    connectionTimeoutHandle = setTimeout(() => {\n      con._ending = true\n      con.stream.destroy(new Error('timeout expired'))\n    }, this._connectionTimeoutMillis)\n  }\n\n  if (this.host && this.host.indexOf('/') === 0) {\n    con.connect(this.host + '/.s.PGSQL.' + this.port)\n  } else {\n    con.connect(this.port, this.host)\n  }\n\n  // once connection is established send startup message\n  con.on('connect', function () {\n    if (self.ssl) {\n      con.requestSsl()\n    } else {\n      con.startup(self.getStartupConf())\n    }\n  })\n\n  con.on('sslconnect', function () {\n    con.startup(self.getStartupConf())\n  })\n\n  function checkPgPass(cb) {\n    return function (msg) {\n      if (typeof self.password === 'function') {\n        self._Promise\n          .resolve()\n          .then(() => self.password())\n          .then((pass) => {\n            if (pass !== undefined) {\n              if (typeof pass !== 'string') {\n                con.emit('error', new TypeError('Password must be a string'))\n                return\n              }\n              self.connectionParameters.password = self.password = pass\n            } else {\n              self.connectionParameters.password = self.password = null\n            }\n            cb(msg)\n          })\n          .catch((err) => {\n            con.emit('error', err)\n          })\n      } else if (self.password !== null) {\n        cb(msg)\n      } else {\n        pgPass(self.connectionParameters, function (pass) {\n          if (undefined !== pass) {\n            self.connectionParameters.password = self.password = pass\n          }\n          cb(msg)\n        })\n      }\n    }\n  }\n\n  // password request handling\n  con.on(\n    'authenticationCleartextPassword',\n    checkPgPass(function () {\n      con.password(self.password)\n    })\n  )\n\n  // password request handling\n  con.on(\n    'authenticationMD5Password',\n    checkPgPass(function (msg) {\n      con.password(utils.postgresMd5PasswordHash(self.user, self.password, msg.salt))\n    })\n  )\n\n  // password request handling (SASL)\n  var saslSession\n  con.on(\n    'authenticationSASL',\n    checkPgPass(function (msg) {\n      saslSession = sasl.startSession(msg.mechanisms)\n\n      con.sendSASLInitialResponseMessage(saslSession.mechanism, saslSession.response)\n    })\n  )\n\n  // password request handling (SASL)\n  con.on('authenticationSASLContinue', function (msg) {\n    sasl.continueSession(saslSession, self.password, msg.data)\n\n    con.sendSCRAMClientFinalMessage(saslSession.response)\n  })\n\n  // password request handling (SASL)\n  con.on('authenticationSASLFinal', function (msg) {\n    sasl.finalizeSession(saslSession, msg.data)\n\n    saslSession = null\n  })\n\n  con.once('backendKeyData', function (msg) {\n    self.processID = msg.processID\n    self.secretKey = msg.secretKey\n  })\n\n  const connectingErrorHandler = (err) => {\n    if (this._connectionError) {\n      return\n    }\n    this._connectionError = true\n    clearTimeout(connectionTimeoutHandle)\n    if (callback) {\n      return callback(err)\n    }\n    this.emit('error', err)\n  }\n\n  const connectedErrorHandler = (err) => {\n    this._queryable = false\n    this._errorAllQueries(err)\n    this.emit('error', err)\n  }\n\n  const connectedErrorMessageHandler = (msg) => {\n    const activeQuery = this.activeQuery\n\n    if (!activeQuery) {\n      connectedErrorHandler(msg)\n      return\n    }\n\n    this.activeQuery = null\n    activeQuery.handleError(msg, con)\n  }\n\n  con.on('error', connectingErrorHandler)\n  con.on('errorMessage', connectingErrorHandler)\n\n  // hook up query handling events to connection\n  // after the connection initially becomes ready for queries\n  con.once('readyForQuery', function () {\n    self._connecting = false\n    self._connected = true\n    self._attachListeners(con)\n    con.removeListener('error', connectingErrorHandler)\n    con.removeListener('errorMessage', connectingErrorHandler)\n    con.on('error', connectedErrorHandler)\n    con.on('errorMessage', connectedErrorMessageHandler)\n    clearTimeout(connectionTimeoutHandle)\n\n    // process possible callback argument to Client#connect\n    if (callback) {\n      callback(null, self)\n      // remove callback for proper error handling\n      // after the connect event\n      callback = null\n    }\n    self.emit('connect')\n  })\n\n  con.on('readyForQuery', function () {\n    var activeQuery = self.activeQuery\n    self.activeQuery = null\n    self.readyForQuery = true\n    if (activeQuery) {\n      activeQuery.handleReadyForQuery(con)\n    }\n    self._pulseQueryQueue()\n  })\n\n  con.once('end', () => {\n    const error = this._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly')\n\n    clearTimeout(connectionTimeoutHandle)\n    this._errorAllQueries(error)\n\n    if (!this._ending) {\n      // if the connection is ended without us calling .end()\n      // on this client then we have an unexpected disconnection\n      // treat this as an error unless we've already emitted an error\n      // during connection.\n      if (this._connecting && !this._connectionError) {\n        if (callback) {\n          callback(error)\n        } else {\n          connectedErrorHandler(error)\n        }\n      } else if (!this._connectionError) {\n        connectedErrorHandler(error)\n      }\n    }\n\n    process.nextTick(() => {\n      this.emit('end')\n    })\n  })\n\n  con.on('notice', function (msg) {\n    self.emit('notice', msg)\n  })\n}\n\nClient.prototype.connect = function (callback) {\n  if (callback) {\n    this._connect(callback)\n    return\n  }\n\n  return new this._Promise((resolve, reject) => {\n    this._connect((error) => {\n      if (error) {\n        reject(error)\n      } else {\n        resolve()\n      }\n    })\n  })\n}\n\nClient.prototype._attachListeners = function (con) {\n  const self = this\n  // delegate rowDescription to active query\n  con.on('rowDescription', function (msg) {\n    self.activeQuery.handleRowDescription(msg)\n  })\n\n  // delegate dataRow to active query\n  con.on('dataRow', function (msg) {\n    self.activeQuery.handleDataRow(msg)\n  })\n\n  // delegate portalSuspended to active query\n  // eslint-disable-next-line no-unused-vars\n  con.on('portalSuspended', function (msg) {\n    self.activeQuery.handlePortalSuspended(con)\n  })\n\n  // delegate emptyQuery to active query\n  // eslint-disable-next-line no-unused-vars\n  con.on('emptyQuery', function (msg) {\n    self.activeQuery.handleEmptyQuery(con)\n  })\n\n  // delegate commandComplete to active query\n  con.on('commandComplete', function (msg) {\n    self.activeQuery.handleCommandComplete(msg, con)\n  })\n\n  // if a prepared statement has a name and properly parses\n  // we track that its already been executed so we don't parse\n  // it again on the same client\n  // eslint-disable-next-line no-unused-vars\n  con.on('parseComplete', function (msg) {\n    if (self.activeQuery.name) {\n      con.parsedStatements[self.activeQuery.name] = self.activeQuery.text\n    }\n  })\n\n  // eslint-disable-next-line no-unused-vars\n  con.on('copyInResponse', function (msg) {\n    self.activeQuery.handleCopyInResponse(self.connection)\n  })\n\n  con.on('copyData', function (msg) {\n    self.activeQuery.handleCopyData(msg, self.connection)\n  })\n\n  con.on('notification', function (msg) {\n    self.emit('notification', msg)\n  })\n}\n\nClient.prototype.getStartupConf = function () {\n  var params = this.connectionParameters\n\n  var data = {\n    user: params.user,\n    database: params.database,\n  }\n\n  var appName = params.application_name || params.fallback_application_name\n  if (appName) {\n    data.application_name = appName\n  }\n  if (params.replication) {\n    data.replication = '' + params.replication\n  }\n  if (params.statement_timeout) {\n    data.statement_timeout = String(parseInt(params.statement_timeout, 10))\n  }\n  if (params.idle_in_transaction_session_timeout) {\n    data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10))\n  }\n\n  return data\n}\n\nClient.prototype.cancel = function (client, query) {\n  if (client.activeQuery === query) {\n    var con = this.connection\n\n    if (this.host && this.host.indexOf('/') === 0) {\n      con.connect(this.host + '/.s.PGSQL.' + this.port)\n    } else {\n      con.connect(this.port, this.host)\n    }\n\n    // once connection is established send cancel message\n    con.on('connect', function () {\n      con.cancel(client.processID, client.secretKey)\n    })\n  } else if (client.queryQueue.indexOf(query) !== -1) {\n    client.queryQueue.splice(client.queryQueue.indexOf(query), 1)\n  }\n}\n\nClient.prototype.setTypeParser = function (oid, format, parseFn) {\n  return this._types.setTypeParser(oid, format, parseFn)\n}\n\nClient.prototype.getTypeParser = function (oid, format) {\n  return this._types.getTypeParser(oid, format)\n}\n\n// Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\nClient.prototype.escapeIdentifier = function (str) {\n  return '\"' + str.replace(/\"/g, '\"\"') + '\"'\n}\n\n// Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\nClient.prototype.escapeLiteral = function (str) {\n  var hasBackslash = false\n  var escaped = \"'\"\n\n  for (var i = 0; i < str.length; i++) {\n    var c = str[i]\n    if (c === \"'\") {\n      escaped += c + c\n    } else if (c === '\\\\') {\n      escaped += c + c\n      hasBackslash = true\n    } else {\n      escaped += c\n    }\n  }\n\n  escaped += \"'\"\n\n  if (hasBackslash === true) {\n    escaped = ' E' + escaped\n  }\n\n  return escaped\n}\n\nClient.prototype._pulseQueryQueue = function () {\n  if (this.readyForQuery === true) {\n    this.activeQuery = this.queryQueue.shift()\n    if (this.activeQuery) {\n      this.readyForQuery = false\n      this.hasExecuted = true\n\n      const queryError = this.activeQuery.submit(this.connection)\n      if (queryError) {\n        process.nextTick(() => {\n          this.activeQuery.handleError(queryError, this.connection)\n          this.readyForQuery = true\n          this._pulseQueryQueue()\n        })\n      }\n    } else if (this.hasExecuted) {\n      this.activeQuery = null\n      this.emit('drain')\n    }\n  }\n}\n\nClient.prototype.query = function (config, values, callback) {\n  // can take in strings, config object or query object\n  var query\n  var result\n  var readTimeout\n  var readTimeoutTimer\n  var queryCallback\n\n  if (config === null || config === undefined) {\n    throw new TypeError('Client was passed a null or undefined query')\n  } else if (typeof config.submit === 'function') {\n    readTimeout = config.query_timeout || this.connectionParameters.query_timeout\n    result = query = config\n    if (typeof values === 'function') {\n      query.callback = query.callback || values\n    }\n  } else {\n    readTimeout = this.connectionParameters.query_timeout\n    query = new Query(config, values, callback)\n    if (!query.callback) {\n      result = new this._Promise((resolve, reject) => {\n        query.callback = (err, res) => (err ? reject(err) : resolve(res))\n      })\n    }\n  }\n\n  if (readTimeout) {\n    queryCallback = query.callback\n\n    readTimeoutTimer = setTimeout(() => {\n      var error = new Error('Query read timeout')\n\n      process.nextTick(() => {\n        query.handleError(error, this.connection)\n      })\n\n      queryCallback(error)\n\n      // we already returned an error,\n      // just do nothing if query completes\n      query.callback = () => {}\n\n      // Remove from queue\n      var index = this.queryQueue.indexOf(query)\n      if (index > -1) {\n        this.queryQueue.splice(index, 1)\n      }\n\n      this._pulseQueryQueue()\n    }, readTimeout)\n\n    query.callback = (err, res) => {\n      clearTimeout(readTimeoutTimer)\n      queryCallback(err, res)\n    }\n  }\n\n  if (this.binary && !query.binary) {\n    query.binary = true\n  }\n\n  if (query._result && !query._result._types) {\n    query._result._types = this._types\n  }\n\n  if (!this._queryable) {\n    process.nextTick(() => {\n      query.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection)\n    })\n    return result\n  }\n\n  if (this._ending) {\n    process.nextTick(() => {\n      query.handleError(new Error('Client was closed and is not queryable'), this.connection)\n    })\n    return result\n  }\n\n  this.queryQueue.push(query)\n  this._pulseQueryQueue()\n  return result\n}\n\nClient.prototype.end = function (cb) {\n  this._ending = true\n\n  // if we have never connected, then end is a noop, callback immediately\n  if (!this.connection._connecting) {\n    if (cb) {\n      cb()\n    } else {\n      return this._Promise.resolve()\n    }\n  }\n\n  if (this.activeQuery || !this._queryable) {\n    // if we have an active query we need to force a disconnect\n    // on the socket - otherwise a hung query could block end forever\n    this.connection.stream.destroy()\n  } else {\n    this.connection.end()\n  }\n\n  if (cb) {\n    this.connection.once('end', cb)\n  } else {\n    return new this._Promise((resolve) => {\n      this.connection.once('end', resolve)\n    })\n  }\n}\n\n// expose a Query constructor\nClient.Query = Query\n\nmodule.exports = Client\n"]},"metadata":{},"sourceType":"script"}