{"ast":null,"code":"/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\nconst {\n  assertOptions\n} = require(`assert-options`);\n\nconst npm = {\n  pgUtils: require(`pg/lib/utils`),\n  patterns: require(`./patterns`),\n  utils: require(`./utils`)\n}; // Format Modification Flags;\n\nconst fmFlags = {\n  raw: 1,\n  // Raw-Text variable\n  alias: 2,\n  // SQL Alias\n  name: 4,\n  // SQL Name/Identifier\n  json: 8,\n  // JSON modifier\n  csv: 16,\n  // CSV modifier\n  value: 32 // escaped, but without ''\n\n}; // Format Modification Map;\n\nconst fmMap = {\n  '^': fmFlags.raw,\n  ':raw': fmFlags.raw,\n  ':alias': fmFlags.alias,\n  '~': fmFlags.name,\n  ':name': fmFlags.name,\n  ':json': fmFlags.json,\n  ':csv': fmFlags.csv,\n  ':list': fmFlags.csv,\n  ':value': fmFlags.value,\n  '#': fmFlags.value\n}; // Global symbols for Custom Type Formatting:\n\nconst ctfSymbols = {\n  toPostgres: Symbol.for(`ctf.toPostgres`),\n  rawType: Symbol.for(`ctf.rawType`)\n};\nconst maxVariable = 100000; // maximum supported variable is '$100000'\n////////////////////////////////////////////////////\n// Converts a single value into its Postgres format.\n\nfunction formatValue({\n  value,\n  fm,\n  cc,\n  options\n}) {\n  if (typeof value === `function`) {\n    return formatValue({\n      value: resolveFunc(value, cc),\n      fm,\n      cc\n    });\n  }\n\n  const ctf = getCTF(value); // Custom Type Formatting\n\n  if (ctf) {\n    fm |= ctf.rawType ? fmFlags.raw : 0;\n    return formatValue({\n      value: resolveFunc(ctf.toPostgres, value),\n      fm,\n      cc\n    });\n  }\n\n  const isRaw = !!(fm & fmFlags.raw);\n  fm &= ~fmFlags.raw;\n\n  switch (fm) {\n    case fmFlags.alias:\n      return $as.alias(value);\n\n    case fmFlags.name:\n      return $as.name(value);\n\n    case fmFlags.json:\n      return $as.json(value, isRaw);\n\n    case fmFlags.csv:\n      return $to.csv(value, options);\n\n    case fmFlags.value:\n      return $as.value(value);\n\n    default:\n      break;\n  }\n\n  if (isNull(value)) {\n    throwIfRaw(isRaw);\n    return `null`;\n  }\n\n  switch (typeof value) {\n    case `string`:\n      return $to.text(value, isRaw);\n\n    case `boolean`:\n      return $to.bool(value);\n\n    case `number`:\n    case `bigint`:\n      return $to.number(value);\n\n    case `symbol`:\n      throw new TypeError(`Type Symbol has no meaning for PostgreSQL: ${value.toString()}`);\n\n    default:\n      if (value instanceof Date) {\n        return $to.date(value, isRaw);\n      }\n\n      if (value instanceof Array) {\n        return $to.array(value, options);\n      }\n\n      if (value instanceof Buffer) {\n        return $to.buffer(value, isRaw);\n      }\n\n      return $to.json(value, isRaw);\n  }\n} ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Converts array of values into PostgreSQL Array Constructor: array[...], as per PostgreSQL documentation:\n// http://www.postgresql.org/docs/9.6/static/arrays.html\n//\n// Arrays of any depth/dimension are supported.\n//\n// Top-level empty arrays are formatted as literal '{}' to avoid the necessity of explicit type casting,\n// as the server cannot automatically infer type of an empty non-literal array.\n\n\nfunction formatArray(array, options) {\n  const loop = a => `[` + a.map(value => value instanceof Array ? loop(value) : formatValue({\n    value,\n    options\n  })).join() + `]`;\n\n  const prefix = options && options.capSQL ? `ARRAY` : `array`;\n  return array.length ? prefix + loop(array) : `'{}'`;\n} ///////////////////////////////////////////////////////////////////\n// Formats array/object/value as a list of comma-separated values.\n\n\nfunction formatCSV(values, options) {\n  if (values instanceof Array) {\n    return values.map(value => formatValue({\n      value,\n      options\n    })).join();\n  }\n\n  if (typeof values === `object` && values !== null) {\n    return Object.keys(values).map(v => formatValue({\n      value: values[v],\n      options\n    })).join();\n  }\n\n  return values === undefined ? `` : formatValue({\n    value: values,\n    options\n  });\n} ///////////////////////////////\n// Query formatting helpers;\n\n\nconst formatAs = {\n  object(query, obj, raw, options) {\n    options = options && typeof options === `object` ? options : {};\n    return query.replace(npm.patterns.namedParameters, name => {\n      const v = formatAs.stripName(name.replace(/^\\$[{(<[/]|[\\s})>\\]/]/g, ``), raw),\n            c = npm.utils.getIfHas(obj, v.name);\n\n      if (!c.valid) {\n        throw new Error(`Invalid property name '${v.name}'.`);\n      }\n\n      if (c.has) {\n        return formatValue({\n          value: c.value,\n          fm: v.fm,\n          cc: c.target,\n          options\n        });\n      }\n\n      if (v.name === `this`) {\n        return formatValue({\n          value: obj,\n          fm: v.fm,\n          options\n        });\n      }\n\n      if (`def` in options) {\n        const d = options.def,\n              value = typeof d === `function` ? d.call(obj, v.name, obj) : d;\n        return formatValue({\n          value,\n          fm: v.fm,\n          cc: obj,\n          options\n        });\n      }\n\n      if (options.partial) {\n        return name;\n      } // property must exist as the object's own or inherited;\n\n\n      throw new Error(`Property '${v.name}' doesn't exist.`);\n    });\n  },\n\n  array(query, array, raw, options) {\n    options = options && typeof options === `object` ? options : {};\n    return query.replace(npm.patterns.multipleValues, name => {\n      const v = formatAs.stripName(name.substr(1), raw);\n      const idx = v.name - 1;\n\n      if (idx >= maxVariable) {\n        throw new RangeError(`Variable $${v.name} exceeds supported maximum of $${maxVariable}`);\n      }\n\n      if (idx < array.length) {\n        return formatValue({\n          value: array[idx],\n          fm: v.fm,\n          options\n        });\n      }\n\n      if (`def` in options) {\n        const d = options.def,\n              value = typeof d === `function` ? d.call(array, idx, array) : d;\n        return formatValue({\n          value,\n          fm: v.fm,\n          options\n        });\n      }\n\n      if (options.partial) {\n        return name;\n      }\n\n      throw new RangeError(`Variable $${v.name} out of range. Parameters array length: ${array.length}`);\n    });\n  },\n\n  value(query, value, raw, options) {\n    return query.replace(npm.patterns.singleValue, name => {\n      const v = formatAs.stripName(name, raw);\n      return formatValue({\n        value,\n        fm: v.fm,\n        options\n      });\n    });\n  },\n\n  stripName(name, raw) {\n    const mod = name.match(npm.patterns.hasValidModifier);\n\n    if (mod) {\n      return {\n        name: name.substr(0, mod.index),\n        fm: fmMap[mod[0]] | (raw ? fmFlags.raw : 0)\n      };\n    }\n\n    return {\n      name,\n      fm: raw ? fmFlags.raw : null\n    };\n  }\n\n}; ////////////////////////////////////////////\n// Simpler check for null/undefined;\n\nfunction isNull(value) {\n  return value === undefined || value === null;\n} //////////////////////////////////////////////////////////////////\n// Checks if the value supports Custom Type Formatting,\n// to return {toPostgres, rawType}, if it does, or null otherwise.\n\n\nfunction getCTF(value) {\n  if (!isNull(value)) {\n    let toPostgres = value[ctfSymbols.toPostgres],\n        rawType = !!value[ctfSymbols.rawType];\n\n    if (typeof toPostgres !== `function`) {\n      toPostgres = value.toPostgres;\n      rawType = !!value.rawType;\n    }\n\n    if (typeof toPostgres === `function`) {\n      if (toPostgres.constructor.name !== `Function`) {\n        throw new Error(`CTF does not support asynchronous toPostgres functions.`);\n      }\n\n      return {\n        toPostgres,\n        rawType\n      };\n    }\n  }\n\n  return null;\n} /////////////////////////////////////////\n// Wraps a text string in single quotes;\n\n\nfunction wrapText(text) {\n  return `'${text}'`;\n} ////////////////////////////////////////////////\n// Replaces each single-quote symbol ' with two,\n// for compliance with PostgreSQL strings.\n\n\nfunction safeText(text) {\n  return text.replace(/'/g, `''`);\n} /////////////////////////////////////////////\n// Throws an exception, if flag 'raw' is set.\n\n\nfunction throwIfRaw(raw) {\n  if (raw) {\n    throw new TypeError(`Values null/undefined cannot be used as raw text.`);\n  }\n} /////////////////////////////////////////////////////////////////////////////\n// Recursively resolves parameter-function, with an optional Calling Context.\n\n\nfunction resolveFunc(value, cc) {\n  while (typeof value === `function`) {\n    if (value.constructor.name !== `Function`) {\n      // Constructor name for asynchronous functions have different names:\n      // - 'GeneratorFunction' for ES6 generators\n      // - 'AsyncFunction' for ES7 async functions\n      throw new Error(`Cannot use asynchronous functions with query formatting.`);\n    }\n\n    value = value.call(cc, cc);\n  }\n\n  return value;\n} ///////////////////////////////////////////////////////////////////////////////////\n// It implements two types of formatting, depending on the 'values' passed:\n//\n// 1. format '$1, $2, etc', when 'values' is of type string, boolean, number, date,\n//    function or null (or an array of the same types, plus undefined values);\n// 2. format $*propName*, when 'values' is an object (not null and not Date),\n//    and where * is any of the supported open-close pairs: {}, (), [], <>, //\n//\n\n\nfunction formatQuery(query, values, raw, options) {\n  if (typeof query !== `string`) {\n    throw new TypeError(`Parameter 'query' must be a text string.`);\n  }\n\n  const ctf = getCTF(values);\n\n  if (ctf) {\n    // Custom Type Formatting\n    return formatQuery(query, resolveFunc(ctf.toPostgres, values), raw || ctf.rawType, options);\n  }\n\n  if (typeof values === `object` && values !== null) {\n    if (values instanceof Array) {\n      // $1, $2,... formatting to be applied;\n      return formatAs.array(query, values, raw, options);\n    }\n\n    if (!(values instanceof Date || values instanceof Buffer)) {\n      // $*propName* formatting to be applied;\n      return formatAs.object(query, values, raw, options);\n    }\n  } // $1 formatting to be applied, if values != undefined;\n\n\n  return values === undefined ? query : formatAs.value(query, values, raw, options);\n} //////////////////////////////////////////////////////\n// Formats a function or stored procedure call query;\n\n\nfunction formatEntity(entity, values, {\n  capSQL,\n  type\n}) {\n  let prefix = type === `func` ? `select * from` : `call`;\n\n  if (capSQL) {\n    prefix = prefix.toUpperCase();\n  }\n\n  return `${prefix} ${$as.alias(entity)} (${formatCSV(values, {\n    capSQL\n  })})`;\n}\n\nfunction formatSqlName(name) {\n  return `\"${name.replace(/\"/g, `\"\"`)}\"`;\n}\n/**\r\n * @namespace formatting\r\n * @description\r\n * Namespace for all query-formatting functions, available from `pgp.as` before and after initializing the library.\r\n *\r\n * @property {formatting.ctf} ctf\r\n * Namespace for symbols used by $[Custom Type Formatting].\r\n *\r\n * @property {function} alias\r\n * {@link formatting.alias alias} - formats an SQL alias.\r\n *\r\n * @property {function} name\r\n * {@link formatting.name name} - formats an SQL Name/Identifier.\r\n *\r\n * @property {function} text\r\n * {@link formatting.text text} - formats a text string.\r\n *\r\n * @property {function} number\r\n * {@link formatting.number number} - formats a number.\r\n *\r\n * @property {function} buffer\r\n * {@link formatting.buffer buffer} - formats a `Buffer` object.\r\n *\r\n * @property {function} value\r\n * {@link formatting.value value} - formats text as an open value.\r\n *\r\n * @property {function} json\r\n * {@link formatting.json json} - formats any value as JSON.\r\n *\r\n * @property {function} array\r\n * {@link formatting.array array} - formats an array of any depth.\r\n *\r\n * @property {function} csv\r\n * {@link formatting.csv csv} - formats an array as a list of comma-separated values.\r\n *\r\n * @property {function} func\r\n * {@link formatting.func func} - formats the value returned from a function.\r\n *\r\n * @property {function} format\r\n * {@link formatting.format format} - formats a query, according to parameters.\r\n *\r\n */\n\n\nconst $as = {\n  /**\r\n   * @namespace formatting.ctf\r\n   * @description\r\n   * Namespace for ES6 symbols used by $[Custom Type Formatting], available from `pgp.as.ctf` before and after initializing the library.\r\n   *\r\n   * It was added to avoid explicit/enumerable extension of types that need to be used as formatting parameters, to keep their type signature intact.\r\n   *\r\n   * @property {external:Symbol} toPostgres\r\n   * Property name for the $[Custom Type Formatting] callback function `toPostgres`.\r\n   *\r\n   * @property {external:Symbol} rawType\r\n   * Property name for the $[Custom Type Formatting] flag `rawType`.\r\n   *\r\n   * @example\r\n   * const ctf = pgp.as.ctf; // Custom Type Formatting symbols\r\n   *\r\n   * class MyType {\r\n   *     constructor() {\r\n   *         this[ctf.rawType] = true; // set it only when toPostgres returns a pre-formatted result\r\n   *     }\r\n   *\r\n   *     [ctf.toPostgres](self) {\r\n   *         // self = this\r\n   *\r\n   *         // return the custom/actual value here\r\n   *     }\r\n   * }\r\n   *\r\n   * const a = new MyType();\r\n   *\r\n   * const s = pgp.as.format('$1', a); // will be custom-formatted\r\n   */\n  ctf: ctfSymbols,\n\n  /**\r\n   * @method formatting.text\r\n   * @description\r\n   * Converts a value into PostgreSQL text presentation, escaped as required.\r\n   *\r\n   * Escaping the result means:\r\n   *  1. Every single-quote (apostrophe) is replaced with two\r\n   *  2. The resulting text is wrapped in apostrophes\r\n   *\r\n   * @param {value|function} value\r\n   * Value to be converted, or a function that returns the value.\r\n   *\r\n   * If the `value` resolves as `null` or `undefined`, while `raw`=`true`,\r\n   * it will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`\r\n   *\r\n   * @param {boolean} [raw=false]\r\n   * Indicates when not to escape the resulting text.\r\n   *\r\n   * @returns {string}\r\n   *\r\n   * - `null` string, if the `value` resolves as `null` or `undefined`\r\n   * - escaped result of `value.toString()`, if the `value` isn't a string\r\n   * - escaped string version, if `value` is a string.\r\n   *\r\n   *  The result is not escaped, if `raw` was passed in as `true`.\r\n   */\n  text(value, raw) {\n    value = resolveFunc(value);\n\n    if (isNull(value)) {\n      throwIfRaw(raw);\n      return `null`;\n    }\n\n    if (typeof value !== `string`) {\n      value = value.toString();\n    }\n\n    return $to.text(value, raw);\n  },\n\n  /**\r\n   * @method formatting.name\r\n   * @description\r\n   * Properly escapes an sql name or identifier, fixing double-quote symbols and wrapping the result in double quotes.\r\n   *\r\n   * Implements a safe way to format $[SQL Names] that neutralizes SQL Injection.\r\n   *\r\n   * When formatting a query, a variable makes use of this method via modifier `:name` or `~`. See method {@link formatting.format format}.\r\n   *\r\n   * @param {string|function|array|object} name\r\n   * SQL name or identifier, or a function that returns it.\r\n   *\r\n   * The name must be at least 1 character long.\r\n   *\r\n   * If `name` doesn't resolve into a non-empty string, it throws {@link external:TypeError TypeError} = `Invalid sql name: ...`\r\n   *\r\n   * If the `name` contains only a single `*` (trailing spaces are ignored), then `name` is returned exactly as is (unescaped).\r\n   *\r\n   * - If `name` is an Array, it is formatted as a comma-separated list of $[SQL Names]\r\n   * - If `name` is a non-Array object, its keys are formatted as a comma-separated list of $[SQL Names]\r\n   *\r\n   * Passing in an empty array/object will throw {@link external:Error Error} = `Cannot retrieve sql names from an empty array/object.`\r\n   *\r\n   * @returns {string}\r\n   * The SQL Name/Identifier, properly escaped for compliance with the PostgreSQL standard for $[SQL Names] and identifiers.\r\n   *\r\n   * @see\r\n   * {@link formatting.alias alias},\r\n   * {@link formatting.format format}\r\n   *\r\n   * @example\r\n   *\r\n   * // automatically list object properties as sql names:\r\n   * format('INSERT INTO table(${this~}) VALUES(${one}, ${two})', {\r\n   *     one: 1,\r\n   *     two: 2\r\n   * });\r\n   * //=> INSERT INTO table(\"one\",\"two\") VALUES(1, 2)\r\n   *\r\n   */\n  name(name) {\n    name = resolveFunc(name);\n\n    if (name) {\n      if (typeof name === `string`) {\n        return /^\\s*\\*(\\s*)$/.test(name) ? name : formatSqlName(name);\n      }\n\n      if (typeof name === `object`) {\n        const keys = Array.isArray(name) ? name : Object.keys(name);\n\n        if (!keys.length) {\n          throw new Error(`Cannot retrieve sql names from an empty array/object.`);\n        }\n\n        return keys.map(value => {\n          if (!value || typeof value !== `string`) {\n            throw new Error(`Invalid sql name: ${npm.utils.toJson(value)}`);\n          }\n\n          return formatSqlName(value);\n        }).join();\n      }\n    }\n\n    throw new TypeError(`Invalid sql name: ${npm.utils.toJson(name)}`);\n  },\n\n  /**\r\n   * @method formatting.alias\r\n   * @description\r\n   * Simpler (non-verbose) version of method {@link formatting.name name}, to handle only a regular string-identifier\r\n   * that's used as an SQL alias, i.e. it doesn't support `*` or an array/object of names, which in the context of\r\n   * an SQL alias would be incorrect.\r\n   *\r\n   * The surrounding double quotes are not added when the alias uses a simple syntax:\r\n   *  - it is a same-case single word, without spaces\r\n   *  - it can contain underscores, and can even start with them\r\n   *  - it can contain digits and `$`, but cannot start with those\r\n   *\r\n   * When formatting a query, a variable makes use of this method via modifier `:alias`. See method {@link formatting.format format}.\r\n   *\r\n   * @param {string|function} name\r\n   * SQL alias name, or a function that returns it.\r\n   *\r\n   * The name must be at least 1 character long.\r\n   *\r\n   * If `name` doesn't resolve into a non-empty string, it throws {@link external:TypeError TypeError} = `Invalid sql alias: ...`\r\n   *\r\n   * @returns {string}\r\n   * The SQL alias, properly escaped for compliance with the PostgreSQL standard for $[SQL Names] and identifiers.\r\n   *\r\n   * @see\r\n   * {@link formatting.name name},\r\n   * {@link formatting.format format}\r\n   *\r\n   */\n  alias(name) {\n    name = resolveFunc(name);\n\n    if (name && typeof name === `string`) {\n      const m = name.match(/^([a-z_][a-z0-9_$]*|[A-Z_][A-Z0-9_$]*)$/);\n\n      if (m && m[0] === name) {\n        return name;\n      }\n\n      return `\"${name.replace(/\"/g, `\"\"`)}\"`;\n    }\n\n    throw new TypeError(`Invalid sql alias: ${npm.utils.toJson(name)}`);\n  },\n\n  /**\r\n   * @method formatting.value\r\n   * @description\r\n   * Represents an open value, one to be formatted according to its type, properly escaped, but without surrounding quotes for text types.\r\n   *\r\n   * When formatting a query, a variable makes use of this method via modifier `:value` or `#`. See method {@link formatting.format format}.\r\n   *\r\n   * @param {value|function} value\r\n   * Value to be converted, or a function that returns the value.\r\n   *\r\n   * If `value` resolves as `null` or `undefined`, it will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`\r\n   *\r\n   * @returns {string}\r\n   * Formatted and properly escaped string, but without surrounding quotes for text types.\r\n   *\r\n   * @see {@link formatting.format format}\r\n   *\r\n   */\n  value(value) {\n    value = resolveFunc(value);\n\n    if (isNull(value)) {\n      throw new TypeError(`Open values cannot be null or undefined.`);\n    }\n\n    return safeText(formatValue({\n      value,\n      fm: fmFlags.raw\n    }));\n  },\n\n  /**\r\n   * @method formatting.buffer\r\n   * @description\r\n   * Converts an object of type `Buffer` into a hex string compatible with PostgreSQL type `bytea`.\r\n   *\r\n   * @param {Buffer|function} obj\r\n   * Object to be converted, or a function that returns one.\r\n   *\r\n   * @param {boolean} [raw=false]\r\n   * Indicates when not to wrap the resulting string in quotes.\r\n   *\r\n   * The generated hex string doesn't need to be escaped.\r\n   *\r\n   * @returns {string}\r\n   */\n  buffer(obj, raw) {\n    obj = resolveFunc(obj);\n\n    if (isNull(obj)) {\n      throwIfRaw(raw);\n      return `null`;\n    }\n\n    if (obj instanceof Buffer) {\n      return $to.buffer(obj, raw);\n    }\n\n    throw new TypeError(`${wrapText(obj)} is not a Buffer object.`);\n  },\n\n  /**\r\n   * @method formatting.bool\r\n   * @description\r\n   * Converts a truthy value into PostgreSQL boolean presentation.\r\n   *\r\n   * @param {boolean|function} value\r\n   * Value to be converted, or a function that returns the value.\r\n   *\r\n   * @returns {string}\r\n   */\n  bool(value) {\n    value = resolveFunc(value);\n\n    if (isNull(value)) {\n      return `null`;\n    }\n\n    return $to.bool(value);\n  },\n\n  /**\r\n   * @method formatting.date\r\n   * @description\r\n   * Converts a `Date`-type value into PostgreSQL date/time presentation,\r\n   * wrapped in quotes (unless flag `raw` is set).\r\n   *\r\n   * @param {Date|function} d\r\n   * Date object to be converted, or a function that returns one.\r\n   *\r\n   * @param {boolean} [raw=false]\r\n   * Indicates when not to escape the value.\r\n   *\r\n   * @returns {string}\r\n   */\n  date(d, raw) {\n    d = resolveFunc(d);\n\n    if (isNull(d)) {\n      throwIfRaw(raw);\n      return `null`;\n    }\n\n    if (d instanceof Date) {\n      return $to.date(d, raw);\n    }\n\n    throw new TypeError(`${wrapText(d)} is not a Date object.`);\n  },\n\n  /**\r\n   * @method formatting.number\r\n   * @description\r\n   * Converts a numeric value into its PostgreSQL number presentation, with support\r\n   * for special values of `NaN`, `+Infinity` and `-Infinity`.\r\n   *\r\n   * @param {number|bigint|function} num\r\n   * Number to be converted, or a function that returns one.\r\n   *\r\n   * @returns {string}\r\n   */\n  number(num) {\n    num = resolveFunc(num);\n\n    if (isNull(num)) {\n      return `null`;\n    }\n\n    const t = typeof num;\n\n    if (t !== `number` && t !== `bigint`) {\n      throw new TypeError(`${wrapText(num)} is not a number.`);\n    }\n\n    return $to.number(num);\n  },\n\n  /**\r\n   * @method formatting.array\r\n   * @description\r\n   * Converts an array of values into its PostgreSQL presentation as an Array-Type constructor string: `array[]`.\r\n   *\r\n   * Top-level empty arrays are formatted as literal `{}`, to avoid the necessity of explicit type casting,\r\n   * as the server cannot automatically infer type of an empty non-literal array.\r\n   *\r\n   * @param {Array|function} arr\r\n   * Array to be converted, or a function that returns one.\r\n   *\r\n   * @param {object} [options]\r\n   * Array-Formatting Options.\r\n   *\r\n   * @param {boolean} [options.capSQL=false]\r\n   * When `true`, outputs `ARRAY` instead of `array`.\r\n   *\r\n   * @returns {string}\r\n   */\n  array(arr, options) {\n    options = assertOptions(options, [`capSQL`]);\n    arr = resolveFunc(arr);\n\n    if (isNull(arr)) {\n      return `null`;\n    }\n\n    if (arr instanceof Array) {\n      return $to.array(arr, options);\n    }\n\n    throw new TypeError(`${wrapText(arr)} is not an Array object.`);\n  },\n\n  /**\r\n   * @method formatting.csv\r\n   * @description\r\n   * Converts a single value or an array of values into a CSV (comma-separated values) string, with all values formatted\r\n   * according to their JavaScript type.\r\n   *\r\n   * When formatting a query, a variable makes use of this method via modifier `:csv` or its alias `:list`.\r\n   *\r\n   * When `values` is an object that's not `null` or `Array`, its properties are enumerated for the actual values.\r\n   *\r\n   * @param {Array|Object|value|function} values\r\n   * Value(s) to be converted, or a function that returns it.\r\n   *\r\n   * @returns {string}\r\n   *\r\n   * @see {@link formatting.format format}\r\n   */\n  csv(values) {\n    return $to.csv(values);\n  },\n\n  /**\r\n   * @method formatting.json\r\n   * @description\r\n   * Converts any value into JSON, and returns it as a valid string, with single-quote symbols fixed, unless flag `raw` is set.\r\n   *\r\n   * When formatting a query, a variable makes use of this method via modifier `:json`. See method {@link formatting.format format}.\r\n   *\r\n   * @param {*} data\r\n   * Object/value to be converted, or a function that returns it.\r\n   *\r\n   * @param {boolean} [raw=false]\r\n   * Indicates when not to escape the result.\r\n   *\r\n   * @returns {string}\r\n   *\r\n   * @see {@link formatting.format format}\r\n   */\n  json(data, raw) {\n    data = resolveFunc(data);\n\n    if (isNull(data)) {\n      throwIfRaw(raw);\n      return `null`;\n    }\n\n    return $to.json(data, raw);\n  },\n\n  /**\r\n   * @method formatting.func\r\n   * @description\r\n   * Calls the function to get the actual value, and then formats the result\r\n   * according to its type + `raw` flag.\r\n   *\r\n   * @param {function} func\r\n   * Function to be called, with support for nesting.\r\n   *\r\n   * @param {boolean} [raw=false]\r\n   * Indicates when not to escape the result.\r\n   *\r\n   * @param {*} [cc]\r\n   * Calling Context: `this` + the only value to be passed into the function on all nested levels.\r\n   *\r\n   * @returns {string}\r\n   */\n  func(func, raw, cc) {\n    if (isNull(func)) {\n      throwIfRaw(raw);\n      return `null`;\n    }\n\n    if (typeof func !== `function`) {\n      throw new TypeError(`${wrapText(func)} is not a function.`);\n    }\n\n    const fm = raw ? fmFlags.raw : null;\n    return formatValue({\n      value: resolveFunc(func, cc),\n      fm,\n      cc\n    });\n  },\n\n  /**\r\n   * @method formatting.format\r\n   * @description\r\n   * Replaces variables in a string according to the type of `values`:\r\n   *\r\n   * - Replaces `$1` occurrences when `values` is of type `string`, `boolean`, `number`, `bigint`, `Date`, `Buffer` or when it is `null`.\r\n   *\r\n   * - Replaces variables `$1`, `$2`, ...`$100000` when `values` is an array of parameters. It throws a {@link external:RangeError RangeError}\r\n   * when the values or variables are out of range.\r\n   *\r\n   * - Replaces `$*propName*`, where `*` is any of `{}`, `()`, `[]`, `<>`, `//`, when `values` is an object that's not a\r\n   * `Date`, `Buffer`, {@link QueryFile} or `null`. Special property name `this` refers to the formatting object itself,\r\n   *   to be injected as a JSON string. When referencing a property that doesn't exist in the formatting object, it throws\r\n   *   {@link external:Error Error} = `Property 'PropName' doesn't exist`, unless option `partial` is used.\r\n   *\r\n   * - Supports $[Nested Named Parameters] of any depth.\r\n   *\r\n   * By default, each variable is automatically formatted according to its type, unless it is a special variable:\r\n   *\r\n   * - Raw-text variables end with `:raw` or symbol `^`, and prevent escaping the text. Such variables are not\r\n   *   allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`\r\n   *   - `$1:raw`, `$2:raw`,..., and `$*propName:raw*` (see `*` above)\r\n   *   - `$1^`, `$2^`,..., and `$*propName^*` (see `*` above)\r\n   *\r\n   * - Open-value variables end with `:value` or symbol `#`, to be escaped, but not wrapped in quotes. Such variables are\r\n   *   not allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`\r\n   *   - `$1:value`, `$2:value`,..., and `$*propName:value*` (see `*` above)\r\n   *   - `$1#`, `$2#`,..., and `$*propName#*` (see `*` above)\r\n   *\r\n   * - SQL name variables end with `:name` or symbol `~` (tilde), and provide proper escaping for SQL names/identifiers:\r\n   *   - `$1:name`, `$2:name`,..., and `$*propName:name*` (see `*` above)\r\n   *   - `$1~`, `$2~`,..., and `$*propName~*` (see `*` above)\r\n   *\r\n   * - Modifier `:alias` - non-verbose $[SQL Names] escaping.\r\n   *\r\n   * - JSON override ends with `:json` to format the value of any type as a JSON string\r\n   *\r\n   * - CSV override ends with `:csv` or `:list` to format an array as a properly escaped comma-separated list of values.\r\n   *\r\n   * @param {string|QueryFile|object} query\r\n   * A query string, a {@link QueryFile} or any object that implements $[Custom Type Formatting], to be formatted according to `values`.\r\n   *\r\n   * @param {array|object|value} [values]\r\n   * Formatting parameter(s) / variable value(s).\r\n   *\r\n   * @param {object} [options]\r\n   * Formatting Options.\r\n   *\r\n   * @param {boolean} [options.capSQL=false]\r\n   * Formats reserved SQL words capitalized. Presently, this only concerns arrays, to output `ARRAY` when required.\r\n   *\r\n   * @param {boolean} [options.partial=false]\r\n   * Indicates that we intend to do only a partial replacement, i.e. throw no error when encountering a variable or\r\n   * property name that's missing within the formatting parameters.\r\n   *\r\n   * **NOTE:** This option has no meaning when option `def` is used.\r\n   *\r\n   * @param {*} [options.def]\r\n   * Sets default value for every variable that's missing, consequently preventing errors when encountering a variable\r\n   * or property name that's missing within the formatting parameters.\r\n   *\r\n   * It can also be set to a function, to be called with two parameters that depend on the type of formatting being used,\r\n   * and to return the actual default value:\r\n   *\r\n   * - For $[Named Parameters] formatting:\r\n   *   - `name` - name of the property missing in the formatting object\r\n   *   - `obj` - the formatting object, and is the same as `this` context\r\n   *\r\n   * - For $[Index Variables] formatting:\r\n   *   - `index` - element's index (starts with 1) that's outside of the input array\r\n   *   - `arr` - the formatting/input array, and is the same as `this` context\r\n   *\r\n   *   You can tell which type of call it is by checking the type of the first parameter.\r\n   *\r\n   * @returns {string}\r\n   * Formatted query string.\r\n   *\r\n   * The function will throw an error, if any occurs during formatting.\r\n   */\n  format(query, values, options) {\n    options = assertOptions(options, [`capSQL`, `partial`, `def`]);\n    const ctf = getCTF(query);\n\n    if (ctf) {\n      query = ctf.toPostgres.call(query, query);\n    }\n\n    return formatQuery(query, values, false, options);\n  }\n\n};\n/* Pre-parsed type formatting */\n\nconst $to = {\n  array(arr, options) {\n    return formatArray(arr, options);\n  },\n\n  csv(values, options) {\n    return formatCSV(resolveFunc(values), options);\n  },\n\n  bool(value) {\n    return value ? `true` : `false`;\n  },\n\n  buffer(obj, raw) {\n    const s = `\\\\x${obj.toString(`hex`)}`;\n    return raw ? s : wrapText(s);\n  },\n\n  date(d, raw) {\n    const s = npm.pgUtils.prepareValue(d);\n    return raw ? s : wrapText(s);\n  },\n\n  json(data, raw) {\n    const s = npm.utils.toJson(data);\n    return raw ? s : wrapText(safeText(s));\n  },\n\n  number(num) {\n    if (typeof num === `bigint` || Number.isFinite(num)) {\n      return num.toString();\n    } // Converting NaN/+Infinity/-Infinity according to Postgres documentation:\n    // http://www.postgresql.org/docs/9.6/static/datatype-numeric.html#DATATYPE-FLOAT\n    //\n    // NOTE: strings for 'NaN'/'+Infinity'/'-Infinity' are not case-sensitive.\n\n\n    if (num === Number.POSITIVE_INFINITY) {\n      return wrapText(`+Infinity`);\n    }\n\n    if (num === Number.NEGATIVE_INFINITY) {\n      return wrapText(`-Infinity`);\n    }\n\n    return wrapText(`NaN`);\n  },\n\n  text(value, raw) {\n    return raw ? value : wrapText(safeText(value));\n  }\n\n};\nmodule.exports = {\n  formatQuery,\n  formatEntity,\n  resolveFunc,\n  as: $as\n};\n/**\r\n * @external Error\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\r\n */\n\n/**\r\n * @external TypeError\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\r\n */\n\n/**\r\n * @external RangeError\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError\r\n */\n\n/**\r\n * @external Symbol\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\r\n */","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg-promise/lib/formatting.js"],"names":["assertOptions","require","npm","pgUtils","patterns","utils","fmFlags","raw","alias","name","json","csv","value","fmMap","ctfSymbols","toPostgres","Symbol","for","rawType","maxVariable","formatValue","fm","cc","options","resolveFunc","ctf","getCTF","isRaw","$as","$to","isNull","throwIfRaw","text","bool","number","TypeError","toString","Date","date","Array","array","Buffer","buffer","formatArray","loop","a","map","join","prefix","capSQL","length","formatCSV","values","Object","keys","v","undefined","formatAs","object","query","obj","replace","namedParameters","stripName","c","getIfHas","valid","Error","has","target","d","def","call","partial","multipleValues","substr","idx","RangeError","singleValue","mod","match","hasValidModifier","index","constructor","wrapText","safeText","formatQuery","formatEntity","entity","type","toUpperCase","formatSqlName","test","isArray","toJson","m","num","t","arr","data","func","format","s","prepareValue","Number","isFinite","POSITIVE_INFINITY","NEGATIVE_INFINITY","module","exports","as"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */\r\n\r\nconst {assertOptions} = require(`assert-options`);\r\n\r\nconst npm = {\r\n    pgUtils: require(`pg/lib/utils`),\r\n    patterns: require(`./patterns`),\r\n    utils: require(`./utils`)\r\n};\r\n\r\n// Format Modification Flags;\r\nconst fmFlags = {\r\n    raw: 1, // Raw-Text variable\r\n    alias: 2, // SQL Alias\r\n    name: 4, // SQL Name/Identifier\r\n    json: 8, // JSON modifier\r\n    csv: 16, // CSV modifier\r\n    value: 32 // escaped, but without ''\r\n};\r\n\r\n// Format Modification Map;\r\nconst fmMap = {\r\n    '^': fmFlags.raw,\r\n    ':raw': fmFlags.raw,\r\n    ':alias': fmFlags.alias,\r\n    '~': fmFlags.name,\r\n    ':name': fmFlags.name,\r\n    ':json': fmFlags.json,\r\n    ':csv': fmFlags.csv,\r\n    ':list': fmFlags.csv,\r\n    ':value': fmFlags.value,\r\n    '#': fmFlags.value\r\n};\r\n\r\n// Global symbols for Custom Type Formatting:\r\nconst ctfSymbols = {\r\n    toPostgres: Symbol.for(`ctf.toPostgres`),\r\n    rawType: Symbol.for(`ctf.rawType`)\r\n};\r\n\r\nconst maxVariable = 100000; // maximum supported variable is '$100000'\r\n\r\n////////////////////////////////////////////////////\r\n// Converts a single value into its Postgres format.\r\nfunction formatValue({value, fm, cc, options}) {\r\n\r\n    if (typeof value === `function`) {\r\n        return formatValue({value: resolveFunc(value, cc), fm, cc});\r\n    }\r\n\r\n    const ctf = getCTF(value); // Custom Type Formatting\r\n    if (ctf) {\r\n        fm |= ctf.rawType ? fmFlags.raw : 0;\r\n        return formatValue({value: resolveFunc(ctf.toPostgres, value), fm, cc});\r\n    }\r\n\r\n    const isRaw = !!(fm & fmFlags.raw);\r\n    fm &= ~fmFlags.raw;\r\n\r\n    switch (fm) {\r\n        case fmFlags.alias:\r\n            return $as.alias(value);\r\n        case fmFlags.name:\r\n            return $as.name(value);\r\n        case fmFlags.json:\r\n            return $as.json(value, isRaw);\r\n        case fmFlags.csv:\r\n            return $to.csv(value, options);\r\n        case fmFlags.value:\r\n            return $as.value(value);\r\n        default:\r\n            break;\r\n    }\r\n\r\n    if (isNull(value)) {\r\n        throwIfRaw(isRaw);\r\n        return `null`;\r\n    }\r\n\r\n    switch (typeof value) {\r\n        case `string`:\r\n            return $to.text(value, isRaw);\r\n        case `boolean`:\r\n            return $to.bool(value);\r\n        case `number`:\r\n        case `bigint`:\r\n            return $to.number(value);\r\n        case `symbol`:\r\n            throw new TypeError(`Type Symbol has no meaning for PostgreSQL: ${value.toString()}`);\r\n        default:\r\n            if (value instanceof Date) {\r\n                return $to.date(value, isRaw);\r\n            }\r\n            if (value instanceof Array) {\r\n                return $to.array(value, options);\r\n            }\r\n            if (value instanceof Buffer) {\r\n                return $to.buffer(value, isRaw);\r\n            }\r\n            return $to.json(value, isRaw);\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// Converts array of values into PostgreSQL Array Constructor: array[...], as per PostgreSQL documentation:\r\n// http://www.postgresql.org/docs/9.6/static/arrays.html\r\n//\r\n// Arrays of any depth/dimension are supported.\r\n//\r\n// Top-level empty arrays are formatted as literal '{}' to avoid the necessity of explicit type casting,\r\n// as the server cannot automatically infer type of an empty non-literal array.\r\nfunction formatArray(array, options) {\r\n    const loop = a => `[` + a.map(value => value instanceof Array ? loop(value) : formatValue({\r\n        value,\r\n        options\r\n    })).join() + `]`;\r\n    const prefix = options && options.capSQL ? `ARRAY` : `array`;\r\n    return array.length ? (prefix + loop(array)) : `'{}'`;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////\r\n// Formats array/object/value as a list of comma-separated values.\r\nfunction formatCSV(values, options) {\r\n    if (values instanceof Array) {\r\n        return values.map(value => formatValue({value, options})).join();\r\n    }\r\n    if (typeof values === `object` && values !== null) {\r\n        return Object.keys(values).map(v => formatValue({value: values[v], options})).join();\r\n    }\r\n    return values === undefined ? `` : formatValue({value: values, options});\r\n}\r\n\r\n///////////////////////////////\r\n// Query formatting helpers;\r\nconst formatAs = {\r\n\r\n    object(query, obj, raw, options) {\r\n        options = options && typeof options === `object` ? options : {};\r\n        return query.replace(npm.patterns.namedParameters, name => {\r\n            const v = formatAs.stripName(name.replace(/^\\$[{(<[/]|[\\s})>\\]/]/g, ``), raw),\r\n                c = npm.utils.getIfHas(obj, v.name);\r\n            if (!c.valid) {\r\n                throw new Error(`Invalid property name '${v.name}'.`);\r\n            }\r\n            if (c.has) {\r\n                return formatValue({value: c.value, fm: v.fm, cc: c.target, options});\r\n            }\r\n            if (v.name === `this`) {\r\n                return formatValue({value: obj, fm: v.fm, options});\r\n            }\r\n            if (`def` in options) {\r\n                const d = options.def, value = typeof d === `function` ? d.call(obj, v.name, obj) : d;\r\n                return formatValue({value, fm: v.fm, cc: obj, options});\r\n            }\r\n            if (options.partial) {\r\n                return name;\r\n            }\r\n            // property must exist as the object's own or inherited;\r\n            throw new Error(`Property '${v.name}' doesn't exist.`);\r\n        });\r\n    },\r\n\r\n    array(query, array, raw, options) {\r\n        options = options && typeof options === `object` ? options : {};\r\n        return query.replace(npm.patterns.multipleValues, name => {\r\n            const v = formatAs.stripName(name.substr(1), raw);\r\n            const idx = v.name - 1;\r\n            if (idx >= maxVariable) {\r\n                throw new RangeError(`Variable $${v.name} exceeds supported maximum of $${maxVariable}`);\r\n            }\r\n            if (idx < array.length) {\r\n                return formatValue({value: array[idx], fm: v.fm, options});\r\n            }\r\n            if (`def` in options) {\r\n                const d = options.def, value = typeof d === `function` ? d.call(array, idx, array) : d;\r\n                return formatValue({value, fm: v.fm, options});\r\n            }\r\n            if (options.partial) {\r\n                return name;\r\n            }\r\n            throw new RangeError(`Variable $${v.name} out of range. Parameters array length: ${array.length}`);\r\n        });\r\n    },\r\n\r\n    value(query, value, raw, options) {\r\n        return query.replace(npm.patterns.singleValue, name => {\r\n            const v = formatAs.stripName(name, raw);\r\n            return formatValue({value, fm: v.fm, options});\r\n        });\r\n    },\r\n\r\n    stripName(name, raw) {\r\n        const mod = name.match(npm.patterns.hasValidModifier);\r\n        if (mod) {\r\n            return {\r\n                name: name.substr(0, mod.index),\r\n                fm: fmMap[mod[0]] | (raw ? fmFlags.raw : 0)\r\n            };\r\n        }\r\n        return {\r\n            name,\r\n            fm: raw ? fmFlags.raw : null\r\n        };\r\n    }\r\n};\r\n\r\n////////////////////////////////////////////\r\n// Simpler check for null/undefined;\r\nfunction isNull(value) {\r\n    return value === undefined || value === null;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////\r\n// Checks if the value supports Custom Type Formatting,\r\n// to return {toPostgres, rawType}, if it does, or null otherwise.\r\nfunction getCTF(value) {\r\n    if (!isNull(value)) {\r\n        let toPostgres = value[ctfSymbols.toPostgres], rawType = !!value[ctfSymbols.rawType];\r\n        if (typeof toPostgres !== `function`) {\r\n            toPostgres = value.toPostgres;\r\n            rawType = !!value.rawType;\r\n        }\r\n        if (typeof toPostgres === `function`) {\r\n            if (toPostgres.constructor.name !== `Function`) {\r\n                throw new Error(`CTF does not support asynchronous toPostgres functions.`);\r\n            }\r\n            return {toPostgres, rawType};\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/////////////////////////////////////////\r\n// Wraps a text string in single quotes;\r\nfunction wrapText(text) {\r\n    return `'${text}'`;\r\n}\r\n\r\n////////////////////////////////////////////////\r\n// Replaces each single-quote symbol ' with two,\r\n// for compliance with PostgreSQL strings.\r\nfunction safeText(text) {\r\n    return text.replace(/'/g, `''`);\r\n}\r\n\r\n/////////////////////////////////////////////\r\n// Throws an exception, if flag 'raw' is set.\r\nfunction throwIfRaw(raw) {\r\n    if (raw) {\r\n        throw new TypeError(`Values null/undefined cannot be used as raw text.`);\r\n    }\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Recursively resolves parameter-function, with an optional Calling Context.\r\nfunction resolveFunc(value, cc) {\r\n    while (typeof value === `function`) {\r\n        if (value.constructor.name !== `Function`) {\r\n            // Constructor name for asynchronous functions have different names:\r\n            // - 'GeneratorFunction' for ES6 generators\r\n            // - 'AsyncFunction' for ES7 async functions\r\n            throw new Error(`Cannot use asynchronous functions with query formatting.`);\r\n        }\r\n        value = value.call(cc, cc);\r\n    }\r\n    return value;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////////\r\n// It implements two types of formatting, depending on the 'values' passed:\r\n//\r\n// 1. format '$1, $2, etc', when 'values' is of type string, boolean, number, date,\r\n//    function or null (or an array of the same types, plus undefined values);\r\n// 2. format $*propName*, when 'values' is an object (not null and not Date),\r\n//    and where * is any of the supported open-close pairs: {}, (), [], <>, //\r\n//\r\nfunction formatQuery(query, values, raw, options) {\r\n    if (typeof query !== `string`) {\r\n        throw new TypeError(`Parameter 'query' must be a text string.`);\r\n    }\r\n    const ctf = getCTF(values);\r\n    if (ctf) {\r\n        // Custom Type Formatting\r\n        return formatQuery(query, resolveFunc(ctf.toPostgres, values), raw || ctf.rawType, options);\r\n    }\r\n    if (typeof values === `object` && values !== null) {\r\n        if (values instanceof Array) {\r\n            // $1, $2,... formatting to be applied;\r\n            return formatAs.array(query, values, raw, options);\r\n        }\r\n        if (!(values instanceof Date || values instanceof Buffer)) {\r\n            // $*propName* formatting to be applied;\r\n            return formatAs.object(query, values, raw, options);\r\n        }\r\n    }\r\n    // $1 formatting to be applied, if values != undefined;\r\n    return values === undefined ? query : formatAs.value(query, values, raw, options);\r\n}\r\n\r\n//////////////////////////////////////////////////////\r\n// Formats a function or stored procedure call query;\r\nfunction formatEntity(entity, values, {capSQL, type}) {\r\n    let prefix = type === `func` ? `select * from` : `call`;\r\n    if (capSQL) {\r\n        prefix = prefix.toUpperCase();\r\n    }\r\n    return `${prefix} ${$as.alias(entity)} (${formatCSV(values, {capSQL})})`;\r\n}\r\n\r\nfunction formatSqlName(name) {\r\n    return `\"${name.replace(/\"/g, `\"\"`)}\"`;\r\n}\r\n\r\n/**\r\n * @namespace formatting\r\n * @description\r\n * Namespace for all query-formatting functions, available from `pgp.as` before and after initializing the library.\r\n *\r\n * @property {formatting.ctf} ctf\r\n * Namespace for symbols used by $[Custom Type Formatting].\r\n *\r\n * @property {function} alias\r\n * {@link formatting.alias alias} - formats an SQL alias.\r\n *\r\n * @property {function} name\r\n * {@link formatting.name name} - formats an SQL Name/Identifier.\r\n *\r\n * @property {function} text\r\n * {@link formatting.text text} - formats a text string.\r\n *\r\n * @property {function} number\r\n * {@link formatting.number number} - formats a number.\r\n *\r\n * @property {function} buffer\r\n * {@link formatting.buffer buffer} - formats a `Buffer` object.\r\n *\r\n * @property {function} value\r\n * {@link formatting.value value} - formats text as an open value.\r\n *\r\n * @property {function} json\r\n * {@link formatting.json json} - formats any value as JSON.\r\n *\r\n * @property {function} array\r\n * {@link formatting.array array} - formats an array of any depth.\r\n *\r\n * @property {function} csv\r\n * {@link formatting.csv csv} - formats an array as a list of comma-separated values.\r\n *\r\n * @property {function} func\r\n * {@link formatting.func func} - formats the value returned from a function.\r\n *\r\n * @property {function} format\r\n * {@link formatting.format format} - formats a query, according to parameters.\r\n *\r\n */\r\nconst $as = {\r\n\r\n    /**\r\n     * @namespace formatting.ctf\r\n     * @description\r\n     * Namespace for ES6 symbols used by $[Custom Type Formatting], available from `pgp.as.ctf` before and after initializing the library.\r\n     *\r\n     * It was added to avoid explicit/enumerable extension of types that need to be used as formatting parameters, to keep their type signature intact.\r\n     *\r\n     * @property {external:Symbol} toPostgres\r\n     * Property name for the $[Custom Type Formatting] callback function `toPostgres`.\r\n     *\r\n     * @property {external:Symbol} rawType\r\n     * Property name for the $[Custom Type Formatting] flag `rawType`.\r\n     *\r\n     * @example\r\n     * const ctf = pgp.as.ctf; // Custom Type Formatting symbols\r\n     *\r\n     * class MyType {\r\n     *     constructor() {\r\n     *         this[ctf.rawType] = true; // set it only when toPostgres returns a pre-formatted result\r\n     *     }\r\n     *\r\n     *     [ctf.toPostgres](self) {\r\n     *         // self = this\r\n     *\r\n     *         // return the custom/actual value here\r\n     *     }\r\n     * }\r\n     *\r\n     * const a = new MyType();\r\n     *\r\n     * const s = pgp.as.format('$1', a); // will be custom-formatted\r\n     */\r\n    ctf: ctfSymbols,\r\n\r\n    /**\r\n     * @method formatting.text\r\n     * @description\r\n     * Converts a value into PostgreSQL text presentation, escaped as required.\r\n     *\r\n     * Escaping the result means:\r\n     *  1. Every single-quote (apostrophe) is replaced with two\r\n     *  2. The resulting text is wrapped in apostrophes\r\n     *\r\n     * @param {value|function} value\r\n     * Value to be converted, or a function that returns the value.\r\n     *\r\n     * If the `value` resolves as `null` or `undefined`, while `raw`=`true`,\r\n     * it will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the resulting text.\r\n     *\r\n     * @returns {string}\r\n     *\r\n     * - `null` string, if the `value` resolves as `null` or `undefined`\r\n     * - escaped result of `value.toString()`, if the `value` isn't a string\r\n     * - escaped string version, if `value` is a string.\r\n     *\r\n     *  The result is not escaped, if `raw` was passed in as `true`.\r\n     */\r\n    text(value, raw) {\r\n        value = resolveFunc(value);\r\n        if (isNull(value)) {\r\n            throwIfRaw(raw);\r\n            return `null`;\r\n        }\r\n        if (typeof value !== `string`) {\r\n            value = value.toString();\r\n        }\r\n        return $to.text(value, raw);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.name\r\n     * @description\r\n     * Properly escapes an sql name or identifier, fixing double-quote symbols and wrapping the result in double quotes.\r\n     *\r\n     * Implements a safe way to format $[SQL Names] that neutralizes SQL Injection.\r\n     *\r\n     * When formatting a query, a variable makes use of this method via modifier `:name` or `~`. See method {@link formatting.format format}.\r\n     *\r\n     * @param {string|function|array|object} name\r\n     * SQL name or identifier, or a function that returns it.\r\n     *\r\n     * The name must be at least 1 character long.\r\n     *\r\n     * If `name` doesn't resolve into a non-empty string, it throws {@link external:TypeError TypeError} = `Invalid sql name: ...`\r\n     *\r\n     * If the `name` contains only a single `*` (trailing spaces are ignored), then `name` is returned exactly as is (unescaped).\r\n     *\r\n     * - If `name` is an Array, it is formatted as a comma-separated list of $[SQL Names]\r\n     * - If `name` is a non-Array object, its keys are formatted as a comma-separated list of $[SQL Names]\r\n     *\r\n     * Passing in an empty array/object will throw {@link external:Error Error} = `Cannot retrieve sql names from an empty array/object.`\r\n     *\r\n     * @returns {string}\r\n     * The SQL Name/Identifier, properly escaped for compliance with the PostgreSQL standard for $[SQL Names] and identifiers.\r\n     *\r\n     * @see\r\n     * {@link formatting.alias alias},\r\n     * {@link formatting.format format}\r\n     *\r\n     * @example\r\n     *\r\n     * // automatically list object properties as sql names:\r\n     * format('INSERT INTO table(${this~}) VALUES(${one}, ${two})', {\r\n     *     one: 1,\r\n     *     two: 2\r\n     * });\r\n     * //=> INSERT INTO table(\"one\",\"two\") VALUES(1, 2)\r\n     *\r\n     */\r\n    name(name) {\r\n        name = resolveFunc(name);\r\n        if (name) {\r\n            if (typeof name === `string`) {\r\n                return /^\\s*\\*(\\s*)$/.test(name) ? name : formatSqlName(name);\r\n            }\r\n            if (typeof name === `object`) {\r\n                const keys = Array.isArray(name) ? name : Object.keys(name);\r\n                if (!keys.length) {\r\n                    throw new Error(`Cannot retrieve sql names from an empty array/object.`);\r\n                }\r\n                return keys.map(value => {\r\n                    if (!value || typeof value !== `string`) {\r\n                        throw new Error(`Invalid sql name: ${npm.utils.toJson(value)}`);\r\n                    }\r\n                    return formatSqlName(value);\r\n                }).join();\r\n            }\r\n        }\r\n        throw new TypeError(`Invalid sql name: ${npm.utils.toJson(name)}`);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.alias\r\n     * @description\r\n     * Simpler (non-verbose) version of method {@link formatting.name name}, to handle only a regular string-identifier\r\n     * that's used as an SQL alias, i.e. it doesn't support `*` or an array/object of names, which in the context of\r\n     * an SQL alias would be incorrect.\r\n     *\r\n     * The surrounding double quotes are not added when the alias uses a simple syntax:\r\n     *  - it is a same-case single word, without spaces\r\n     *  - it can contain underscores, and can even start with them\r\n     *  - it can contain digits and `$`, but cannot start with those\r\n     *\r\n     * When formatting a query, a variable makes use of this method via modifier `:alias`. See method {@link formatting.format format}.\r\n     *\r\n     * @param {string|function} name\r\n     * SQL alias name, or a function that returns it.\r\n     *\r\n     * The name must be at least 1 character long.\r\n     *\r\n     * If `name` doesn't resolve into a non-empty string, it throws {@link external:TypeError TypeError} = `Invalid sql alias: ...`\r\n     *\r\n     * @returns {string}\r\n     * The SQL alias, properly escaped for compliance with the PostgreSQL standard for $[SQL Names] and identifiers.\r\n     *\r\n     * @see\r\n     * {@link formatting.name name},\r\n     * {@link formatting.format format}\r\n     *\r\n     */\r\n    alias(name) {\r\n        name = resolveFunc(name);\r\n        if (name && typeof name === `string`) {\r\n            const m = name.match(/^([a-z_][a-z0-9_$]*|[A-Z_][A-Z0-9_$]*)$/);\r\n            if (m && m[0] === name) {\r\n                return name;\r\n            }\r\n            return `\"${name.replace(/\"/g, `\"\"`)}\"`;\r\n        }\r\n        throw new TypeError(`Invalid sql alias: ${npm.utils.toJson(name)}`);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.value\r\n     * @description\r\n     * Represents an open value, one to be formatted according to its type, properly escaped, but without surrounding quotes for text types.\r\n     *\r\n     * When formatting a query, a variable makes use of this method via modifier `:value` or `#`. See method {@link formatting.format format}.\r\n     *\r\n     * @param {value|function} value\r\n     * Value to be converted, or a function that returns the value.\r\n     *\r\n     * If `value` resolves as `null` or `undefined`, it will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`\r\n     *\r\n     * @returns {string}\r\n     * Formatted and properly escaped string, but without surrounding quotes for text types.\r\n     *\r\n     * @see {@link formatting.format format}\r\n     *\r\n     */\r\n    value(value) {\r\n        value = resolveFunc(value);\r\n        if (isNull(value)) {\r\n            throw new TypeError(`Open values cannot be null or undefined.`);\r\n        }\r\n        return safeText(formatValue({value, fm: fmFlags.raw}));\r\n    },\r\n\r\n    /**\r\n     * @method formatting.buffer\r\n     * @description\r\n     * Converts an object of type `Buffer` into a hex string compatible with PostgreSQL type `bytea`.\r\n     *\r\n     * @param {Buffer|function} obj\r\n     * Object to be converted, or a function that returns one.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to wrap the resulting string in quotes.\r\n     *\r\n     * The generated hex string doesn't need to be escaped.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    buffer(obj, raw) {\r\n        obj = resolveFunc(obj);\r\n        if (isNull(obj)) {\r\n            throwIfRaw(raw);\r\n            return `null`;\r\n        }\r\n        if (obj instanceof Buffer) {\r\n            return $to.buffer(obj, raw);\r\n        }\r\n        throw new TypeError(`${wrapText(obj)} is not a Buffer object.`);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.bool\r\n     * @description\r\n     * Converts a truthy value into PostgreSQL boolean presentation.\r\n     *\r\n     * @param {boolean|function} value\r\n     * Value to be converted, or a function that returns the value.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    bool(value) {\r\n        value = resolveFunc(value);\r\n        if (isNull(value)) {\r\n            return `null`;\r\n        }\r\n        return $to.bool(value);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.date\r\n     * @description\r\n     * Converts a `Date`-type value into PostgreSQL date/time presentation,\r\n     * wrapped in quotes (unless flag `raw` is set).\r\n     *\r\n     * @param {Date|function} d\r\n     * Date object to be converted, or a function that returns one.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the value.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    date(d, raw) {\r\n        d = resolveFunc(d);\r\n        if (isNull(d)) {\r\n            throwIfRaw(raw);\r\n            return `null`;\r\n        }\r\n        if (d instanceof Date) {\r\n            return $to.date(d, raw);\r\n        }\r\n        throw new TypeError(`${wrapText(d)} is not a Date object.`);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.number\r\n     * @description\r\n     * Converts a numeric value into its PostgreSQL number presentation, with support\r\n     * for special values of `NaN`, `+Infinity` and `-Infinity`.\r\n     *\r\n     * @param {number|bigint|function} num\r\n     * Number to be converted, or a function that returns one.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    number(num) {\r\n        num = resolveFunc(num);\r\n        if (isNull(num)) {\r\n            return `null`;\r\n        }\r\n        const t = typeof num;\r\n        if (t !== `number` && t !== `bigint`) {\r\n            throw new TypeError(`${wrapText(num)} is not a number.`);\r\n        }\r\n        return $to.number(num);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.array\r\n     * @description\r\n     * Converts an array of values into its PostgreSQL presentation as an Array-Type constructor string: `array[]`.\r\n     *\r\n     * Top-level empty arrays are formatted as literal `{}`, to avoid the necessity of explicit type casting,\r\n     * as the server cannot automatically infer type of an empty non-literal array.\r\n     *\r\n     * @param {Array|function} arr\r\n     * Array to be converted, or a function that returns one.\r\n     *\r\n     * @param {object} [options]\r\n     * Array-Formatting Options.\r\n     *\r\n     * @param {boolean} [options.capSQL=false]\r\n     * When `true`, outputs `ARRAY` instead of `array`.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    array(arr, options) {\r\n        options = assertOptions(options, [`capSQL`]);\r\n        arr = resolveFunc(arr);\r\n        if (isNull(arr)) {\r\n            return `null`;\r\n        }\r\n        if (arr instanceof Array) {\r\n            return $to.array(arr, options);\r\n        }\r\n        throw new TypeError(`${wrapText(arr)} is not an Array object.`);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.csv\r\n     * @description\r\n     * Converts a single value or an array of values into a CSV (comma-separated values) string, with all values formatted\r\n     * according to their JavaScript type.\r\n     *\r\n     * When formatting a query, a variable makes use of this method via modifier `:csv` or its alias `:list`.\r\n     *\r\n     * When `values` is an object that's not `null` or `Array`, its properties are enumerated for the actual values.\r\n     *\r\n     * @param {Array|Object|value|function} values\r\n     * Value(s) to be converted, or a function that returns it.\r\n     *\r\n     * @returns {string}\r\n     *\r\n     * @see {@link formatting.format format}\r\n     */\r\n    csv(values) {\r\n        return $to.csv(values);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.json\r\n     * @description\r\n     * Converts any value into JSON, and returns it as a valid string, with single-quote symbols fixed, unless flag `raw` is set.\r\n     *\r\n     * When formatting a query, a variable makes use of this method via modifier `:json`. See method {@link formatting.format format}.\r\n     *\r\n     * @param {*} data\r\n     * Object/value to be converted, or a function that returns it.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the result.\r\n     *\r\n     * @returns {string}\r\n     *\r\n     * @see {@link formatting.format format}\r\n     */\r\n    json(data, raw) {\r\n        data = resolveFunc(data);\r\n        if (isNull(data)) {\r\n            throwIfRaw(raw);\r\n            return `null`;\r\n        }\r\n        return $to.json(data, raw);\r\n    },\r\n\r\n    /**\r\n     * @method formatting.func\r\n     * @description\r\n     * Calls the function to get the actual value, and then formats the result\r\n     * according to its type + `raw` flag.\r\n     *\r\n     * @param {function} func\r\n     * Function to be called, with support for nesting.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the result.\r\n     *\r\n     * @param {*} [cc]\r\n     * Calling Context: `this` + the only value to be passed into the function on all nested levels.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    func(func, raw, cc) {\r\n        if (isNull(func)) {\r\n            throwIfRaw(raw);\r\n            return `null`;\r\n        }\r\n        if (typeof func !== `function`) {\r\n            throw new TypeError(`${wrapText(func)} is not a function.`);\r\n        }\r\n        const fm = raw ? fmFlags.raw : null;\r\n        return formatValue({value: resolveFunc(func, cc), fm, cc});\r\n    },\r\n\r\n    /**\r\n     * @method formatting.format\r\n     * @description\r\n     * Replaces variables in a string according to the type of `values`:\r\n     *\r\n     * - Replaces `$1` occurrences when `values` is of type `string`, `boolean`, `number`, `bigint`, `Date`, `Buffer` or when it is `null`.\r\n     *\r\n     * - Replaces variables `$1`, `$2`, ...`$100000` when `values` is an array of parameters. It throws a {@link external:RangeError RangeError}\r\n     * when the values or variables are out of range.\r\n     *\r\n     * - Replaces `$*propName*`, where `*` is any of `{}`, `()`, `[]`, `<>`, `//`, when `values` is an object that's not a\r\n     * `Date`, `Buffer`, {@link QueryFile} or `null`. Special property name `this` refers to the formatting object itself,\r\n     *   to be injected as a JSON string. When referencing a property that doesn't exist in the formatting object, it throws\r\n     *   {@link external:Error Error} = `Property 'PropName' doesn't exist`, unless option `partial` is used.\r\n     *\r\n     * - Supports $[Nested Named Parameters] of any depth.\r\n     *\r\n     * By default, each variable is automatically formatted according to its type, unless it is a special variable:\r\n     *\r\n     * - Raw-text variables end with `:raw` or symbol `^`, and prevent escaping the text. Such variables are not\r\n     *   allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`\r\n     *   - `$1:raw`, `$2:raw`,..., and `$*propName:raw*` (see `*` above)\r\n     *   - `$1^`, `$2^`,..., and `$*propName^*` (see `*` above)\r\n     *\r\n     * - Open-value variables end with `:value` or symbol `#`, to be escaped, but not wrapped in quotes. Such variables are\r\n     *   not allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`\r\n     *   - `$1:value`, `$2:value`,..., and `$*propName:value*` (see `*` above)\r\n     *   - `$1#`, `$2#`,..., and `$*propName#*` (see `*` above)\r\n     *\r\n     * - SQL name variables end with `:name` or symbol `~` (tilde), and provide proper escaping for SQL names/identifiers:\r\n     *   - `$1:name`, `$2:name`,..., and `$*propName:name*` (see `*` above)\r\n     *   - `$1~`, `$2~`,..., and `$*propName~*` (see `*` above)\r\n     *\r\n     * - Modifier `:alias` - non-verbose $[SQL Names] escaping.\r\n     *\r\n     * - JSON override ends with `:json` to format the value of any type as a JSON string\r\n     *\r\n     * - CSV override ends with `:csv` or `:list` to format an array as a properly escaped comma-separated list of values.\r\n     *\r\n     * @param {string|QueryFile|object} query\r\n     * A query string, a {@link QueryFile} or any object that implements $[Custom Type Formatting], to be formatted according to `values`.\r\n     *\r\n     * @param {array|object|value} [values]\r\n     * Formatting parameter(s) / variable value(s).\r\n     *\r\n     * @param {object} [options]\r\n     * Formatting Options.\r\n     *\r\n     * @param {boolean} [options.capSQL=false]\r\n     * Formats reserved SQL words capitalized. Presently, this only concerns arrays, to output `ARRAY` when required.\r\n     *\r\n     * @param {boolean} [options.partial=false]\r\n     * Indicates that we intend to do only a partial replacement, i.e. throw no error when encountering a variable or\r\n     * property name that's missing within the formatting parameters.\r\n     *\r\n     * **NOTE:** This option has no meaning when option `def` is used.\r\n     *\r\n     * @param {*} [options.def]\r\n     * Sets default value for every variable that's missing, consequently preventing errors when encountering a variable\r\n     * or property name that's missing within the formatting parameters.\r\n     *\r\n     * It can also be set to a function, to be called with two parameters that depend on the type of formatting being used,\r\n     * and to return the actual default value:\r\n     *\r\n     * - For $[Named Parameters] formatting:\r\n     *   - `name` - name of the property missing in the formatting object\r\n     *   - `obj` - the formatting object, and is the same as `this` context\r\n     *\r\n     * - For $[Index Variables] formatting:\r\n     *   - `index` - element's index (starts with 1) that's outside of the input array\r\n     *   - `arr` - the formatting/input array, and is the same as `this` context\r\n     *\r\n     *   You can tell which type of call it is by checking the type of the first parameter.\r\n     *\r\n     * @returns {string}\r\n     * Formatted query string.\r\n     *\r\n     * The function will throw an error, if any occurs during formatting.\r\n     */\r\n    format(query, values, options) {\r\n        options = assertOptions(options, [`capSQL`, `partial`, `def`]);\r\n        const ctf = getCTF(query);\r\n        if (ctf) {\r\n            query = ctf.toPostgres.call(query, query);\r\n        }\r\n        return formatQuery(query, values, false, options);\r\n    }\r\n};\r\n\r\n/* Pre-parsed type formatting */\r\nconst $to = {\r\n    array(arr, options) {\r\n        return formatArray(arr, options);\r\n    },\r\n    csv(values, options) {\r\n        return formatCSV(resolveFunc(values), options);\r\n    },\r\n    bool(value) {\r\n        return value ? `true` : `false`;\r\n    },\r\n    buffer(obj, raw) {\r\n        const s = `\\\\x${obj.toString(`hex`)}`;\r\n        return raw ? s : wrapText(s);\r\n    },\r\n    date(d, raw) {\r\n        const s = npm.pgUtils.prepareValue(d);\r\n        return raw ? s : wrapText(s);\r\n    },\r\n    json(data, raw) {\r\n        const s = npm.utils.toJson(data);\r\n        return raw ? s : wrapText(safeText(s));\r\n    },\r\n    number(num) {\r\n        if (typeof num === `bigint` || Number.isFinite(num)) {\r\n            return num.toString();\r\n        }\r\n        // Converting NaN/+Infinity/-Infinity according to Postgres documentation:\r\n        // http://www.postgresql.org/docs/9.6/static/datatype-numeric.html#DATATYPE-FLOAT\r\n        //\r\n        // NOTE: strings for 'NaN'/'+Infinity'/'-Infinity' are not case-sensitive.\r\n        if (num === Number.POSITIVE_INFINITY) {\r\n            return wrapText(`+Infinity`);\r\n        }\r\n        if (num === Number.NEGATIVE_INFINITY) {\r\n            return wrapText(`-Infinity`);\r\n        }\r\n        return wrapText(`NaN`);\r\n    },\r\n    text(value, raw) {\r\n        return raw ? value : wrapText(safeText(value));\r\n    }\r\n};\r\n\r\nmodule.exports = {\r\n    formatQuery,\r\n    formatEntity,\r\n    resolveFunc,\r\n    as: $as\r\n};\r\n\r\n/**\r\n * @external Error\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\r\n */\r\n\r\n/**\r\n * @external TypeError\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\r\n */\r\n\r\n/**\r\n * @external RangeError\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError\r\n */\r\n\r\n/**\r\n * @external Symbol\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\r\n */\r\n"]},"metadata":{},"sourceType":"script"}